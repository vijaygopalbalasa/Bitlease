"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@gemini-wallet";
exports.ids = ["vendor-chunks/@gemini-wallet"];
exports.modules = {

/***/ "(ssr)/./node_modules/@gemini-wallet/core/dist/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@gemini-wallet/core/dist/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Communicator: () => (/* binding */ Communicator),\n/* harmony export */   DEFAULT_CHAIN_ID: () => (/* binding */ DEFAULT_CHAIN_ID),\n/* harmony export */   GeminiSdkEvent: () => (/* binding */ GeminiSdkEvent),\n/* harmony export */   GeminiStorage: () => (/* binding */ GeminiStorage),\n/* harmony export */   GeminiWallet: () => (/* binding */ GeminiWallet),\n/* harmony export */   GeminiWalletProvider: () => (/* binding */ GeminiWalletProvider),\n/* harmony export */   POPUP_HEIGHT: () => (/* binding */ POPUP_HEIGHT),\n/* harmony export */   POPUP_WIDTH: () => (/* binding */ POPUP_WIDTH),\n/* harmony export */   ProviderEventEmitter: () => (/* binding */ ProviderEventEmitter),\n/* harmony export */   SDK_BACKEND_URL: () => (/* binding */ SDK_BACKEND_URL),\n/* harmony export */   SDK_VERSION: () => (/* binding */ SDK_VERSION),\n/* harmony export */   STORAGE_ETH_ACCOUNTS_KEY: () => (/* binding */ STORAGE_ETH_ACCOUNTS_KEY),\n/* harmony export */   STORAGE_ETH_ACTIVE_CHAIN_KEY: () => (/* binding */ STORAGE_ETH_ACTIVE_CHAIN_KEY),\n/* harmony export */   STORAGE_PASSKEY_CREDENTIAL_KEY: () => (/* binding */ STORAGE_PASSKEY_CREDENTIAL_KEY),\n/* harmony export */   STORAGE_SETTINGS_KEY: () => (/* binding */ STORAGE_SETTINGS_KEY),\n/* harmony export */   STORAGE_SMART_ACCOUNT_KEY: () => (/* binding */ STORAGE_SMART_ACCOUNT_KEY),\n/* harmony export */   base64ToHex: () => (/* binding */ base64ToHex),\n/* harmony export */   bufferToBase64URLString: () => (/* binding */ bufferToBase64URLString),\n/* harmony export */   calculateWalletAddress: () => (/* binding */ calculateWalletAddress),\n/* harmony export */   closePopup: () => (/* binding */ closePopup),\n/* harmony export */   convertSendValuesToBigInt: () => (/* binding */ convertSendValuesToBigInt),\n/* harmony export */   decodeBase64: () => (/* binding */ decodeBase64),\n/* harmony export */   encodeBase64: () => (/* binding */ encodeBase64),\n/* harmony export */   fetchRpcRequest: () => (/* binding */ fetchRpcRequest),\n/* harmony export */   generateAuthenticatorIdHash: () => (/* binding */ generateAuthenticatorIdHash),\n/* harmony export */   generateRequestId: () => (/* binding */ generateRequestId),\n/* harmony export */   hexStringFromNumber: () => (/* binding */ hexStringFromNumber),\n/* harmony export */   openPopup: () => (/* binding */ openPopup),\n/* harmony export */   reverseResolveEns: () => (/* binding */ reverseResolveEns),\n/* harmony export */   safeJsonStringify: () => (/* binding */ safeJsonStringify),\n/* harmony export */   utf8StringToBuffer: () => (/* binding */ utf8StringToBuffer),\n/* harmony export */   validateRpcRequestArgs: () => (/* binding */ validateRpcRequestArgs),\n/* harmony export */   validateWebAuthnKey: () => (/* binding */ validateWebAuthnKey)\n/* harmony export */ });\nvar __create = Object.create;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __toESM = (mod, isNodeMode, target) => {\n  target = mod != null ? __create(__getProtoOf(mod)) : {};\n  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target;\n  for (let key of __getOwnPropNames(mod))\n    if (!__hasOwnProp.call(to, key))\n      __defProp(to, key, {\n        get: () => mod[key],\n        enumerable: true\n      });\n  return to;\n};\nvar __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);\nvar __esm = (fn, res) => () => (fn && (res = fn(fn = 0)), res);\n\n// node_modules/@noble/hashes/esm/_u64.js\nfunction fromBig(n, le = false) {\n  if (le)\n    return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };\n  return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\nfunction split(lst, le = false) {\n  const len = lst.length;\n  let Ah = new Uint32Array(len);\n  let Al = new Uint32Array(len);\n  for (let i = 0;i < len; i++) {\n    const { h, l } = fromBig(lst[i], le);\n    [Ah[i], Al[i]] = [h, l];\n  }\n  return [Ah, Al];\n}\nvar U32_MASK64, _32n, rotlSH = (h, l, s) => h << s | l >>> 32 - s, rotlSL = (h, l, s) => l << s | h >>> 32 - s, rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s, rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;\nvar init__u64 = __esm(() => {\n  U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\n  _32n = /* @__PURE__ */ BigInt(32);\n});\n\n// node_modules/@noble/hashes/esm/utils.js\nfunction isBytes(a) {\n  return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === \"Uint8Array\";\n}\nfunction anumber(n) {\n  if (!Number.isSafeInteger(n) || n < 0)\n    throw new Error(\"positive integer expected, got \" + n);\n}\nfunction abytes(b, ...lengths) {\n  if (!isBytes(b))\n    throw new Error(\"Uint8Array expected\");\n  if (lengths.length > 0 && !lengths.includes(b.length))\n    throw new Error(\"Uint8Array expected of length \" + lengths + \", got length=\" + b.length);\n}\nfunction aexists(instance, checkFinished = true) {\n  if (instance.destroyed)\n    throw new Error(\"Hash instance has been destroyed\");\n  if (checkFinished && instance.finished)\n    throw new Error(\"Hash#digest() has already been called\");\n}\nfunction aoutput(out, instance) {\n  abytes(out);\n  const min = instance.outputLen;\n  if (out.length < min) {\n    throw new Error(\"digestInto() expects output buffer of length at least \" + min);\n  }\n}\nfunction u32(arr) {\n  return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n}\nfunction clean(...arrays) {\n  for (let i = 0;i < arrays.length; i++) {\n    arrays[i].fill(0);\n  }\n}\nfunction createView(arr) {\n  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n}\nfunction rotr(word, shift) {\n  return word << 32 - shift | word >>> shift;\n}\nfunction byteSwap(word) {\n  return word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;\n}\nfunction byteSwap32(arr) {\n  for (let i = 0;i < arr.length; i++) {\n    arr[i] = byteSwap(arr[i]);\n  }\n  return arr;\n}\nfunction utf8ToBytes(str) {\n  if (typeof str !== \"string\")\n    throw new Error(\"string expected\");\n  return new Uint8Array(new TextEncoder().encode(str));\n}\nfunction toBytes(data) {\n  if (typeof data === \"string\")\n    data = utf8ToBytes(data);\n  abytes(data);\n  return data;\n}\n\nclass Hash {\n}\nfunction createHasher(hashCons) {\n  const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n  const tmp = hashCons();\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = () => hashCons();\n  return hashC;\n}\nvar isLE, swap32IfBE;\nvar init_utils = __esm(() => {\n  /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n  isLE = /* @__PURE__ */ (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();\n  swap32IfBE = isLE ? (u) => u : byteSwap32;\n});\n\n// node_modules/@noble/hashes/esm/sha3.js\nfunction keccakP(s, rounds = 24) {\n  const B = new Uint32Array(5 * 2);\n  for (let round = 24 - rounds;round < 24; round++) {\n    for (let x = 0;x < 10; x++)\n      B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];\n    for (let x = 0;x < 10; x += 2) {\n      const idx1 = (x + 8) % 10;\n      const idx0 = (x + 2) % 10;\n      const B0 = B[idx0];\n      const B1 = B[idx0 + 1];\n      const Th = rotlH(B0, B1, 1) ^ B[idx1];\n      const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];\n      for (let y = 0;y < 50; y += 10) {\n        s[x + y] ^= Th;\n        s[x + y + 1] ^= Tl;\n      }\n    }\n    let curH = s[2];\n    let curL = s[3];\n    for (let t = 0;t < 24; t++) {\n      const shift = SHA3_ROTL[t];\n      const Th = rotlH(curH, curL, shift);\n      const Tl = rotlL(curH, curL, shift);\n      const PI = SHA3_PI[t];\n      curH = s[PI];\n      curL = s[PI + 1];\n      s[PI] = Th;\n      s[PI + 1] = Tl;\n    }\n    for (let y = 0;y < 50; y += 10) {\n      for (let x = 0;x < 10; x++)\n        B[x] = s[y + x];\n      for (let x = 0;x < 10; x++)\n        s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];\n    }\n    s[0] ^= SHA3_IOTA_H[round];\n    s[1] ^= SHA3_IOTA_L[round];\n  }\n  clean(B);\n}\nvar _0n, _1n, _2n, _7n, _256n, _0x71n, SHA3_PI, SHA3_ROTL, _SHA3_IOTA, IOTAS, SHA3_IOTA_H, SHA3_IOTA_L, rotlH = (h, l, s) => s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s), rotlL = (h, l, s) => s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s), Keccak, gen = (suffix, blockLen, outputLen) => createHasher(() => new Keccak(blockLen, suffix, outputLen)), keccak_256;\nvar init_sha3 = __esm(() => {\n  init__u64();\n  init_utils();\n  _0n = BigInt(0);\n  _1n = BigInt(1);\n  _2n = BigInt(2);\n  _7n = BigInt(7);\n  _256n = BigInt(256);\n  _0x71n = BigInt(113);\n  SHA3_PI = [];\n  SHA3_ROTL = [];\n  _SHA3_IOTA = [];\n  for (let round = 0, R = _1n, x = 1, y = 0;round < 24; round++) {\n    [x, y] = [y, (2 * x + 3 * y) % 5];\n    SHA3_PI.push(2 * (5 * y + x));\n    SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);\n    let t = _0n;\n    for (let j = 0;j < 7; j++) {\n      R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;\n      if (R & _2n)\n        t ^= _1n << (_1n << /* @__PURE__ */ BigInt(j)) - _1n;\n    }\n    _SHA3_IOTA.push(t);\n  }\n  IOTAS = split(_SHA3_IOTA, true);\n  SHA3_IOTA_H = IOTAS[0];\n  SHA3_IOTA_L = IOTAS[1];\n  Keccak = class Keccak extends Hash {\n    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {\n      super();\n      this.pos = 0;\n      this.posOut = 0;\n      this.finished = false;\n      this.destroyed = false;\n      this.enableXOF = false;\n      this.blockLen = blockLen;\n      this.suffix = suffix;\n      this.outputLen = outputLen;\n      this.enableXOF = enableXOF;\n      this.rounds = rounds;\n      anumber(outputLen);\n      if (!(0 < blockLen && blockLen < 200))\n        throw new Error(\"only keccak-f1600 function is supported\");\n      this.state = new Uint8Array(200);\n      this.state32 = u32(this.state);\n    }\n    clone() {\n      return this._cloneInto();\n    }\n    keccak() {\n      swap32IfBE(this.state32);\n      keccakP(this.state32, this.rounds);\n      swap32IfBE(this.state32);\n      this.posOut = 0;\n      this.pos = 0;\n    }\n    update(data) {\n      aexists(this);\n      data = toBytes(data);\n      abytes(data);\n      const { blockLen, state } = this;\n      const len = data.length;\n      for (let pos = 0;pos < len; ) {\n        const take = Math.min(blockLen - this.pos, len - pos);\n        for (let i = 0;i < take; i++)\n          state[this.pos++] ^= data[pos++];\n        if (this.pos === blockLen)\n          this.keccak();\n      }\n      return this;\n    }\n    finish() {\n      if (this.finished)\n        return;\n      this.finished = true;\n      const { state, suffix, pos, blockLen } = this;\n      state[pos] ^= suffix;\n      if ((suffix & 128) !== 0 && pos === blockLen - 1)\n        this.keccak();\n      state[blockLen - 1] ^= 128;\n      this.keccak();\n    }\n    writeInto(out) {\n      aexists(this, false);\n      abytes(out);\n      this.finish();\n      const bufferOut = this.state;\n      const { blockLen } = this;\n      for (let pos = 0, len = out.length;pos < len; ) {\n        if (this.posOut >= blockLen)\n          this.keccak();\n        const take = Math.min(blockLen - this.posOut, len - pos);\n        out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\n        this.posOut += take;\n        pos += take;\n      }\n      return out;\n    }\n    xofInto(out) {\n      if (!this.enableXOF)\n        throw new Error(\"XOF is not possible for this instance\");\n      return this.writeInto(out);\n    }\n    xof(bytes) {\n      anumber(bytes);\n      return this.xofInto(new Uint8Array(bytes));\n    }\n    digestInto(out) {\n      aoutput(out, this);\n      if (this.finished)\n        throw new Error(\"digest() was already called\");\n      this.writeInto(out);\n      this.destroy();\n      return out;\n    }\n    digest() {\n      return this.digestInto(new Uint8Array(this.outputLen));\n    }\n    destroy() {\n      this.destroyed = true;\n      clean(this.state);\n    }\n    _cloneInto(to) {\n      const { blockLen, suffix, outputLen, rounds, enableXOF } = this;\n      to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));\n      to.state32.set(this.state32);\n      to.pos = this.pos;\n      to.posOut = this.posOut;\n      to.finished = this.finished;\n      to.rounds = rounds;\n      to.suffix = suffix;\n      to.outputLen = outputLen;\n      to.enableXOF = enableXOF;\n      to.destroyed = this.destroyed;\n      return to;\n    }\n  };\n  keccak_256 = /* @__PURE__ */ (() => gen(1, 136, 256 / 8))();\n});\n\n// node_modules/fast-safe-stringify/index.js\nvar require_fast_safe_stringify = __commonJS((exports, module) => {\n  module.exports = stringify;\n  stringify.default = stringify;\n  stringify.stable = deterministicStringify;\n  stringify.stableStringify = deterministicStringify;\n  var LIMIT_REPLACE_NODE = \"[...]\";\n  var CIRCULAR_REPLACE_NODE = \"[Circular]\";\n  var arr = [];\n  var replacerStack = [];\n  function defaultOptions() {\n    return {\n      depthLimit: Number.MAX_SAFE_INTEGER,\n      edgesLimit: Number.MAX_SAFE_INTEGER\n    };\n  }\n  function stringify(obj, replacer, spacer, options) {\n    if (typeof options === \"undefined\") {\n      options = defaultOptions();\n    }\n    decirc(obj, \"\", 0, [], undefined, 0, options);\n    var res;\n    try {\n      if (replacerStack.length === 0) {\n        res = JSON.stringify(obj, replacer, spacer);\n      } else {\n        res = JSON.stringify(obj, replaceGetterValues(replacer), spacer);\n      }\n    } catch (_) {\n      return JSON.stringify(\"[unable to serialize, circular reference is too complex to analyze]\");\n    } finally {\n      while (arr.length !== 0) {\n        var part = arr.pop();\n        if (part.length === 4) {\n          Object.defineProperty(part[0], part[1], part[3]);\n        } else {\n          part[0][part[1]] = part[2];\n        }\n      }\n    }\n    return res;\n  }\n  function setReplace(replace, val, k, parent) {\n    var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k);\n    if (propertyDescriptor.get !== undefined) {\n      if (propertyDescriptor.configurable) {\n        Object.defineProperty(parent, k, { value: replace });\n        arr.push([parent, k, val, propertyDescriptor]);\n      } else {\n        replacerStack.push([val, k, replace]);\n      }\n    } else {\n      parent[k] = replace;\n      arr.push([parent, k, val]);\n    }\n  }\n  function decirc(val, k, edgeIndex, stack, parent, depth, options) {\n    depth += 1;\n    var i;\n    if (typeof val === \"object\" && val !== null) {\n      for (i = 0;i < stack.length; i++) {\n        if (stack[i] === val) {\n          setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);\n          return;\n        }\n      }\n      if (typeof options.depthLimit !== \"undefined\" && depth > options.depthLimit) {\n        setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n        return;\n      }\n      if (typeof options.edgesLimit !== \"undefined\" && edgeIndex + 1 > options.edgesLimit) {\n        setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n        return;\n      }\n      stack.push(val);\n      if (Array.isArray(val)) {\n        for (i = 0;i < val.length; i++) {\n          decirc(val[i], i, i, stack, val, depth, options);\n        }\n      } else {\n        var keys = Object.keys(val);\n        for (i = 0;i < keys.length; i++) {\n          var key = keys[i];\n          decirc(val[key], key, i, stack, val, depth, options);\n        }\n      }\n      stack.pop();\n    }\n  }\n  function compareFunction(a, b) {\n    if (a < b) {\n      return -1;\n    }\n    if (a > b) {\n      return 1;\n    }\n    return 0;\n  }\n  function deterministicStringify(obj, replacer, spacer, options) {\n    if (typeof options === \"undefined\") {\n      options = defaultOptions();\n    }\n    var tmp = deterministicDecirc(obj, \"\", 0, [], undefined, 0, options) || obj;\n    var res;\n    try {\n      if (replacerStack.length === 0) {\n        res = JSON.stringify(tmp, replacer, spacer);\n      } else {\n        res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer);\n      }\n    } catch (_) {\n      return JSON.stringify(\"[unable to serialize, circular reference is too complex to analyze]\");\n    } finally {\n      while (arr.length !== 0) {\n        var part = arr.pop();\n        if (part.length === 4) {\n          Object.defineProperty(part[0], part[1], part[3]);\n        } else {\n          part[0][part[1]] = part[2];\n        }\n      }\n    }\n    return res;\n  }\n  function deterministicDecirc(val, k, edgeIndex, stack, parent, depth, options) {\n    depth += 1;\n    var i;\n    if (typeof val === \"object\" && val !== null) {\n      for (i = 0;i < stack.length; i++) {\n        if (stack[i] === val) {\n          setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);\n          return;\n        }\n      }\n      try {\n        if (typeof val.toJSON === \"function\") {\n          return;\n        }\n      } catch (_) {\n        return;\n      }\n      if (typeof options.depthLimit !== \"undefined\" && depth > options.depthLimit) {\n        setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n        return;\n      }\n      if (typeof options.edgesLimit !== \"undefined\" && edgeIndex + 1 > options.edgesLimit) {\n        setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n        return;\n      }\n      stack.push(val);\n      if (Array.isArray(val)) {\n        for (i = 0;i < val.length; i++) {\n          deterministicDecirc(val[i], i, i, stack, val, depth, options);\n        }\n      } else {\n        var tmp = {};\n        var keys = Object.keys(val).sort(compareFunction);\n        for (i = 0;i < keys.length; i++) {\n          var key = keys[i];\n          deterministicDecirc(val[key], key, i, stack, val, depth, options);\n          tmp[key] = val[key];\n        }\n        if (typeof parent !== \"undefined\") {\n          arr.push([parent, k, val]);\n          parent[k] = tmp;\n        } else {\n          return tmp;\n        }\n      }\n      stack.pop();\n    }\n  }\n  function replaceGetterValues(replacer) {\n    replacer = typeof replacer !== \"undefined\" ? replacer : function(k, v) {\n      return v;\n    };\n    return function(key, val) {\n      if (replacerStack.length > 0) {\n        for (var i = 0;i < replacerStack.length; i++) {\n          var part = replacerStack[i];\n          if (part[1] === key && part[0] === val) {\n            val = part[2];\n            replacerStack.splice(i, 1);\n            break;\n          }\n        }\n      }\n      return replacer.call(this, key, val);\n    };\n  }\n});\n\n// node_modules/eventemitter3/index.js\nvar require_eventemitter3 = __commonJS((exports, module) => {\n  var has = Object.prototype.hasOwnProperty;\n  var prefix = \"~\";\n  function Events() {}\n  if (Object.create) {\n    Events.prototype = Object.create(null);\n    if (!new Events().__proto__)\n      prefix = false;\n  }\n  function EE(fn, context, once) {\n    this.fn = fn;\n    this.context = context;\n    this.once = once || false;\n  }\n  function addListener(emitter, event, fn, context, once) {\n    if (typeof fn !== \"function\") {\n      throw new TypeError(\"The listener must be a function\");\n    }\n    var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;\n    if (!emitter._events[evt])\n      emitter._events[evt] = listener, emitter._eventsCount++;\n    else if (!emitter._events[evt].fn)\n      emitter._events[evt].push(listener);\n    else\n      emitter._events[evt] = [emitter._events[evt], listener];\n    return emitter;\n  }\n  function clearEvent(emitter, evt) {\n    if (--emitter._eventsCount === 0)\n      emitter._events = new Events;\n    else\n      delete emitter._events[evt];\n  }\n  function EventEmitter() {\n    this._events = new Events;\n    this._eventsCount = 0;\n  }\n  EventEmitter.prototype.eventNames = function eventNames() {\n    var names = [], events, name;\n    if (this._eventsCount === 0)\n      return names;\n    for (name in events = this._events) {\n      if (has.call(events, name))\n        names.push(prefix ? name.slice(1) : name);\n    }\n    if (Object.getOwnPropertySymbols) {\n      return names.concat(Object.getOwnPropertySymbols(events));\n    }\n    return names;\n  };\n  EventEmitter.prototype.listeners = function listeners(event) {\n    var evt = prefix ? prefix + event : event, handlers = this._events[evt];\n    if (!handlers)\n      return [];\n    if (handlers.fn)\n      return [handlers.fn];\n    for (var i = 0, l = handlers.length, ee = new Array(l);i < l; i++) {\n      ee[i] = handlers[i].fn;\n    }\n    return ee;\n  };\n  EventEmitter.prototype.listenerCount = function listenerCount(event) {\n    var evt = prefix ? prefix + event : event, listeners = this._events[evt];\n    if (!listeners)\n      return 0;\n    if (listeners.fn)\n      return 1;\n    return listeners.length;\n  };\n  EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n    var evt = prefix ? prefix + event : event;\n    if (!this._events[evt])\n      return false;\n    var listeners = this._events[evt], len = arguments.length, args, i;\n    if (listeners.fn) {\n      if (listeners.once)\n        this.removeListener(event, listeners.fn, undefined, true);\n      switch (len) {\n        case 1:\n          return listeners.fn.call(listeners.context), true;\n        case 2:\n          return listeners.fn.call(listeners.context, a1), true;\n        case 3:\n          return listeners.fn.call(listeners.context, a1, a2), true;\n        case 4:\n          return listeners.fn.call(listeners.context, a1, a2, a3), true;\n        case 5:\n          return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n        case 6:\n          return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n      }\n      for (i = 1, args = new Array(len - 1);i < len; i++) {\n        args[i - 1] = arguments[i];\n      }\n      listeners.fn.apply(listeners.context, args);\n    } else {\n      var length = listeners.length, j;\n      for (i = 0;i < length; i++) {\n        if (listeners[i].once)\n          this.removeListener(event, listeners[i].fn, undefined, true);\n        switch (len) {\n          case 1:\n            listeners[i].fn.call(listeners[i].context);\n            break;\n          case 2:\n            listeners[i].fn.call(listeners[i].context, a1);\n            break;\n          case 3:\n            listeners[i].fn.call(listeners[i].context, a1, a2);\n            break;\n          case 4:\n            listeners[i].fn.call(listeners[i].context, a1, a2, a3);\n            break;\n          default:\n            if (!args)\n              for (j = 1, args = new Array(len - 1);j < len; j++) {\n                args[j - 1] = arguments[j];\n              }\n            listeners[i].fn.apply(listeners[i].context, args);\n        }\n      }\n    }\n    return true;\n  };\n  EventEmitter.prototype.on = function on(event, fn, context) {\n    return addListener(this, event, fn, context, false);\n  };\n  EventEmitter.prototype.once = function once(event, fn, context) {\n    return addListener(this, event, fn, context, true);\n  };\n  EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n    var evt = prefix ? prefix + event : event;\n    if (!this._events[evt])\n      return this;\n    if (!fn) {\n      clearEvent(this, evt);\n      return this;\n    }\n    var listeners = this._events[evt];\n    if (listeners.fn) {\n      if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {\n        clearEvent(this, evt);\n      }\n    } else {\n      for (var i = 0, events = [], length = listeners.length;i < length; i++) {\n        if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {\n          events.push(listeners[i]);\n        }\n      }\n      if (events.length)\n        this._events[evt] = events.length === 1 ? events[0] : events;\n      else\n        clearEvent(this, evt);\n    }\n    return this;\n  };\n  EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n    var evt;\n    if (event) {\n      evt = prefix ? prefix + event : event;\n      if (this._events[evt])\n        clearEvent(this, evt);\n    } else {\n      this._events = new Events;\n      this._eventsCount = 0;\n    }\n    return this;\n  };\n  EventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n  EventEmitter.prototype.addListener = EventEmitter.prototype.on;\n  EventEmitter.prefixed = prefix;\n  EventEmitter.EventEmitter = EventEmitter;\n  if (typeof module !== \"undefined\") {\n    module.exports = EventEmitter;\n  }\n});\n\n// node_modules/abitype/dist/esm/regex.js\nfunction execTyped(regex, string2) {\n  const match = regex.exec(string2);\n  return match?.groups;\n}\nvar init_regex = () => {};\n\n// node_modules/abitype/dist/esm/human-readable/formatAbiParameter.js\nfunction formatAbiParameter(abiParameter) {\n  let type = abiParameter.type;\n  if (tupleRegex.test(abiParameter.type) && \"components\" in abiParameter) {\n    type = \"(\";\n    const length = abiParameter.components.length;\n    for (let i = 0;i < length; i++) {\n      const component = abiParameter.components[i];\n      type += formatAbiParameter(component);\n      if (i < length - 1)\n        type += \", \";\n    }\n    const result = execTyped(tupleRegex, abiParameter.type);\n    type += `)${result?.array ?? \"\"}`;\n    return formatAbiParameter({\n      ...abiParameter,\n      type\n    });\n  }\n  if (\"indexed\" in abiParameter && abiParameter.indexed)\n    type = `${type} indexed`;\n  if (abiParameter.name)\n    return `${type} ${abiParameter.name}`;\n  return type;\n}\nvar tupleRegex;\nvar init_formatAbiParameter = __esm(() => {\n  init_regex();\n  tupleRegex = /^tuple(?<array>(\\[(\\d*)\\])*)$/;\n});\n\n// node_modules/abitype/dist/esm/human-readable/formatAbiParameters.js\nfunction formatAbiParameters(abiParameters) {\n  let params = \"\";\n  const length = abiParameters.length;\n  for (let i = 0;i < length; i++) {\n    const abiParameter = abiParameters[i];\n    params += formatAbiParameter(abiParameter);\n    if (i !== length - 1)\n      params += \", \";\n  }\n  return params;\n}\nvar init_formatAbiParameters = __esm(() => {\n  init_formatAbiParameter();\n});\n\n// node_modules/abitype/dist/esm/human-readable/formatAbiItem.js\nfunction formatAbiItem(abiItem) {\n  if (abiItem.type === \"function\")\n    return `function ${abiItem.name}(${formatAbiParameters(abiItem.inputs)})${abiItem.stateMutability && abiItem.stateMutability !== \"nonpayable\" ? ` ${abiItem.stateMutability}` : \"\"}${abiItem.outputs?.length ? ` returns (${formatAbiParameters(abiItem.outputs)})` : \"\"}`;\n  if (abiItem.type === \"event\")\n    return `event ${abiItem.name}(${formatAbiParameters(abiItem.inputs)})`;\n  if (abiItem.type === \"error\")\n    return `error ${abiItem.name}(${formatAbiParameters(abiItem.inputs)})`;\n  if (abiItem.type === \"constructor\")\n    return `constructor(${formatAbiParameters(abiItem.inputs)})${abiItem.stateMutability === \"payable\" ? \" payable\" : \"\"}`;\n  if (abiItem.type === \"fallback\")\n    return `fallback() external${abiItem.stateMutability === \"payable\" ? \" payable\" : \"\"}`;\n  return \"receive() external payable\";\n}\nvar init_formatAbiItem = __esm(() => {\n  init_formatAbiParameters();\n});\n\n// node_modules/abitype/dist/esm/exports/index.js\nvar init_exports = __esm(() => {\n  init_formatAbiItem();\n});\n\n// node_modules/viem/_esm/utils/abi/formatAbiItem.js\nfunction formatAbiItem2(abiItem, { includeName = false } = {}) {\n  if (abiItem.type !== \"function\" && abiItem.type !== \"event\" && abiItem.type !== \"error\")\n    throw new InvalidDefinitionTypeError(abiItem.type);\n  return `${abiItem.name}(${formatAbiParams(abiItem.inputs, { includeName })})`;\n}\nfunction formatAbiParams(params, { includeName = false } = {}) {\n  if (!params)\n    return \"\";\n  return params.map((param) => formatAbiParam(param, { includeName })).join(includeName ? \", \" : \",\");\n}\nfunction formatAbiParam(param, { includeName }) {\n  if (param.type.startsWith(\"tuple\")) {\n    return `(${formatAbiParams(param.components, { includeName })})${param.type.slice(\"tuple\".length)}`;\n  }\n  return param.type + (includeName && param.name ? ` ${param.name}` : \"\");\n}\nvar init_formatAbiItem2 = __esm(() => {\n  init_abi();\n});\n\n// node_modules/viem/_esm/utils/data/isHex.js\nfunction isHex(value, { strict = true } = {}) {\n  if (!value)\n    return false;\n  if (typeof value !== \"string\")\n    return false;\n  return strict ? /^0x[0-9a-fA-F]*$/.test(value) : value.startsWith(\"0x\");\n}\n\n// node_modules/viem/_esm/utils/data/size.js\nfunction size(value) {\n  if (isHex(value, { strict: false }))\n    return Math.ceil((value.length - 2) / 2);\n  return value.length;\n}\nvar init_size = () => {};\n\n// node_modules/viem/_esm/errors/version.js\nvar version = \"2.33.3\";\n\n// node_modules/viem/_esm/errors/base.js\nfunction walk(err, fn) {\n  if (fn?.(err))\n    return err;\n  if (err && typeof err === \"object\" && \"cause\" in err && err.cause !== undefined)\n    return walk(err.cause, fn);\n  return fn ? null : err;\n}\nvar errorConfig, BaseError;\nvar init_base = __esm(() => {\n  errorConfig = {\n    getDocsUrl: ({ docsBaseUrl, docsPath = \"\", docsSlug }) => docsPath ? `${docsBaseUrl ?? \"https://viem.sh\"}${docsPath}${docsSlug ? `#${docsSlug}` : \"\"}` : undefined,\n    version: `viem@${version}`\n  };\n  BaseError = class BaseError extends Error {\n    constructor(shortMessage, args = {}) {\n      const details = (() => {\n        if (args.cause instanceof BaseError)\n          return args.cause.details;\n        if (args.cause?.message)\n          return args.cause.message;\n        return args.details;\n      })();\n      const docsPath = (() => {\n        if (args.cause instanceof BaseError)\n          return args.cause.docsPath || args.docsPath;\n        return args.docsPath;\n      })();\n      const docsUrl = errorConfig.getDocsUrl?.({ ...args, docsPath });\n      const message = [\n        shortMessage || \"An error occurred.\",\n        \"\",\n        ...args.metaMessages ? [...args.metaMessages, \"\"] : [],\n        ...docsUrl ? [`Docs: ${docsUrl}`] : [],\n        ...details ? [`Details: ${details}`] : [],\n        ...errorConfig.version ? [`Version: ${errorConfig.version}`] : []\n      ].join(`\n`);\n      super(message, args.cause ? { cause: args.cause } : undefined);\n      Object.defineProperty(this, \"details\", {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value: undefined\n      });\n      Object.defineProperty(this, \"docsPath\", {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value: undefined\n      });\n      Object.defineProperty(this, \"metaMessages\", {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value: undefined\n      });\n      Object.defineProperty(this, \"shortMessage\", {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value: undefined\n      });\n      Object.defineProperty(this, \"version\", {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value: undefined\n      });\n      Object.defineProperty(this, \"name\", {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value: \"BaseError\"\n      });\n      this.details = details;\n      this.docsPath = docsPath;\n      this.metaMessages = args.metaMessages;\n      this.name = args.name ?? this.name;\n      this.shortMessage = shortMessage;\n      this.version = version;\n    }\n    walk(fn) {\n      return walk(this, fn);\n    }\n  };\n});\n\n// node_modules/viem/_esm/errors/abi.js\nvar AbiEncodingArrayLengthMismatchError, AbiEncodingBytesSizeMismatchError, AbiEncodingLengthMismatchError, AbiFunctionNotFoundError, AbiItemAmbiguityError, BytesSizeMismatchError, InvalidAbiEncodingTypeError, InvalidArrayError, InvalidDefinitionTypeError, UnsupportedPackedAbiType;\nvar init_abi = __esm(() => {\n  init_formatAbiItem2();\n  init_size();\n  init_base();\n  AbiEncodingArrayLengthMismatchError = class AbiEncodingArrayLengthMismatchError extends BaseError {\n    constructor({ expectedLength, givenLength, type }) {\n      super([\n        `ABI encoding array length mismatch for type ${type}.`,\n        `Expected length: ${expectedLength}`,\n        `Given length: ${givenLength}`\n      ].join(`\n`), { name: \"AbiEncodingArrayLengthMismatchError\" });\n    }\n  };\n  AbiEncodingBytesSizeMismatchError = class AbiEncodingBytesSizeMismatchError extends BaseError {\n    constructor({ expectedSize, value }) {\n      super(`Size of bytes \"${value}\" (bytes${size(value)}) does not match expected size (bytes${expectedSize}).`, { name: \"AbiEncodingBytesSizeMismatchError\" });\n    }\n  };\n  AbiEncodingLengthMismatchError = class AbiEncodingLengthMismatchError extends BaseError {\n    constructor({ expectedLength, givenLength }) {\n      super([\n        \"ABI encoding params/values length mismatch.\",\n        `Expected length (params): ${expectedLength}`,\n        `Given length (values): ${givenLength}`\n      ].join(`\n`), { name: \"AbiEncodingLengthMismatchError\" });\n    }\n  };\n  AbiFunctionNotFoundError = class AbiFunctionNotFoundError extends BaseError {\n    constructor(functionName, { docsPath } = {}) {\n      super([\n        `Function ${functionName ? `\"${functionName}\" ` : \"\"}not found on ABI.`,\n        \"Make sure you are using the correct ABI and that the function exists on it.\"\n      ].join(`\n`), {\n        docsPath,\n        name: \"AbiFunctionNotFoundError\"\n      });\n    }\n  };\n  AbiItemAmbiguityError = class AbiItemAmbiguityError extends BaseError {\n    constructor(x, y) {\n      super(\"Found ambiguous types in overloaded ABI items.\", {\n        metaMessages: [\n          `\\`${x.type}\\` in \\`${formatAbiItem2(x.abiItem)}\\`, and`,\n          `\\`${y.type}\\` in \\`${formatAbiItem2(y.abiItem)}\\``,\n          \"\",\n          \"These types encode differently and cannot be distinguished at runtime.\",\n          \"Remove one of the ambiguous items in the ABI.\"\n        ],\n        name: \"AbiItemAmbiguityError\"\n      });\n    }\n  };\n  BytesSizeMismatchError = class BytesSizeMismatchError extends BaseError {\n    constructor({ expectedSize, givenSize }) {\n      super(`Expected bytes${expectedSize}, got bytes${givenSize}.`, {\n        name: \"BytesSizeMismatchError\"\n      });\n    }\n  };\n  InvalidAbiEncodingTypeError = class InvalidAbiEncodingTypeError extends BaseError {\n    constructor(type, { docsPath }) {\n      super([\n        `Type \"${type}\" is not a valid encoding type.`,\n        \"Please provide a valid ABI type.\"\n      ].join(`\n`), { docsPath, name: \"InvalidAbiEncodingType\" });\n    }\n  };\n  InvalidArrayError = class InvalidArrayError extends BaseError {\n    constructor(value) {\n      super([`Value \"${value}\" is not a valid array.`].join(`\n`), {\n        name: \"InvalidArrayError\"\n      });\n    }\n  };\n  InvalidDefinitionTypeError = class InvalidDefinitionTypeError extends BaseError {\n    constructor(type) {\n      super([\n        `\"${type}\" is not a valid definition type.`,\n        'Valid types: \"function\", \"event\", \"error\"'\n      ].join(`\n`), { name: \"InvalidDefinitionTypeError\" });\n    }\n  };\n  UnsupportedPackedAbiType = class UnsupportedPackedAbiType extends BaseError {\n    constructor(type) {\n      super(`Type \"${type}\" is not supported for packed encoding.`, {\n        name: \"UnsupportedPackedAbiType\"\n      });\n    }\n  };\n});\n\n// node_modules/viem/_esm/errors/data.js\nvar SliceOffsetOutOfBoundsError, SizeExceedsPaddingSizeError;\nvar init_data = __esm(() => {\n  init_base();\n  SliceOffsetOutOfBoundsError = class SliceOffsetOutOfBoundsError extends BaseError {\n    constructor({ offset, position, size: size2 }) {\n      super(`Slice ${position === \"start\" ? \"starting\" : \"ending\"} at offset \"${offset}\" is out-of-bounds (size: ${size2}).`, { name: \"SliceOffsetOutOfBoundsError\" });\n    }\n  };\n  SizeExceedsPaddingSizeError = class SizeExceedsPaddingSizeError extends BaseError {\n    constructor({ size: size2, targetSize, type }) {\n      super(`${type.charAt(0).toUpperCase()}${type.slice(1).toLowerCase()} size (${size2}) exceeds padding size (${targetSize}).`, { name: \"SizeExceedsPaddingSizeError\" });\n    }\n  };\n});\n\n// node_modules/viem/_esm/utils/data/pad.js\nfunction pad(hexOrBytes, { dir, size: size2 = 32 } = {}) {\n  if (typeof hexOrBytes === \"string\")\n    return padHex(hexOrBytes, { dir, size: size2 });\n  return padBytes(hexOrBytes, { dir, size: size2 });\n}\nfunction padHex(hex_, { dir, size: size2 = 32 } = {}) {\n  if (size2 === null)\n    return hex_;\n  const hex = hex_.replace(\"0x\", \"\");\n  if (hex.length > size2 * 2)\n    throw new SizeExceedsPaddingSizeError({\n      size: Math.ceil(hex.length / 2),\n      targetSize: size2,\n      type: \"hex\"\n    });\n  return `0x${hex[dir === \"right\" ? \"padEnd\" : \"padStart\"](size2 * 2, \"0\")}`;\n}\nfunction padBytes(bytes, { dir, size: size2 = 32 } = {}) {\n  if (size2 === null)\n    return bytes;\n  if (bytes.length > size2)\n    throw new SizeExceedsPaddingSizeError({\n      size: bytes.length,\n      targetSize: size2,\n      type: \"bytes\"\n    });\n  const paddedBytes = new Uint8Array(size2);\n  for (let i = 0;i < size2; i++) {\n    const padEnd = dir === \"right\";\n    paddedBytes[padEnd ? i : size2 - i - 1] = bytes[padEnd ? i : bytes.length - i - 1];\n  }\n  return paddedBytes;\n}\nvar init_pad = __esm(() => {\n  init_data();\n});\n\n// node_modules/viem/_esm/errors/encoding.js\nvar IntegerOutOfRangeError, SizeOverflowError;\nvar init_encoding = __esm(() => {\n  init_base();\n  IntegerOutOfRangeError = class IntegerOutOfRangeError extends BaseError {\n    constructor({ max, min, signed, size: size2, value }) {\n      super(`Number \"${value}\" is not in safe ${size2 ? `${size2 * 8}-bit ${signed ? \"signed\" : \"unsigned\"} ` : \"\"}integer range ${max ? `(${min} to ${max})` : `(above ${min})`}`, { name: \"IntegerOutOfRangeError\" });\n    }\n  };\n  SizeOverflowError = class SizeOverflowError extends BaseError {\n    constructor({ givenSize, maxSize }) {\n      super(`Size cannot exceed ${maxSize} bytes. Given size: ${givenSize} bytes.`, { name: \"SizeOverflowError\" });\n    }\n  };\n});\n\n// node_modules/viem/_esm/utils/data/trim.js\nfunction trim(hexOrBytes, { dir = \"left\" } = {}) {\n  let data = typeof hexOrBytes === \"string\" ? hexOrBytes.replace(\"0x\", \"\") : hexOrBytes;\n  let sliceLength = 0;\n  for (let i = 0;i < data.length - 1; i++) {\n    if (data[dir === \"left\" ? i : data.length - i - 1].toString() === \"0\")\n      sliceLength++;\n    else\n      break;\n  }\n  data = dir === \"left\" ? data.slice(sliceLength) : data.slice(0, data.length - sliceLength);\n  if (typeof hexOrBytes === \"string\") {\n    if (data.length === 1 && dir === \"right\")\n      data = `${data}0`;\n    return `0x${data.length % 2 === 1 ? `0${data}` : data}`;\n  }\n  return data;\n}\n\n// node_modules/viem/_esm/utils/encoding/fromHex.js\nfunction assertSize(hexOrBytes, { size: size2 }) {\n  if (size(hexOrBytes) > size2)\n    throw new SizeOverflowError({\n      givenSize: size(hexOrBytes),\n      maxSize: size2\n    });\n}\nfunction hexToBigInt(hex, opts = {}) {\n  const { signed } = opts;\n  if (opts.size)\n    assertSize(hex, { size: opts.size });\n  const value = BigInt(hex);\n  if (!signed)\n    return value;\n  const size2 = (hex.length - 2) / 2;\n  const max = (1n << BigInt(size2) * 8n - 1n) - 1n;\n  if (value <= max)\n    return value;\n  return value - BigInt(`0x${\"f\".padStart(size2 * 2, \"f\")}`) - 1n;\n}\nfunction hexToNumber(hex, opts = {}) {\n  return Number(hexToBigInt(hex, opts));\n}\nvar init_fromHex = __esm(() => {\n  init_encoding();\n  init_size();\n});\n\n// node_modules/viem/_esm/utils/encoding/toHex.js\nfunction toHex(value, opts = {}) {\n  if (typeof value === \"number\" || typeof value === \"bigint\")\n    return numberToHex(value, opts);\n  if (typeof value === \"string\") {\n    return stringToHex(value, opts);\n  }\n  if (typeof value === \"boolean\")\n    return boolToHex(value, opts);\n  return bytesToHex(value, opts);\n}\nfunction boolToHex(value, opts = {}) {\n  const hex = `0x${Number(value)}`;\n  if (typeof opts.size === \"number\") {\n    assertSize(hex, { size: opts.size });\n    return pad(hex, { size: opts.size });\n  }\n  return hex;\n}\nfunction bytesToHex(value, opts = {}) {\n  let string2 = \"\";\n  for (let i = 0;i < value.length; i++) {\n    string2 += hexes[value[i]];\n  }\n  const hex = `0x${string2}`;\n  if (typeof opts.size === \"number\") {\n    assertSize(hex, { size: opts.size });\n    return pad(hex, { dir: \"right\", size: opts.size });\n  }\n  return hex;\n}\nfunction numberToHex(value_, opts = {}) {\n  const { signed, size: size2 } = opts;\n  const value = BigInt(value_);\n  let maxValue;\n  if (size2) {\n    if (signed)\n      maxValue = (1n << BigInt(size2) * 8n - 1n) - 1n;\n    else\n      maxValue = 2n ** (BigInt(size2) * 8n) - 1n;\n  } else if (typeof value_ === \"number\") {\n    maxValue = BigInt(Number.MAX_SAFE_INTEGER);\n  }\n  const minValue = typeof maxValue === \"bigint\" && signed ? -maxValue - 1n : 0;\n  if (maxValue && value > maxValue || value < minValue) {\n    const suffix = typeof value_ === \"bigint\" ? \"n\" : \"\";\n    throw new IntegerOutOfRangeError({\n      max: maxValue ? `${maxValue}${suffix}` : undefined,\n      min: `${minValue}${suffix}`,\n      signed,\n      size: size2,\n      value: `${value_}${suffix}`\n    });\n  }\n  const hex = `0x${(signed && value < 0 ? (1n << BigInt(size2 * 8)) + BigInt(value) : value).toString(16)}`;\n  if (size2)\n    return pad(hex, { size: size2 });\n  return hex;\n}\nfunction stringToHex(value_, opts = {}) {\n  const value = encoder.encode(value_);\n  return bytesToHex(value, opts);\n}\nvar hexes, encoder;\nvar init_toHex = __esm(() => {\n  init_encoding();\n  init_pad();\n  init_fromHex();\n  hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_v, i) => i.toString(16).padStart(2, \"0\"));\n  encoder = /* @__PURE__ */ new TextEncoder;\n});\n\n// node_modules/viem/_esm/utils/encoding/toBytes.js\nfunction toBytes2(value, opts = {}) {\n  if (typeof value === \"number\" || typeof value === \"bigint\")\n    return numberToBytes(value, opts);\n  if (typeof value === \"boolean\")\n    return boolToBytes(value, opts);\n  if (isHex(value))\n    return hexToBytes(value, opts);\n  return stringToBytes(value, opts);\n}\nfunction boolToBytes(value, opts = {}) {\n  const bytes = new Uint8Array(1);\n  bytes[0] = Number(value);\n  if (typeof opts.size === \"number\") {\n    assertSize(bytes, { size: opts.size });\n    return pad(bytes, { size: opts.size });\n  }\n  return bytes;\n}\nfunction charCodeToBase16(char) {\n  if (char >= charCodeMap.zero && char <= charCodeMap.nine)\n    return char - charCodeMap.zero;\n  if (char >= charCodeMap.A && char <= charCodeMap.F)\n    return char - (charCodeMap.A - 10);\n  if (char >= charCodeMap.a && char <= charCodeMap.f)\n    return char - (charCodeMap.a - 10);\n  return;\n}\nfunction hexToBytes(hex_, opts = {}) {\n  let hex = hex_;\n  if (opts.size) {\n    assertSize(hex, { size: opts.size });\n    hex = pad(hex, { dir: \"right\", size: opts.size });\n  }\n  let hexString = hex.slice(2);\n  if (hexString.length % 2)\n    hexString = `0${hexString}`;\n  const length = hexString.length / 2;\n  const bytes = new Uint8Array(length);\n  for (let index = 0, j = 0;index < length; index++) {\n    const nibbleLeft = charCodeToBase16(hexString.charCodeAt(j++));\n    const nibbleRight = charCodeToBase16(hexString.charCodeAt(j++));\n    if (nibbleLeft === undefined || nibbleRight === undefined) {\n      throw new BaseError(`Invalid byte sequence (\"${hexString[j - 2]}${hexString[j - 1]}\" in \"${hexString}\").`);\n    }\n    bytes[index] = nibbleLeft * 16 + nibbleRight;\n  }\n  return bytes;\n}\nfunction numberToBytes(value, opts) {\n  const hex = numberToHex(value, opts);\n  return hexToBytes(hex);\n}\nfunction stringToBytes(value, opts = {}) {\n  const bytes = encoder2.encode(value);\n  if (typeof opts.size === \"number\") {\n    assertSize(bytes, { size: opts.size });\n    return pad(bytes, { dir: \"right\", size: opts.size });\n  }\n  return bytes;\n}\nvar encoder2, charCodeMap;\nvar init_toBytes = __esm(() => {\n  init_base();\n  init_pad();\n  init_fromHex();\n  init_toHex();\n  encoder2 = /* @__PURE__ */ new TextEncoder;\n  charCodeMap = {\n    zero: 48,\n    nine: 57,\n    A: 65,\n    F: 70,\n    a: 97,\n    f: 102\n  };\n});\n\n// node_modules/viem/_esm/utils/hash/keccak256.js\nfunction keccak256(value, to_) {\n  const to = to_ || \"hex\";\n  const bytes = keccak_256(isHex(value, { strict: false }) ? toBytes2(value) : value);\n  if (to === \"bytes\")\n    return bytes;\n  return toHex(bytes);\n}\nvar init_keccak256 = __esm(() => {\n  init_sha3();\n  init_toBytes();\n  init_toHex();\n});\n\n// node_modules/viem/_esm/utils/hash/hashSignature.js\nfunction hashSignature(sig) {\n  return hash(sig);\n}\nvar hash = (value) => keccak256(toBytes2(value));\nvar init_hashSignature = __esm(() => {\n  init_toBytes();\n  init_keccak256();\n});\n\n// node_modules/viem/_esm/utils/hash/normalizeSignature.js\nfunction normalizeSignature(signature) {\n  let active = true;\n  let current = \"\";\n  let level = 0;\n  let result = \"\";\n  let valid = false;\n  for (let i = 0;i < signature.length; i++) {\n    const char = signature[i];\n    if ([\"(\", \")\", \",\"].includes(char))\n      active = true;\n    if (char === \"(\")\n      level++;\n    if (char === \")\")\n      level--;\n    if (!active)\n      continue;\n    if (level === 0) {\n      if (char === \" \" && [\"event\", \"function\", \"\"].includes(result))\n        result = \"\";\n      else {\n        result += char;\n        if (char === \")\") {\n          valid = true;\n          break;\n        }\n      }\n      continue;\n    }\n    if (char === \" \") {\n      if (signature[i - 1] !== \",\" && current !== \",\" && current !== \",(\") {\n        current = \"\";\n        active = false;\n      }\n      continue;\n    }\n    result += char;\n    current += char;\n  }\n  if (!valid)\n    throw new BaseError(\"Unable to normalize signature.\");\n  return result;\n}\nvar init_normalizeSignature = __esm(() => {\n  init_base();\n});\n\n// node_modules/viem/_esm/utils/hash/toSignature.js\nvar toSignature = (def) => {\n  const def_ = (() => {\n    if (typeof def === \"string\")\n      return def;\n    return formatAbiItem(def);\n  })();\n  return normalizeSignature(def_);\n};\nvar init_toSignature = __esm(() => {\n  init_exports();\n  init_normalizeSignature();\n});\n\n// node_modules/viem/_esm/utils/hash/toSignatureHash.js\nfunction toSignatureHash(fn) {\n  return hashSignature(toSignature(fn));\n}\nvar init_toSignatureHash = __esm(() => {\n  init_hashSignature();\n  init_toSignature();\n});\n\n// node_modules/viem/_esm/utils/hash/toEventSelector.js\nvar toEventSelector;\nvar init_toEventSelector = __esm(() => {\n  init_toSignatureHash();\n  toEventSelector = toSignatureHash;\n});\n\n// node_modules/viem/_esm/errors/address.js\nvar InvalidAddressError;\nvar init_address = __esm(() => {\n  init_base();\n  InvalidAddressError = class InvalidAddressError extends BaseError {\n    constructor({ address }) {\n      super(`Address \"${address}\" is invalid.`, {\n        metaMessages: [\n          \"- Address must be a hex value of 20 bytes (40 hex characters).\",\n          \"- Address must match its checksum counterpart.\"\n        ],\n        name: \"InvalidAddressError\"\n      });\n    }\n  };\n});\n\n// node_modules/viem/_esm/utils/lru.js\nvar LruMap;\nvar init_lru = __esm(() => {\n  LruMap = class LruMap extends Map {\n    constructor(size2) {\n      super();\n      Object.defineProperty(this, \"maxSize\", {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value: undefined\n      });\n      this.maxSize = size2;\n    }\n    get(key) {\n      const value = super.get(key);\n      if (super.has(key) && value !== undefined) {\n        this.delete(key);\n        super.set(key, value);\n      }\n      return value;\n    }\n    set(key, value) {\n      super.set(key, value);\n      if (this.maxSize && this.size > this.maxSize) {\n        const firstKey = this.keys().next().value;\n        if (firstKey)\n          this.delete(firstKey);\n      }\n      return this;\n    }\n  };\n});\n\n// node_modules/viem/_esm/utils/address/getAddress.js\nfunction checksumAddress(address_, chainId) {\n  if (checksumAddressCache.has(`${address_}.${chainId}`))\n    return checksumAddressCache.get(`${address_}.${chainId}`);\n  const hexAddress = chainId ? `${chainId}${address_.toLowerCase()}` : address_.substring(2).toLowerCase();\n  const hash2 = keccak256(stringToBytes(hexAddress), \"bytes\");\n  const address = (chainId ? hexAddress.substring(`${chainId}0x`.length) : hexAddress).split(\"\");\n  for (let i = 0;i < 40; i += 2) {\n    if (hash2[i >> 1] >> 4 >= 8 && address[i]) {\n      address[i] = address[i].toUpperCase();\n    }\n    if ((hash2[i >> 1] & 15) >= 8 && address[i + 1]) {\n      address[i + 1] = address[i + 1].toUpperCase();\n    }\n  }\n  const result = `0x${address.join(\"\")}`;\n  checksumAddressCache.set(`${address_}.${chainId}`, result);\n  return result;\n}\nfunction getAddress(address, chainId) {\n  if (!isAddress(address, { strict: false }))\n    throw new InvalidAddressError({ address });\n  return checksumAddress(address, chainId);\n}\nvar checksumAddressCache;\nvar init_getAddress = __esm(() => {\n  init_address();\n  init_toBytes();\n  init_keccak256();\n  init_lru();\n  init_isAddress();\n  checksumAddressCache = /* @__PURE__ */ new LruMap(8192);\n});\n\n// node_modules/viem/_esm/utils/address/isAddress.js\nfunction isAddress(address, options) {\n  const { strict = true } = options ?? {};\n  const cacheKey = `${address}.${strict}`;\n  if (isAddressCache.has(cacheKey))\n    return isAddressCache.get(cacheKey);\n  const result = (() => {\n    if (!addressRegex.test(address))\n      return false;\n    if (address.toLowerCase() === address)\n      return true;\n    if (strict)\n      return checksumAddress(address) === address;\n    return true;\n  })();\n  isAddressCache.set(cacheKey, result);\n  return result;\n}\nvar addressRegex, isAddressCache;\nvar init_isAddress = __esm(() => {\n  init_lru();\n  init_getAddress();\n  addressRegex = /^0x[a-fA-F0-9]{40}$/;\n  isAddressCache = /* @__PURE__ */ new LruMap(8192);\n});\n\n// node_modules/viem/_esm/utils/data/concat.js\nfunction concat(values) {\n  if (typeof values[0] === \"string\")\n    return concatHex(values);\n  return concatBytes(values);\n}\nfunction concatBytes(values) {\n  let length = 0;\n  for (const arr of values) {\n    length += arr.length;\n  }\n  const result = new Uint8Array(length);\n  let offset = 0;\n  for (const arr of values) {\n    result.set(arr, offset);\n    offset += arr.length;\n  }\n  return result;\n}\nfunction concatHex(values) {\n  return `0x${values.reduce((acc, x) => acc + x.replace(\"0x\", \"\"), \"\")}`;\n}\n\n// node_modules/viem/_esm/utils/data/slice.js\nfunction slice(value, start, end, { strict } = {}) {\n  if (isHex(value, { strict: false }))\n    return sliceHex(value, start, end, {\n      strict\n    });\n  return sliceBytes(value, start, end, {\n    strict\n  });\n}\nfunction assertStartOffset(value, start) {\n  if (typeof start === \"number\" && start > 0 && start > size(value) - 1)\n    throw new SliceOffsetOutOfBoundsError({\n      offset: start,\n      position: \"start\",\n      size: size(value)\n    });\n}\nfunction assertEndOffset(value, start, end) {\n  if (typeof start === \"number\" && typeof end === \"number\" && size(value) !== end - start) {\n    throw new SliceOffsetOutOfBoundsError({\n      offset: end,\n      position: \"end\",\n      size: size(value)\n    });\n  }\n}\nfunction sliceBytes(value_, start, end, { strict } = {}) {\n  assertStartOffset(value_, start);\n  const value = value_.slice(start, end);\n  if (strict)\n    assertEndOffset(value, start, end);\n  return value;\n}\nfunction sliceHex(value_, start, end, { strict } = {}) {\n  assertStartOffset(value_, start);\n  const value = `0x${value_.replace(\"0x\", \"\").slice((start ?? 0) * 2, (end ?? value_.length) * 2)}`;\n  if (strict)\n    assertEndOffset(value, start, end);\n  return value;\n}\nvar init_slice = __esm(() => {\n  init_data();\n  init_size();\n});\n\n// node_modules/viem/_esm/utils/regex.js\nvar arrayRegex, bytesRegex, integerRegex;\nvar init_regex2 = __esm(() => {\n  arrayRegex = /^(.*)\\[([0-9]*)\\]$/;\n  bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;\n  integerRegex = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;\n});\n\n// node_modules/viem/_esm/utils/abi/encodeAbiParameters.js\nfunction encodeAbiParameters(params, values) {\n  if (params.length !== values.length)\n    throw new AbiEncodingLengthMismatchError({\n      expectedLength: params.length,\n      givenLength: values.length\n    });\n  const preparedParams = prepareParams({\n    params,\n    values\n  });\n  const data = encodeParams(preparedParams);\n  if (data.length === 0)\n    return \"0x\";\n  return data;\n}\nfunction prepareParams({ params, values }) {\n  const preparedParams = [];\n  for (let i = 0;i < params.length; i++) {\n    preparedParams.push(prepareParam({ param: params[i], value: values[i] }));\n  }\n  return preparedParams;\n}\nfunction prepareParam({ param, value }) {\n  const arrayComponents = getArrayComponents(param.type);\n  if (arrayComponents) {\n    const [length, type] = arrayComponents;\n    return encodeArray(value, { length, param: { ...param, type } });\n  }\n  if (param.type === \"tuple\") {\n    return encodeTuple(value, {\n      param\n    });\n  }\n  if (param.type === \"address\") {\n    return encodeAddress(value);\n  }\n  if (param.type === \"bool\") {\n    return encodeBool(value);\n  }\n  if (param.type.startsWith(\"uint\") || param.type.startsWith(\"int\")) {\n    const signed = param.type.startsWith(\"int\");\n    const [, , size2 = \"256\"] = integerRegex.exec(param.type) ?? [];\n    return encodeNumber(value, {\n      signed,\n      size: Number(size2)\n    });\n  }\n  if (param.type.startsWith(\"bytes\")) {\n    return encodeBytes(value, { param });\n  }\n  if (param.type === \"string\") {\n    return encodeString(value);\n  }\n  throw new InvalidAbiEncodingTypeError(param.type, {\n    docsPath: \"/docs/contract/encodeAbiParameters\"\n  });\n}\nfunction encodeParams(preparedParams) {\n  let staticSize = 0;\n  for (let i = 0;i < preparedParams.length; i++) {\n    const { dynamic, encoded } = preparedParams[i];\n    if (dynamic)\n      staticSize += 32;\n    else\n      staticSize += size(encoded);\n  }\n  const staticParams = [];\n  const dynamicParams = [];\n  let dynamicSize = 0;\n  for (let i = 0;i < preparedParams.length; i++) {\n    const { dynamic, encoded } = preparedParams[i];\n    if (dynamic) {\n      staticParams.push(numberToHex(staticSize + dynamicSize, { size: 32 }));\n      dynamicParams.push(encoded);\n      dynamicSize += size(encoded);\n    } else {\n      staticParams.push(encoded);\n    }\n  }\n  return concat([...staticParams, ...dynamicParams]);\n}\nfunction encodeAddress(value) {\n  if (!isAddress(value))\n    throw new InvalidAddressError({ address: value });\n  return { dynamic: false, encoded: padHex(value.toLowerCase()) };\n}\nfunction encodeArray(value, { length, param }) {\n  const dynamic = length === null;\n  if (!Array.isArray(value))\n    throw new InvalidArrayError(value);\n  if (!dynamic && value.length !== length)\n    throw new AbiEncodingArrayLengthMismatchError({\n      expectedLength: length,\n      givenLength: value.length,\n      type: `${param.type}[${length}]`\n    });\n  let dynamicChild = false;\n  const preparedParams = [];\n  for (let i = 0;i < value.length; i++) {\n    const preparedParam = prepareParam({ param, value: value[i] });\n    if (preparedParam.dynamic)\n      dynamicChild = true;\n    preparedParams.push(preparedParam);\n  }\n  if (dynamic || dynamicChild) {\n    const data = encodeParams(preparedParams);\n    if (dynamic) {\n      const length2 = numberToHex(preparedParams.length, { size: 32 });\n      return {\n        dynamic: true,\n        encoded: preparedParams.length > 0 ? concat([length2, data]) : length2\n      };\n    }\n    if (dynamicChild)\n      return { dynamic: true, encoded: data };\n  }\n  return {\n    dynamic: false,\n    encoded: concat(preparedParams.map(({ encoded }) => encoded))\n  };\n}\nfunction encodeBytes(value, { param }) {\n  const [, paramSize] = param.type.split(\"bytes\");\n  const bytesSize = size(value);\n  if (!paramSize) {\n    let value_ = value;\n    if (bytesSize % 32 !== 0)\n      value_ = padHex(value_, {\n        dir: \"right\",\n        size: Math.ceil((value.length - 2) / 2 / 32) * 32\n      });\n    return {\n      dynamic: true,\n      encoded: concat([padHex(numberToHex(bytesSize, { size: 32 })), value_])\n    };\n  }\n  if (bytesSize !== Number.parseInt(paramSize))\n    throw new AbiEncodingBytesSizeMismatchError({\n      expectedSize: Number.parseInt(paramSize),\n      value\n    });\n  return { dynamic: false, encoded: padHex(value, { dir: \"right\" }) };\n}\nfunction encodeBool(value) {\n  if (typeof value !== \"boolean\")\n    throw new BaseError(`Invalid boolean value: \"${value}\" (type: ${typeof value}). Expected: \\`true\\` or \\`false\\`.`);\n  return { dynamic: false, encoded: padHex(boolToHex(value)) };\n}\nfunction encodeNumber(value, { signed, size: size2 = 256 }) {\n  if (typeof size2 === \"number\") {\n    const max = 2n ** (BigInt(size2) - (signed ? 1n : 0n)) - 1n;\n    const min = signed ? -max - 1n : 0n;\n    if (value > max || value < min)\n      throw new IntegerOutOfRangeError({\n        max: max.toString(),\n        min: min.toString(),\n        signed,\n        size: size2 / 8,\n        value: value.toString()\n      });\n  }\n  return {\n    dynamic: false,\n    encoded: numberToHex(value, {\n      size: 32,\n      signed\n    })\n  };\n}\nfunction encodeString(value) {\n  const hexValue = stringToHex(value);\n  const partsLength = Math.ceil(size(hexValue) / 32);\n  const parts = [];\n  for (let i = 0;i < partsLength; i++) {\n    parts.push(padHex(slice(hexValue, i * 32, (i + 1) * 32), {\n      dir: \"right\"\n    }));\n  }\n  return {\n    dynamic: true,\n    encoded: concat([\n      padHex(numberToHex(size(hexValue), { size: 32 })),\n      ...parts\n    ])\n  };\n}\nfunction encodeTuple(value, { param }) {\n  let dynamic = false;\n  const preparedParams = [];\n  for (let i = 0;i < param.components.length; i++) {\n    const param_ = param.components[i];\n    const index = Array.isArray(value) ? i : param_.name;\n    const preparedParam = prepareParam({\n      param: param_,\n      value: value[index]\n    });\n    preparedParams.push(preparedParam);\n    if (preparedParam.dynamic)\n      dynamic = true;\n  }\n  return {\n    dynamic,\n    encoded: dynamic ? encodeParams(preparedParams) : concat(preparedParams.map(({ encoded }) => encoded))\n  };\n}\nfunction getArrayComponents(type) {\n  const matches = type.match(/^(.*)\\[(\\d+)?\\]$/);\n  return matches ? [matches[2] ? Number(matches[2]) : null, matches[1]] : undefined;\n}\nvar init_encodeAbiParameters = __esm(() => {\n  init_abi();\n  init_address();\n  init_base();\n  init_encoding();\n  init_isAddress();\n  init_pad();\n  init_size();\n  init_slice();\n  init_toHex();\n  init_regex2();\n});\n\n// node_modules/viem/_esm/utils/hash/toFunctionSelector.js\nvar toFunctionSelector = (fn) => slice(toSignatureHash(fn), 0, 4);\nvar init_toFunctionSelector = __esm(() => {\n  init_slice();\n  init_toSignatureHash();\n});\n\n// node_modules/viem/_esm/utils/abi/getAbiItem.js\nfunction getAbiItem(parameters) {\n  const { abi, args = [], name } = parameters;\n  const isSelector = isHex(name, { strict: false });\n  const abiItems = abi.filter((abiItem) => {\n    if (isSelector) {\n      if (abiItem.type === \"function\")\n        return toFunctionSelector(abiItem) === name;\n      if (abiItem.type === \"event\")\n        return toEventSelector(abiItem) === name;\n      return false;\n    }\n    return \"name\" in abiItem && abiItem.name === name;\n  });\n  if (abiItems.length === 0)\n    return;\n  if (abiItems.length === 1)\n    return abiItems[0];\n  let matchedAbiItem = undefined;\n  for (const abiItem of abiItems) {\n    if (!(\"inputs\" in abiItem))\n      continue;\n    if (!args || args.length === 0) {\n      if (!abiItem.inputs || abiItem.inputs.length === 0)\n        return abiItem;\n      continue;\n    }\n    if (!abiItem.inputs)\n      continue;\n    if (abiItem.inputs.length === 0)\n      continue;\n    if (abiItem.inputs.length !== args.length)\n      continue;\n    const matched = args.every((arg, index) => {\n      const abiParameter = \"inputs\" in abiItem && abiItem.inputs[index];\n      if (!abiParameter)\n        return false;\n      return isArgOfType(arg, abiParameter);\n    });\n    if (matched) {\n      if (matchedAbiItem && \"inputs\" in matchedAbiItem && matchedAbiItem.inputs) {\n        const ambiguousTypes = getAmbiguousTypes(abiItem.inputs, matchedAbiItem.inputs, args);\n        if (ambiguousTypes)\n          throw new AbiItemAmbiguityError({\n            abiItem,\n            type: ambiguousTypes[0]\n          }, {\n            abiItem: matchedAbiItem,\n            type: ambiguousTypes[1]\n          });\n      }\n      matchedAbiItem = abiItem;\n    }\n  }\n  if (matchedAbiItem)\n    return matchedAbiItem;\n  return abiItems[0];\n}\nfunction isArgOfType(arg, abiParameter) {\n  const argType = typeof arg;\n  const abiParameterType = abiParameter.type;\n  switch (abiParameterType) {\n    case \"address\":\n      return isAddress(arg, { strict: false });\n    case \"bool\":\n      return argType === \"boolean\";\n    case \"function\":\n      return argType === \"string\";\n    case \"string\":\n      return argType === \"string\";\n    default: {\n      if (abiParameterType === \"tuple\" && \"components\" in abiParameter)\n        return Object.values(abiParameter.components).every((component, index) => {\n          return isArgOfType(Object.values(arg)[index], component);\n        });\n      if (/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(abiParameterType))\n        return argType === \"number\" || argType === \"bigint\";\n      if (/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(abiParameterType))\n        return argType === \"string\" || arg instanceof Uint8Array;\n      if (/[a-z]+[1-9]{0,3}(\\[[0-9]{0,}\\])+$/.test(abiParameterType)) {\n        return Array.isArray(arg) && arg.every((x) => isArgOfType(x, {\n          ...abiParameter,\n          type: abiParameterType.replace(/(\\[[0-9]{0,}\\])$/, \"\")\n        }));\n      }\n      return false;\n    }\n  }\n}\nfunction getAmbiguousTypes(sourceParameters, targetParameters, args) {\n  for (const parameterIndex in sourceParameters) {\n    const sourceParameter = sourceParameters[parameterIndex];\n    const targetParameter = targetParameters[parameterIndex];\n    if (sourceParameter.type === \"tuple\" && targetParameter.type === \"tuple\" && \"components\" in sourceParameter && \"components\" in targetParameter)\n      return getAmbiguousTypes(sourceParameter.components, targetParameter.components, args[parameterIndex]);\n    const types = [sourceParameter.type, targetParameter.type];\n    const ambiguous = (() => {\n      if (types.includes(\"address\") && types.includes(\"bytes20\"))\n        return true;\n      if (types.includes(\"address\") && types.includes(\"string\"))\n        return isAddress(args[parameterIndex], { strict: false });\n      if (types.includes(\"address\") && types.includes(\"bytes\"))\n        return isAddress(args[parameterIndex], { strict: false });\n      return false;\n    })();\n    if (ambiguous)\n      return types;\n  }\n  return;\n}\nvar init_getAbiItem = __esm(() => {\n  init_abi();\n  init_isAddress();\n  init_toEventSelector();\n  init_toFunctionSelector();\n});\n\n// node_modules/viem/_esm/utils/abi/prepareEncodeFunctionData.js\nfunction prepareEncodeFunctionData(parameters) {\n  const { abi, args, functionName } = parameters;\n  let abiItem = abi[0];\n  if (functionName) {\n    const item = getAbiItem({\n      abi,\n      args,\n      name: functionName\n    });\n    if (!item)\n      throw new AbiFunctionNotFoundError(functionName, { docsPath });\n    abiItem = item;\n  }\n  if (abiItem.type !== \"function\")\n    throw new AbiFunctionNotFoundError(undefined, { docsPath });\n  return {\n    abi: [abiItem],\n    functionName: toFunctionSelector(formatAbiItem2(abiItem))\n  };\n}\nvar docsPath = \"/docs/contract/encodeFunctionData\";\nvar init_prepareEncodeFunctionData = __esm(() => {\n  init_abi();\n  init_toFunctionSelector();\n  init_formatAbiItem2();\n  init_getAbiItem();\n});\n\n// node_modules/viem/_esm/utils/abi/encodeFunctionData.js\nfunction encodeFunctionData(parameters) {\n  const { args } = parameters;\n  const { abi, functionName } = (() => {\n    if (parameters.abi.length === 1 && parameters.functionName?.startsWith(\"0x\"))\n      return parameters;\n    return prepareEncodeFunctionData(parameters);\n  })();\n  const abiItem = abi[0];\n  const signature = functionName;\n  const data = \"inputs\" in abiItem && abiItem.inputs ? encodeAbiParameters(abiItem.inputs, args ?? []) : undefined;\n  return concatHex([signature, data ?? \"0x\"]);\n}\nvar init_encodeFunctionData = __esm(() => {\n  init_encodeAbiParameters();\n  init_prepareEncodeFunctionData();\n});\n\n// node_modules/viem/_esm/errors/cursor.js\nvar NegativeOffsetError, PositionOutOfBoundsError, RecursiveReadLimitExceededError;\nvar init_cursor = __esm(() => {\n  init_base();\n  NegativeOffsetError = class NegativeOffsetError extends BaseError {\n    constructor({ offset }) {\n      super(`Offset \\`${offset}\\` cannot be negative.`, {\n        name: \"NegativeOffsetError\"\n      });\n    }\n  };\n  PositionOutOfBoundsError = class PositionOutOfBoundsError extends BaseError {\n    constructor({ length, position }) {\n      super(`Position \\`${position}\\` is out of bounds (\\`0 < position < ${length}\\`).`, { name: \"PositionOutOfBoundsError\" });\n    }\n  };\n  RecursiveReadLimitExceededError = class RecursiveReadLimitExceededError extends BaseError {\n    constructor({ count, limit }) {\n      super(`Recursive read limit of \\`${limit}\\` exceeded (recursive read count: \\`${count}\\`).`, { name: \"RecursiveReadLimitExceededError\" });\n    }\n  };\n});\n\n// node_modules/viem/_esm/utils/cursor.js\nfunction createCursor(bytes, { recursiveReadLimit = 8192 } = {}) {\n  const cursor = Object.create(staticCursor);\n  cursor.bytes = bytes;\n  cursor.dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n  cursor.positionReadCount = new Map;\n  cursor.recursiveReadLimit = recursiveReadLimit;\n  return cursor;\n}\nvar staticCursor;\nvar init_cursor2 = __esm(() => {\n  init_cursor();\n  staticCursor = {\n    bytes: new Uint8Array,\n    dataView: new DataView(new ArrayBuffer(0)),\n    position: 0,\n    positionReadCount: new Map,\n    recursiveReadCount: 0,\n    recursiveReadLimit: Number.POSITIVE_INFINITY,\n    assertReadLimit() {\n      if (this.recursiveReadCount >= this.recursiveReadLimit)\n        throw new RecursiveReadLimitExceededError({\n          count: this.recursiveReadCount + 1,\n          limit: this.recursiveReadLimit\n        });\n    },\n    assertPosition(position) {\n      if (position < 0 || position > this.bytes.length - 1)\n        throw new PositionOutOfBoundsError({\n          length: this.bytes.length,\n          position\n        });\n    },\n    decrementPosition(offset) {\n      if (offset < 0)\n        throw new NegativeOffsetError({ offset });\n      const position = this.position - offset;\n      this.assertPosition(position);\n      this.position = position;\n    },\n    getReadCount(position) {\n      return this.positionReadCount.get(position || this.position) || 0;\n    },\n    incrementPosition(offset) {\n      if (offset < 0)\n        throw new NegativeOffsetError({ offset });\n      const position = this.position + offset;\n      this.assertPosition(position);\n      this.position = position;\n    },\n    inspectByte(position_) {\n      const position = position_ ?? this.position;\n      this.assertPosition(position);\n      return this.bytes[position];\n    },\n    inspectBytes(length, position_) {\n      const position = position_ ?? this.position;\n      this.assertPosition(position + length - 1);\n      return this.bytes.subarray(position, position + length);\n    },\n    inspectUint8(position_) {\n      const position = position_ ?? this.position;\n      this.assertPosition(position);\n      return this.bytes[position];\n    },\n    inspectUint16(position_) {\n      const position = position_ ?? this.position;\n      this.assertPosition(position + 1);\n      return this.dataView.getUint16(position);\n    },\n    inspectUint24(position_) {\n      const position = position_ ?? this.position;\n      this.assertPosition(position + 2);\n      return (this.dataView.getUint16(position) << 8) + this.dataView.getUint8(position + 2);\n    },\n    inspectUint32(position_) {\n      const position = position_ ?? this.position;\n      this.assertPosition(position + 3);\n      return this.dataView.getUint32(position);\n    },\n    pushByte(byte) {\n      this.assertPosition(this.position);\n      this.bytes[this.position] = byte;\n      this.position++;\n    },\n    pushBytes(bytes) {\n      this.assertPosition(this.position + bytes.length - 1);\n      this.bytes.set(bytes, this.position);\n      this.position += bytes.length;\n    },\n    pushUint8(value) {\n      this.assertPosition(this.position);\n      this.bytes[this.position] = value;\n      this.position++;\n    },\n    pushUint16(value) {\n      this.assertPosition(this.position + 1);\n      this.dataView.setUint16(this.position, value);\n      this.position += 2;\n    },\n    pushUint24(value) {\n      this.assertPosition(this.position + 2);\n      this.dataView.setUint16(this.position, value >> 8);\n      this.dataView.setUint8(this.position + 2, value & ~4294967040);\n      this.position += 3;\n    },\n    pushUint32(value) {\n      this.assertPosition(this.position + 3);\n      this.dataView.setUint32(this.position, value);\n      this.position += 4;\n    },\n    readByte() {\n      this.assertReadLimit();\n      this._touch();\n      const value = this.inspectByte();\n      this.position++;\n      return value;\n    },\n    readBytes(length, size2) {\n      this.assertReadLimit();\n      this._touch();\n      const value = this.inspectBytes(length);\n      this.position += size2 ?? length;\n      return value;\n    },\n    readUint8() {\n      this.assertReadLimit();\n      this._touch();\n      const value = this.inspectUint8();\n      this.position += 1;\n      return value;\n    },\n    readUint16() {\n      this.assertReadLimit();\n      this._touch();\n      const value = this.inspectUint16();\n      this.position += 2;\n      return value;\n    },\n    readUint24() {\n      this.assertReadLimit();\n      this._touch();\n      const value = this.inspectUint24();\n      this.position += 3;\n      return value;\n    },\n    readUint32() {\n      this.assertReadLimit();\n      this._touch();\n      const value = this.inspectUint32();\n      this.position += 4;\n      return value;\n    },\n    get remaining() {\n      return this.bytes.length - this.position;\n    },\n    setPosition(position) {\n      const oldPosition = this.position;\n      this.assertPosition(position);\n      this.position = position;\n      return () => this.position = oldPosition;\n    },\n    _touch() {\n      if (this.recursiveReadLimit === Number.POSITIVE_INFINITY)\n        return;\n      const count = this.getReadCount();\n      this.positionReadCount.set(this.position, count + 1);\n      if (count > 0)\n        this.recursiveReadCount++;\n    }\n  };\n});\n\n// node_modules/viem/_esm/constants/unit.js\nvar gweiUnits;\nvar init_unit = __esm(() => {\n  gweiUnits = {\n    ether: -9,\n    wei: 9\n  };\n});\n\n// node_modules/viem/_esm/utils/unit/formatUnits.js\nfunction formatUnits(value, decimals) {\n  let display = value.toString();\n  const negative = display.startsWith(\"-\");\n  if (negative)\n    display = display.slice(1);\n  display = display.padStart(decimals, \"0\");\n  let [integer2, fraction] = [\n    display.slice(0, display.length - decimals),\n    display.slice(display.length - decimals)\n  ];\n  fraction = fraction.replace(/(0+)$/, \"\");\n  return `${negative ? \"-\" : \"\"}${integer2 || \"0\"}${fraction ? `.${fraction}` : \"\"}`;\n}\n\n// node_modules/viem/_esm/utils/unit/formatGwei.js\nfunction formatGwei(wei, unit = \"wei\") {\n  return formatUnits(wei, gweiUnits[unit]);\n}\nvar init_formatGwei = __esm(() => {\n  init_unit();\n});\n\n// node_modules/viem/_esm/errors/transaction.js\nfunction prettyPrint(args) {\n  const entries = Object.entries(args).map(([key, value]) => {\n    if (value === undefined || value === false)\n      return null;\n    return [key, value];\n  }).filter(Boolean);\n  const maxLength = entries.reduce((acc, [key]) => Math.max(acc, key.length), 0);\n  return entries.map(([key, value]) => `  ${`${key}:`.padEnd(maxLength + 1)}  ${value}`).join(`\n`);\n}\nvar InvalidLegacyVError, InvalidSerializableTransactionError, InvalidStorageKeySizeError;\nvar init_transaction = __esm(() => {\n  init_base();\n  InvalidLegacyVError = class InvalidLegacyVError extends BaseError {\n    constructor({ v }) {\n      super(`Invalid \\`v\\` value \"${v}\". Expected 27 or 28.`, {\n        name: \"InvalidLegacyVError\"\n      });\n    }\n  };\n  InvalidSerializableTransactionError = class InvalidSerializableTransactionError extends BaseError {\n    constructor({ transaction }) {\n      super(\"Cannot infer a transaction type from provided transaction.\", {\n        metaMessages: [\n          \"Provided Transaction:\",\n          \"{\",\n          prettyPrint(transaction),\n          \"}\",\n          \"\",\n          \"To infer the type, either provide:\",\n          \"- a `type` to the Transaction, or\",\n          \"- an EIP-1559 Transaction with `maxFeePerGas`, or\",\n          \"- an EIP-2930 Transaction with `gasPrice` & `accessList`, or\",\n          \"- an EIP-4844 Transaction with `blobs`, `blobVersionedHashes`, `sidecars`, or\",\n          \"- an EIP-7702 Transaction with `authorizationList`, or\",\n          \"- a Legacy Transaction with `gasPrice`\"\n        ],\n        name: \"InvalidSerializableTransactionError\"\n      });\n    }\n  };\n  InvalidStorageKeySizeError = class InvalidStorageKeySizeError extends BaseError {\n    constructor({ storageKey }) {\n      super(`Size for storage key \"${storageKey}\" is invalid. Expected 32 bytes. Got ${Math.floor((storageKey.length - 2) / 2)} bytes.`, { name: \"InvalidStorageKeySizeError\" });\n    }\n  };\n});\n\n// node_modules/viem/_esm/errors/node.js\nvar ExecutionRevertedError, FeeCapTooHighError, FeeCapTooLowError, NonceTooHighError, NonceTooLowError, NonceMaxValueError, InsufficientFundsError, IntrinsicGasTooHighError, IntrinsicGasTooLowError, TransactionTypeNotSupportedError, TipAboveFeeCapError;\nvar init_node = __esm(() => {\n  init_formatGwei();\n  init_base();\n  ExecutionRevertedError = class ExecutionRevertedError extends BaseError {\n    constructor({ cause, message } = {}) {\n      const reason = message?.replace(\"execution reverted: \", \"\")?.replace(\"execution reverted\", \"\");\n      super(`Execution reverted ${reason ? `with reason: ${reason}` : \"for an unknown reason\"}.`, {\n        cause,\n        name: \"ExecutionRevertedError\"\n      });\n    }\n  };\n  Object.defineProperty(ExecutionRevertedError, \"code\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: 3\n  });\n  Object.defineProperty(ExecutionRevertedError, \"nodeMessage\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: /execution reverted/\n  });\n  FeeCapTooHighError = class FeeCapTooHighError extends BaseError {\n    constructor({ cause, maxFeePerGas } = {}) {\n      super(`The fee cap (\\`maxFeePerGas\\`${maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)} gwei` : \"\"}) cannot be higher than the maximum allowed value (2^256-1).`, {\n        cause,\n        name: \"FeeCapTooHighError\"\n      });\n    }\n  };\n  Object.defineProperty(FeeCapTooHighError, \"nodeMessage\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: /max fee per gas higher than 2\\^256-1|fee cap higher than 2\\^256-1/\n  });\n  FeeCapTooLowError = class FeeCapTooLowError extends BaseError {\n    constructor({ cause, maxFeePerGas } = {}) {\n      super(`The fee cap (\\`maxFeePerGas\\`${maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)}` : \"\"} gwei) cannot be lower than the block base fee.`, {\n        cause,\n        name: \"FeeCapTooLowError\"\n      });\n    }\n  };\n  Object.defineProperty(FeeCapTooLowError, \"nodeMessage\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: /max fee per gas less than block base fee|fee cap less than block base fee|transaction is outdated/\n  });\n  NonceTooHighError = class NonceTooHighError extends BaseError {\n    constructor({ cause, nonce } = {}) {\n      super(`Nonce provided for the transaction ${nonce ? `(${nonce}) ` : \"\"}is higher than the next one expected.`, { cause, name: \"NonceTooHighError\" });\n    }\n  };\n  Object.defineProperty(NonceTooHighError, \"nodeMessage\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: /nonce too high/\n  });\n  NonceTooLowError = class NonceTooLowError extends BaseError {\n    constructor({ cause, nonce } = {}) {\n      super([\n        `Nonce provided for the transaction ${nonce ? `(${nonce}) ` : \"\"}is lower than the current nonce of the account.`,\n        \"Try increasing the nonce or find the latest nonce with `getTransactionCount`.\"\n      ].join(`\n`), { cause, name: \"NonceTooLowError\" });\n    }\n  };\n  Object.defineProperty(NonceTooLowError, \"nodeMessage\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: /nonce too low|transaction already imported|already known/\n  });\n  NonceMaxValueError = class NonceMaxValueError extends BaseError {\n    constructor({ cause, nonce } = {}) {\n      super(`Nonce provided for the transaction ${nonce ? `(${nonce}) ` : \"\"}exceeds the maximum allowed nonce.`, { cause, name: \"NonceMaxValueError\" });\n    }\n  };\n  Object.defineProperty(NonceMaxValueError, \"nodeMessage\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: /nonce has max value/\n  });\n  InsufficientFundsError = class InsufficientFundsError extends BaseError {\n    constructor({ cause } = {}) {\n      super([\n        \"The total cost (gas * gas fee + value) of executing this transaction exceeds the balance of the account.\"\n      ].join(`\n`), {\n        cause,\n        metaMessages: [\n          \"This error could arise when the account does not have enough funds to:\",\n          \" - pay for the total gas fee,\",\n          \" - pay for the value to send.\",\n          \" \",\n          \"The cost of the transaction is calculated as `gas * gas fee + value`, where:\",\n          \" - `gas` is the amount of gas needed for transaction to execute,\",\n          \" - `gas fee` is the gas fee,\",\n          \" - `value` is the amount of ether to send to the recipient.\"\n        ],\n        name: \"InsufficientFundsError\"\n      });\n    }\n  };\n  Object.defineProperty(InsufficientFundsError, \"nodeMessage\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: /insufficient funds|exceeds transaction sender account balance/\n  });\n  IntrinsicGasTooHighError = class IntrinsicGasTooHighError extends BaseError {\n    constructor({ cause, gas } = {}) {\n      super(`The amount of gas ${gas ? `(${gas}) ` : \"\"}provided for the transaction exceeds the limit allowed for the block.`, {\n        cause,\n        name: \"IntrinsicGasTooHighError\"\n      });\n    }\n  };\n  Object.defineProperty(IntrinsicGasTooHighError, \"nodeMessage\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: /intrinsic gas too high|gas limit reached/\n  });\n  IntrinsicGasTooLowError = class IntrinsicGasTooLowError extends BaseError {\n    constructor({ cause, gas } = {}) {\n      super(`The amount of gas ${gas ? `(${gas}) ` : \"\"}provided for the transaction is too low.`, {\n        cause,\n        name: \"IntrinsicGasTooLowError\"\n      });\n    }\n  };\n  Object.defineProperty(IntrinsicGasTooLowError, \"nodeMessage\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: /intrinsic gas too low/\n  });\n  TransactionTypeNotSupportedError = class TransactionTypeNotSupportedError extends BaseError {\n    constructor({ cause }) {\n      super(\"The transaction type is not supported for this chain.\", {\n        cause,\n        name: \"TransactionTypeNotSupportedError\"\n      });\n    }\n  };\n  Object.defineProperty(TransactionTypeNotSupportedError, \"nodeMessage\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: /transaction type not valid/\n  });\n  TipAboveFeeCapError = class TipAboveFeeCapError extends BaseError {\n    constructor({ cause, maxPriorityFeePerGas, maxFeePerGas } = {}) {\n      super([\n        `The provided tip (\\`maxPriorityFeePerGas\\`${maxPriorityFeePerGas ? ` = ${formatGwei(maxPriorityFeePerGas)} gwei` : \"\"}) cannot be higher than the fee cap (\\`maxFeePerGas\\`${maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)} gwei` : \"\"}).`\n      ].join(`\n`), {\n        cause,\n        name: \"TipAboveFeeCapError\"\n      });\n    }\n  };\n  Object.defineProperty(TipAboveFeeCapError, \"nodeMessage\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: /max priority fee per gas higher than max fee per gas|tip higher than fee cap/\n  });\n});\n\n// node_modules/viem/_esm/utils/formatters/formatter.js\nfunction defineFormatter(type, format) {\n  return ({ exclude, format: overrides }) => {\n    return {\n      exclude,\n      format: (args) => {\n        const formatted = format(args);\n        if (exclude) {\n          for (const key of exclude) {\n            delete formatted[key];\n          }\n        }\n        return {\n          ...formatted,\n          ...overrides(args)\n        };\n      },\n      type\n    };\n  };\n}\n\n// node_modules/viem/_esm/constants/number.js\nvar maxInt8, maxInt16, maxInt24, maxInt32, maxInt40, maxInt48, maxInt56, maxInt64, maxInt72, maxInt80, maxInt88, maxInt96, maxInt104, maxInt112, maxInt120, maxInt128, maxInt136, maxInt144, maxInt152, maxInt160, maxInt168, maxInt176, maxInt184, maxInt192, maxInt200, maxInt208, maxInt216, maxInt224, maxInt232, maxInt240, maxInt248, maxInt256, minInt8, minInt16, minInt24, minInt32, minInt40, minInt48, minInt56, minInt64, minInt72, minInt80, minInt88, minInt96, minInt104, minInt112, minInt120, minInt128, minInt136, minInt144, minInt152, minInt160, minInt168, minInt176, minInt184, minInt192, minInt200, minInt208, minInt216, minInt224, minInt232, minInt240, minInt248, minInt256, maxUint8, maxUint16, maxUint24, maxUint32, maxUint40, maxUint48, maxUint56, maxUint64, maxUint72, maxUint80, maxUint88, maxUint96, maxUint104, maxUint112, maxUint120, maxUint128, maxUint136, maxUint144, maxUint152, maxUint160, maxUint168, maxUint176, maxUint184, maxUint192, maxUint200, maxUint208, maxUint216, maxUint224, maxUint232, maxUint240, maxUint248, maxUint256;\nvar init_number = __esm(() => {\n  maxInt8 = 2n ** (8n - 1n) - 1n;\n  maxInt16 = 2n ** (16n - 1n) - 1n;\n  maxInt24 = 2n ** (24n - 1n) - 1n;\n  maxInt32 = 2n ** (32n - 1n) - 1n;\n  maxInt40 = 2n ** (40n - 1n) - 1n;\n  maxInt48 = 2n ** (48n - 1n) - 1n;\n  maxInt56 = 2n ** (56n - 1n) - 1n;\n  maxInt64 = 2n ** (64n - 1n) - 1n;\n  maxInt72 = 2n ** (72n - 1n) - 1n;\n  maxInt80 = 2n ** (80n - 1n) - 1n;\n  maxInt88 = 2n ** (88n - 1n) - 1n;\n  maxInt96 = 2n ** (96n - 1n) - 1n;\n  maxInt104 = 2n ** (104n - 1n) - 1n;\n  maxInt112 = 2n ** (112n - 1n) - 1n;\n  maxInt120 = 2n ** (120n - 1n) - 1n;\n  maxInt128 = 2n ** (128n - 1n) - 1n;\n  maxInt136 = 2n ** (136n - 1n) - 1n;\n  maxInt144 = 2n ** (144n - 1n) - 1n;\n  maxInt152 = 2n ** (152n - 1n) - 1n;\n  maxInt160 = 2n ** (160n - 1n) - 1n;\n  maxInt168 = 2n ** (168n - 1n) - 1n;\n  maxInt176 = 2n ** (176n - 1n) - 1n;\n  maxInt184 = 2n ** (184n - 1n) - 1n;\n  maxInt192 = 2n ** (192n - 1n) - 1n;\n  maxInt200 = 2n ** (200n - 1n) - 1n;\n  maxInt208 = 2n ** (208n - 1n) - 1n;\n  maxInt216 = 2n ** (216n - 1n) - 1n;\n  maxInt224 = 2n ** (224n - 1n) - 1n;\n  maxInt232 = 2n ** (232n - 1n) - 1n;\n  maxInt240 = 2n ** (240n - 1n) - 1n;\n  maxInt248 = 2n ** (248n - 1n) - 1n;\n  maxInt256 = 2n ** (256n - 1n) - 1n;\n  minInt8 = -(2n ** (8n - 1n));\n  minInt16 = -(2n ** (16n - 1n));\n  minInt24 = -(2n ** (24n - 1n));\n  minInt32 = -(2n ** (32n - 1n));\n  minInt40 = -(2n ** (40n - 1n));\n  minInt48 = -(2n ** (48n - 1n));\n  minInt56 = -(2n ** (56n - 1n));\n  minInt64 = -(2n ** (64n - 1n));\n  minInt72 = -(2n ** (72n - 1n));\n  minInt80 = -(2n ** (80n - 1n));\n  minInt88 = -(2n ** (88n - 1n));\n  minInt96 = -(2n ** (96n - 1n));\n  minInt104 = -(2n ** (104n - 1n));\n  minInt112 = -(2n ** (112n - 1n));\n  minInt120 = -(2n ** (120n - 1n));\n  minInt128 = -(2n ** (128n - 1n));\n  minInt136 = -(2n ** (136n - 1n));\n  minInt144 = -(2n ** (144n - 1n));\n  minInt152 = -(2n ** (152n - 1n));\n  minInt160 = -(2n ** (160n - 1n));\n  minInt168 = -(2n ** (168n - 1n));\n  minInt176 = -(2n ** (176n - 1n));\n  minInt184 = -(2n ** (184n - 1n));\n  minInt192 = -(2n ** (192n - 1n));\n  minInt200 = -(2n ** (200n - 1n));\n  minInt208 = -(2n ** (208n - 1n));\n  minInt216 = -(2n ** (216n - 1n));\n  minInt224 = -(2n ** (224n - 1n));\n  minInt232 = -(2n ** (232n - 1n));\n  minInt240 = -(2n ** (240n - 1n));\n  minInt248 = -(2n ** (248n - 1n));\n  minInt256 = -(2n ** (256n - 1n));\n  maxUint8 = 2n ** 8n - 1n;\n  maxUint16 = 2n ** 16n - 1n;\n  maxUint24 = 2n ** 24n - 1n;\n  maxUint32 = 2n ** 32n - 1n;\n  maxUint40 = 2n ** 40n - 1n;\n  maxUint48 = 2n ** 48n - 1n;\n  maxUint56 = 2n ** 56n - 1n;\n  maxUint64 = 2n ** 64n - 1n;\n  maxUint72 = 2n ** 72n - 1n;\n  maxUint80 = 2n ** 80n - 1n;\n  maxUint88 = 2n ** 88n - 1n;\n  maxUint96 = 2n ** 96n - 1n;\n  maxUint104 = 2n ** 104n - 1n;\n  maxUint112 = 2n ** 112n - 1n;\n  maxUint120 = 2n ** 120n - 1n;\n  maxUint128 = 2n ** 128n - 1n;\n  maxUint136 = 2n ** 136n - 1n;\n  maxUint144 = 2n ** 144n - 1n;\n  maxUint152 = 2n ** 152n - 1n;\n  maxUint160 = 2n ** 160n - 1n;\n  maxUint168 = 2n ** 168n - 1n;\n  maxUint176 = 2n ** 176n - 1n;\n  maxUint184 = 2n ** 184n - 1n;\n  maxUint192 = 2n ** 192n - 1n;\n  maxUint200 = 2n ** 200n - 1n;\n  maxUint208 = 2n ** 208n - 1n;\n  maxUint216 = 2n ** 216n - 1n;\n  maxUint224 = 2n ** 224n - 1n;\n  maxUint232 = 2n ** 232n - 1n;\n  maxUint240 = 2n ** 240n - 1n;\n  maxUint248 = 2n ** 248n - 1n;\n  maxUint256 = 2n ** 256n - 1n;\n});\n\n// node_modules/@noble/hashes/esm/_md.js\nfunction setBigUint64(view, byteOffset, value, isLE2) {\n  if (typeof view.setBigUint64 === \"function\")\n    return view.setBigUint64(byteOffset, value, isLE2);\n  const _32n2 = BigInt(32);\n  const _u32_max = BigInt(4294967295);\n  const wh = Number(value >> _32n2 & _u32_max);\n  const wl = Number(value & _u32_max);\n  const h = isLE2 ? 4 : 0;\n  const l = isLE2 ? 0 : 4;\n  view.setUint32(byteOffset + h, wh, isLE2);\n  view.setUint32(byteOffset + l, wl, isLE2);\n}\nfunction Chi(a, b, c) {\n  return a & b ^ ~a & c;\n}\nfunction Maj(a, b, c) {\n  return a & b ^ a & c ^ b & c;\n}\nvar HashMD, SHA256_IV;\nvar init__md = __esm(() => {\n  init_utils();\n  HashMD = class HashMD extends Hash {\n    constructor(blockLen, outputLen, padOffset, isLE2) {\n      super();\n      this.finished = false;\n      this.length = 0;\n      this.pos = 0;\n      this.destroyed = false;\n      this.blockLen = blockLen;\n      this.outputLen = outputLen;\n      this.padOffset = padOffset;\n      this.isLE = isLE2;\n      this.buffer = new Uint8Array(blockLen);\n      this.view = createView(this.buffer);\n    }\n    update(data) {\n      aexists(this);\n      data = toBytes(data);\n      abytes(data);\n      const { view, buffer, blockLen } = this;\n      const len = data.length;\n      for (let pos = 0;pos < len; ) {\n        const take = Math.min(blockLen - this.pos, len - pos);\n        if (take === blockLen) {\n          const dataView = createView(data);\n          for (;blockLen <= len - pos; pos += blockLen)\n            this.process(dataView, pos);\n          continue;\n        }\n        buffer.set(data.subarray(pos, pos + take), this.pos);\n        this.pos += take;\n        pos += take;\n        if (this.pos === blockLen) {\n          this.process(view, 0);\n          this.pos = 0;\n        }\n      }\n      this.length += data.length;\n      this.roundClean();\n      return this;\n    }\n    digestInto(out) {\n      aexists(this);\n      aoutput(out, this);\n      this.finished = true;\n      const { buffer, view, blockLen, isLE: isLE2 } = this;\n      let { pos } = this;\n      buffer[pos++] = 128;\n      clean(this.buffer.subarray(pos));\n      if (this.padOffset > blockLen - pos) {\n        this.process(view, 0);\n        pos = 0;\n      }\n      for (let i = pos;i < blockLen; i++)\n        buffer[i] = 0;\n      setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE2);\n      this.process(view, 0);\n      const oview = createView(out);\n      const len = this.outputLen;\n      if (len % 4)\n        throw new Error(\"_sha2: outputLen should be aligned to 32bit\");\n      const outLen = len / 4;\n      const state = this.get();\n      if (outLen > state.length)\n        throw new Error(\"_sha2: outputLen bigger than state\");\n      for (let i = 0;i < outLen; i++)\n        oview.setUint32(4 * i, state[i], isLE2);\n    }\n    digest() {\n      const { buffer, outputLen } = this;\n      this.digestInto(buffer);\n      const res = buffer.slice(0, outputLen);\n      this.destroy();\n      return res;\n    }\n    _cloneInto(to) {\n      to || (to = new this.constructor);\n      to.set(...this.get());\n      const { blockLen, buffer, length, finished, destroyed, pos } = this;\n      to.destroyed = destroyed;\n      to.finished = finished;\n      to.length = length;\n      to.pos = pos;\n      if (length % blockLen)\n        to.buffer.set(buffer);\n      return to;\n    }\n    clone() {\n      return this._cloneInto();\n    }\n  };\n  SHA256_IV = /* @__PURE__ */ Uint32Array.from([\n    1779033703,\n    3144134277,\n    1013904242,\n    2773480762,\n    1359893119,\n    2600822924,\n    528734635,\n    1541459225\n  ]);\n});\n\n// node_modules/@noble/hashes/esm/sha2.js\nvar SHA256_K, SHA256_W, SHA256, sha256;\nvar init_sha2 = __esm(() => {\n  init__md();\n  init_utils();\n  SHA256_K = /* @__PURE__ */ Uint32Array.from([\n    1116352408,\n    1899447441,\n    3049323471,\n    3921009573,\n    961987163,\n    1508970993,\n    2453635748,\n    2870763221,\n    3624381080,\n    310598401,\n    607225278,\n    1426881987,\n    1925078388,\n    2162078206,\n    2614888103,\n    3248222580,\n    3835390401,\n    4022224774,\n    264347078,\n    604807628,\n    770255983,\n    1249150122,\n    1555081692,\n    1996064986,\n    2554220882,\n    2821834349,\n    2952996808,\n    3210313671,\n    3336571891,\n    3584528711,\n    113926993,\n    338241895,\n    666307205,\n    773529912,\n    1294757372,\n    1396182291,\n    1695183700,\n    1986661051,\n    2177026350,\n    2456956037,\n    2730485921,\n    2820302411,\n    3259730800,\n    3345764771,\n    3516065817,\n    3600352804,\n    4094571909,\n    275423344,\n    430227734,\n    506948616,\n    659060556,\n    883997877,\n    958139571,\n    1322822218,\n    1537002063,\n    1747873779,\n    1955562222,\n    2024104815,\n    2227730452,\n    2361852424,\n    2428436474,\n    2756734187,\n    3204031479,\n    3329325298\n  ]);\n  SHA256_W = /* @__PURE__ */ new Uint32Array(64);\n  SHA256 = class SHA256 extends HashMD {\n    constructor(outputLen = 32) {\n      super(64, outputLen, 8, false);\n      this.A = SHA256_IV[0] | 0;\n      this.B = SHA256_IV[1] | 0;\n      this.C = SHA256_IV[2] | 0;\n      this.D = SHA256_IV[3] | 0;\n      this.E = SHA256_IV[4] | 0;\n      this.F = SHA256_IV[5] | 0;\n      this.G = SHA256_IV[6] | 0;\n      this.H = SHA256_IV[7] | 0;\n    }\n    get() {\n      const { A, B, C, D, E, F, G, H } = this;\n      return [A, B, C, D, E, F, G, H];\n    }\n    set(A, B, C, D, E, F, G, H) {\n      this.A = A | 0;\n      this.B = B | 0;\n      this.C = C | 0;\n      this.D = D | 0;\n      this.E = E | 0;\n      this.F = F | 0;\n      this.G = G | 0;\n      this.H = H | 0;\n    }\n    process(view, offset) {\n      for (let i = 0;i < 16; i++, offset += 4)\n        SHA256_W[i] = view.getUint32(offset, false);\n      for (let i = 16;i < 64; i++) {\n        const W15 = SHA256_W[i - 15];\n        const W2 = SHA256_W[i - 2];\n        const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;\n        const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;\n        SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;\n      }\n      let { A, B, C, D, E, F, G, H } = this;\n      for (let i = 0;i < 64; i++) {\n        const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);\n        const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;\n        const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);\n        const T2 = sigma0 + Maj(A, B, C) | 0;\n        H = G;\n        G = F;\n        F = E;\n        E = D + T1 | 0;\n        D = C;\n        C = B;\n        B = A;\n        A = T1 + T2 | 0;\n      }\n      A = A + this.A | 0;\n      B = B + this.B | 0;\n      C = C + this.C | 0;\n      D = D + this.D | 0;\n      E = E + this.E | 0;\n      F = F + this.F | 0;\n      G = G + this.G | 0;\n      H = H + this.H | 0;\n      this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n      clean(SHA256_W);\n    }\n    destroy() {\n      this.set(0, 0, 0, 0, 0, 0, 0, 0);\n      clean(this.buffer);\n    }\n  };\n  sha256 = /* @__PURE__ */ createHasher(() => new SHA256);\n});\n\n// node_modules/viem/_esm/errors/chain.js\nvar InvalidChainIdError;\nvar init_chain = __esm(() => {\n  init_base();\n  InvalidChainIdError = class InvalidChainIdError extends BaseError {\n    constructor({ chainId }) {\n      super(typeof chainId === \"number\" ? `Chain ID \"${chainId}\" is invalid.` : \"Chain ID is invalid.\", { name: \"InvalidChainIdError\" });\n    }\n  };\n});\n\n// node_modules/@metamask/superstruct/dist/error.mjs\nclass StructError extends TypeError {\n  constructor(failure, failures) {\n    let cached;\n    const { message, explanation, ...rest } = failure;\n    const { path } = failure;\n    const cause = path.length === 0 ? message : `At path: ${path.join(\".\")} -- ${message}`;\n    super(explanation ?? cause);\n    if (explanation !== null && explanation !== undefined) {\n      this.cause = cause;\n    }\n    Object.assign(this, rest);\n    this.name = this.constructor.name;\n    this.failures = () => {\n      return cached ?? (cached = [failure, ...failures()]);\n    };\n  }\n}\n\n// node_modules/@metamask/superstruct/dist/utils.mjs\nfunction isIterable(value) {\n  return isObject(value) && typeof value[Symbol.iterator] === \"function\";\n}\nfunction isObject(value) {\n  return typeof value === \"object\" && value !== null;\n}\nfunction print(value) {\n  if (typeof value === \"symbol\") {\n    return value.toString();\n  }\n  return typeof value === \"string\" ? JSON.stringify(value) : `${value}`;\n}\nfunction shiftIterator(input) {\n  const { done, value } = input.next();\n  return done ? undefined : value;\n}\nfunction toFailure(result, context, struct, value) {\n  if (result === true) {\n    return;\n  } else if (result === false) {\n    result = {};\n  } else if (typeof result === \"string\") {\n    result = { message: result };\n  }\n  const { path, branch } = context;\n  const { type } = struct;\n  const { refinement, message = `Expected a value of type \\`${type}\\`${refinement ? ` with refinement \\`${refinement}\\`` : \"\"}, but received: \\`${print(value)}\\`` } = result;\n  return {\n    value,\n    type,\n    refinement,\n    key: path[path.length - 1],\n    path,\n    branch,\n    ...result,\n    message\n  };\n}\nfunction* toFailures(result, context, struct, value) {\n  if (!isIterable(result)) {\n    result = [result];\n  }\n  for (const validationResult of result) {\n    const failure = toFailure(validationResult, context, struct, value);\n    if (failure) {\n      yield failure;\n    }\n  }\n}\nfunction* run(value, struct, options = {}) {\n  const { path = [], branch = [value], coerce = false, mask = false } = options;\n  const context = { path, branch };\n  if (coerce) {\n    value = struct.coercer(value, context);\n    if (mask && struct.type !== \"type\" && isObject(struct.schema) && isObject(value) && !Array.isArray(value)) {\n      for (const key in value) {\n        if (struct.schema[key] === undefined) {\n          delete value[key];\n        }\n      }\n    }\n  }\n  let status = \"valid\";\n  for (const failure of struct.validator(value, context)) {\n    failure.explanation = options.message;\n    status = \"not_valid\";\n    yield [failure, undefined];\n  }\n  for (let [innerKey, innerValue, innerStruct] of struct.entries(value, context)) {\n    const iterable = run(innerValue, innerStruct, {\n      path: innerKey === undefined ? path : [...path, innerKey],\n      branch: innerKey === undefined ? branch : [...branch, innerValue],\n      coerce,\n      mask,\n      message: options.message\n    });\n    for (const result of iterable) {\n      if (result[0]) {\n        status = result[0].refinement === null || result[0].refinement === undefined ? \"not_valid\" : \"not_refined\";\n        yield [result[0], undefined];\n      } else if (coerce) {\n        innerValue = result[1];\n        if (innerKey === undefined) {\n          value = innerValue;\n        } else if (value instanceof Map) {\n          value.set(innerKey, innerValue);\n        } else if (value instanceof Set) {\n          value.add(innerValue);\n        } else if (isObject(value)) {\n          if (innerValue !== undefined || innerKey in value) {\n            value[innerKey] = innerValue;\n          }\n        }\n      }\n    }\n  }\n  if (status !== \"not_valid\") {\n    for (const failure of struct.refiner(value, context)) {\n      failure.explanation = options.message;\n      status = \"not_refined\";\n      yield [failure, undefined];\n    }\n  }\n  if (status === \"valid\") {\n    yield [undefined, value];\n  }\n}\n\n// node_modules/@metamask/superstruct/dist/struct.mjs\nclass Struct {\n  constructor(props) {\n    const { type, schema, validator, refiner, coercer = (value) => value, entries = function* () {} } = props;\n    this.type = type;\n    this.schema = schema;\n    this.entries = entries;\n    this.coercer = coercer;\n    if (validator) {\n      this.validator = (value, context) => {\n        const result = validator(value, context);\n        return toFailures(result, context, this, value);\n      };\n    } else {\n      this.validator = () => [];\n    }\n    if (refiner) {\n      this.refiner = (value, context) => {\n        const result = refiner(value, context);\n        return toFailures(result, context, this, value);\n      };\n    } else {\n      this.refiner = () => [];\n    }\n  }\n  assert(value, message) {\n    return assert(value, this, message);\n  }\n  create(value, message) {\n    return create(value, this, message);\n  }\n  is(value) {\n    return is(value, this);\n  }\n  mask(value, message) {\n    return mask(value, this, message);\n  }\n  validate(value, options = {}) {\n    return validate(value, this, options);\n  }\n}\nvar ExactOptionalBrand = \"EXACT_OPTIONAL\";\n\nclass ExactOptionalStruct extends Struct {\n  constructor(props) {\n    super({\n      ...props,\n      type: `exact optional ${props.type}`\n    });\n    this.brand = ExactOptionalBrand;\n  }\n  static isExactOptional(value) {\n    return isObject(value) && \"brand\" in value && value.brand === ExactOptionalBrand;\n  }\n}\nfunction assert(value, struct, message) {\n  const result = validate(value, struct, { message });\n  if (result[0]) {\n    throw result[0];\n  }\n}\nfunction create(value, struct, message) {\n  const result = validate(value, struct, { coerce: true, message });\n  if (result[0]) {\n    throw result[0];\n  } else {\n    return result[1];\n  }\n}\nfunction mask(value, struct, message) {\n  const result = validate(value, struct, { coerce: true, mask: true, message });\n  if (result[0]) {\n    throw result[0];\n  } else {\n    return result[1];\n  }\n}\nfunction is(value, struct) {\n  const result = validate(value, struct);\n  return !result[0];\n}\nfunction validate(value, struct, options = {}) {\n  const tuples = run(value, struct, options);\n  const tuple = shiftIterator(tuples);\n  if (tuple[0]) {\n    const error = new StructError(tuple[0], function* () {\n      for (const innerTuple of tuples) {\n        if (innerTuple[0]) {\n          yield innerTuple[0];\n        }\n      }\n    });\n    return [error, undefined];\n  }\n  const validatedValue = tuple[1];\n  return [undefined, validatedValue];\n}\n\n// node_modules/@metamask/superstruct/dist/structs/utilities.mjs\nfunction define(name, validator) {\n  return new Struct({ type: name, schema: null, validator });\n}\n\n// node_modules/@metamask/superstruct/dist/structs/types.mjs\nfunction any() {\n  return define(\"any\", () => true);\n}\nfunction array(Element) {\n  return new Struct({\n    type: \"array\",\n    schema: Element,\n    *entries(value) {\n      if (Element && Array.isArray(value)) {\n        for (const [index, arrayValue] of value.entries()) {\n          yield [index, arrayValue, Element];\n        }\n      }\n    },\n    coercer(value) {\n      return Array.isArray(value) ? value.slice() : value;\n    },\n    validator(value) {\n      return Array.isArray(value) || `Expected an array value, but received: ${print(value)}`;\n    }\n  });\n}\nfunction integer() {\n  return define(\"integer\", (value) => {\n    return typeof value === \"number\" && !isNaN(value) && Number.isInteger(value) || `Expected an integer, but received: ${print(value)}`;\n  });\n}\nfunction literal(constant) {\n  const description = print(constant);\n  const valueType = typeof constant;\n  return new Struct({\n    type: \"literal\",\n    schema: valueType === \"string\" || valueType === \"number\" || valueType === \"boolean\" ? constant : null,\n    validator(value) {\n      return value === constant || `Expected the literal \\`${description}\\`, but received: ${print(value)}`;\n    }\n  });\n}\nfunction never() {\n  return define(\"never\", () => false);\n}\nfunction nullable(struct) {\n  return new Struct({\n    ...struct,\n    validator: (value, ctx) => value === null || struct.validator(value, ctx),\n    refiner: (value, ctx) => value === null || struct.refiner(value, ctx)\n  });\n}\nfunction number() {\n  return define(\"number\", (value) => {\n    return typeof value === \"number\" && !isNaN(value) || `Expected a number, but received: ${print(value)}`;\n  });\n}\nfunction object(schema) {\n  const knowns = schema ? Object.keys(schema) : [];\n  const Never = never();\n  return new Struct({\n    type: \"object\",\n    schema: schema ?? null,\n    *entries(value) {\n      if (schema && isObject(value)) {\n        const unknowns = new Set(Object.keys(value));\n        for (const key of knowns) {\n          unknowns.delete(key);\n          const propertySchema = schema[key];\n          if (ExactOptionalStruct.isExactOptional(propertySchema) && !Object.prototype.hasOwnProperty.call(value, key)) {\n            continue;\n          }\n          yield [key, value[key], schema[key]];\n        }\n        for (const key of unknowns) {\n          yield [key, value[key], Never];\n        }\n      }\n    },\n    validator(value) {\n      return isObject(value) || `Expected an object, but received: ${print(value)}`;\n    },\n    coercer(value) {\n      return isObject(value) ? { ...value } : value;\n    }\n  });\n}\nfunction optional(struct) {\n  return new Struct({\n    ...struct,\n    validator: (value, ctx) => value === undefined || struct.validator(value, ctx),\n    refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx)\n  });\n}\nfunction record(Key, Value) {\n  return new Struct({\n    type: \"record\",\n    schema: null,\n    *entries(value) {\n      if (isObject(value)) {\n        for (const objectKey in value) {\n          const objectValue = value[objectKey];\n          yield [objectKey, objectKey, Key];\n          yield [objectKey, objectValue, Value];\n        }\n      }\n    },\n    validator(value) {\n      return isObject(value) || `Expected an object, but received: ${print(value)}`;\n    }\n  });\n}\nfunction string() {\n  return define(\"string\", (value) => {\n    return typeof value === \"string\" || `Expected a string, but received: ${print(value)}`;\n  });\n}\nfunction union(Structs) {\n  const description = Structs.map((struct) => struct.type).join(\" | \");\n  return new Struct({\n    type: \"union\",\n    schema: null,\n    coercer(value) {\n      for (const InnerStruct of Structs) {\n        const [error, coerced] = InnerStruct.validate(value, { coerce: true });\n        if (!error) {\n          return coerced;\n        }\n      }\n      return value;\n    },\n    validator(value, ctx) {\n      const failures = [];\n      for (const InnerStruct of Structs) {\n        const [...tuples] = run(value, InnerStruct, ctx);\n        const [first] = tuples;\n        if (!first?.[0]) {\n          return [];\n        }\n        for (const [failure] of tuples) {\n          if (failure) {\n            failures.push(failure);\n          }\n        }\n      }\n      return [\n        `Expected the value to satisfy a union of \\`${description}\\`, but received: ${print(value)}`,\n        ...failures\n      ];\n    }\n  });\n}\nfunction unknown() {\n  return define(\"unknown\", () => true);\n}\n\n// node_modules/@metamask/superstruct/dist/structs/coercions.mjs\nfunction coerce(struct, condition, coercer) {\n  return new Struct({\n    ...struct,\n    coercer: (value, ctx) => {\n      return is(value, condition) ? struct.coercer(coercer(value, ctx), ctx) : struct.coercer(value, ctx);\n    }\n  });\n}\n\n// node_modules/@metamask/superstruct/dist/structs/refinements.mjs\nfunction refine(struct, name, refiner) {\n  return new Struct({\n    ...struct,\n    *refiner(value, ctx) {\n      yield* struct.refiner(value, ctx);\n      const result = refiner(value, ctx);\n      const failures = toFailures(result, ctx, struct, value);\n      for (const failure of failures) {\n        yield { ...failure, refinement: name };\n      }\n    }\n  });\n}\n\n// node_modules/@metamask/utils/dist/misc.mjs\nfunction isObject2(value) {\n  return Boolean(value) && typeof value === \"object\" && !Array.isArray(value);\n}\nvar hasProperty = (objectToCheck, name) => Object.hasOwnProperty.call(objectToCheck, name);\nvar JsonSize;\n(function(JsonSize2) {\n  JsonSize2[JsonSize2[\"Null\"] = 4] = \"Null\";\n  JsonSize2[JsonSize2[\"Comma\"] = 1] = \"Comma\";\n  JsonSize2[JsonSize2[\"Wrapper\"] = 1] = \"Wrapper\";\n  JsonSize2[JsonSize2[\"True\"] = 4] = \"True\";\n  JsonSize2[JsonSize2[\"False\"] = 5] = \"False\";\n  JsonSize2[JsonSize2[\"Quote\"] = 1] = \"Quote\";\n  JsonSize2[JsonSize2[\"Colon\"] = 1] = \"Colon\";\n  JsonSize2[JsonSize2[\"Date\"] = 24] = \"Date\";\n})(JsonSize = JsonSize || (JsonSize = {}));\nfunction isPlainObject(value) {\n  if (typeof value !== \"object\" || value === null) {\n    return false;\n  }\n  try {\n    let proto = value;\n    while (Object.getPrototypeOf(proto) !== null) {\n      proto = Object.getPrototypeOf(proto);\n    }\n    return Object.getPrototypeOf(value) === proto;\n  } catch (_) {\n    return false;\n  }\n}\n\n// node_modules/@metamask/utils/dist/json.mjs\nvar object2 = (schema) => object(schema);\nfunction hasOptional({ path, branch }) {\n  const field = path[path.length - 1];\n  return hasProperty(branch[branch.length - 2], field);\n}\nfunction exactOptional(struct) {\n  return new Struct({\n    ...struct,\n    type: `optional ${struct.type}`,\n    validator: (value, context) => !hasOptional(context) || struct.validator(value, context),\n    refiner: (value, context) => !hasOptional(context) || struct.refiner(value, context)\n  });\n}\nfunction validateJson(json) {\n  if (json === null || typeof json === \"boolean\" || typeof json === \"string\") {\n    return true;\n  }\n  if (typeof json === \"number\" && Number.isFinite(json)) {\n    return true;\n  }\n  if (typeof json === \"object\") {\n    let every = true;\n    if (Array.isArray(json)) {\n      for (let i = 0;i < json.length; i++) {\n        if (!validateJson(json[i])) {\n          every = false;\n          break;\n        }\n      }\n      return every;\n    }\n    const entries = Object.entries(json);\n    for (let i = 0;i < entries.length; i++) {\n      if (typeof entries[i][0] !== \"string\" || !validateJson(entries[i][1])) {\n        every = false;\n        break;\n      }\n    }\n    return every;\n  }\n  return false;\n}\nvar UnsafeJsonStruct = define(\"JSON\", (json) => validateJson(json));\nvar JsonStruct = coerce(UnsafeJsonStruct, refine(any(), \"JSON\", (value) => is(value, UnsafeJsonStruct)), (value) => JSON.parse(JSON.stringify(value, (propKey, propValue) => {\n  if (propKey === \"__proto__\" || propKey === \"constructor\") {\n    return;\n  }\n  return propValue;\n})));\nfunction isValidJson(value) {\n  try {\n    getSafeJson(value);\n    return true;\n  } catch {\n    return false;\n  }\n}\nfunction getSafeJson(value) {\n  return create(value, JsonStruct);\n}\nvar jsonrpc2 = \"2.0\";\nvar JsonRpcVersionStruct = literal(jsonrpc2);\nvar JsonRpcIdStruct = nullable(union([number(), string()]));\nvar JsonRpcErrorStruct = object2({\n  code: integer(),\n  message: string(),\n  data: exactOptional(JsonStruct),\n  stack: exactOptional(string())\n});\nvar JsonRpcParamsStruct = union([record(string(), JsonStruct), array(JsonStruct)]);\nvar JsonRpcRequestStruct = object2({\n  id: JsonRpcIdStruct,\n  jsonrpc: JsonRpcVersionStruct,\n  method: string(),\n  params: exactOptional(JsonRpcParamsStruct)\n});\nvar JsonRpcNotificationStruct = object2({\n  jsonrpc: JsonRpcVersionStruct,\n  method: string(),\n  params: exactOptional(JsonRpcParamsStruct)\n});\nvar PendingJsonRpcResponseStruct = object({\n  id: JsonRpcIdStruct,\n  jsonrpc: JsonRpcVersionStruct,\n  result: optional(unknown()),\n  error: optional(JsonRpcErrorStruct)\n});\nvar JsonRpcSuccessStruct = object2({\n  id: JsonRpcIdStruct,\n  jsonrpc: JsonRpcVersionStruct,\n  result: JsonStruct\n});\nvar JsonRpcFailureStruct = object2({\n  id: JsonRpcIdStruct,\n  jsonrpc: JsonRpcVersionStruct,\n  error: JsonRpcErrorStruct\n});\nvar JsonRpcResponseStruct = union([\n  JsonRpcSuccessStruct,\n  JsonRpcFailureStruct\n]);\nfunction isJsonRpcError(value) {\n  return is(value, JsonRpcErrorStruct);\n}\n\n// node_modules/@metamask/rpc-errors/dist/classes.mjs\nvar import_fast_safe_stringify = __toESM(require_fast_safe_stringify(), 1);\n\n// node_modules/@metamask/rpc-errors/dist/error-constants.mjs\nvar errorCodes = {\n  rpc: {\n    invalidInput: -32000,\n    resourceNotFound: -32001,\n    resourceUnavailable: -32002,\n    transactionRejected: -32003,\n    methodNotSupported: -32004,\n    limitExceeded: -32005,\n    parse: -32700,\n    invalidRequest: -32600,\n    methodNotFound: -32601,\n    invalidParams: -32602,\n    internal: -32603\n  },\n  provider: {\n    userRejectedRequest: 4001,\n    unauthorized: 4100,\n    unsupportedMethod: 4200,\n    disconnected: 4900,\n    chainDisconnected: 4901\n  }\n};\nvar errorValues = {\n  \"-32700\": {\n    standard: \"JSON RPC 2.0\",\n    message: \"Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text.\"\n  },\n  \"-32600\": {\n    standard: \"JSON RPC 2.0\",\n    message: \"The JSON sent is not a valid Request object.\"\n  },\n  \"-32601\": {\n    standard: \"JSON RPC 2.0\",\n    message: \"The method does not exist / is not available.\"\n  },\n  \"-32602\": {\n    standard: \"JSON RPC 2.0\",\n    message: \"Invalid method parameter(s).\"\n  },\n  \"-32603\": {\n    standard: \"JSON RPC 2.0\",\n    message: \"Internal JSON-RPC error.\"\n  },\n  \"-32000\": {\n    standard: \"EIP-1474\",\n    message: \"Invalid input.\"\n  },\n  \"-32001\": {\n    standard: \"EIP-1474\",\n    message: \"Resource not found.\"\n  },\n  \"-32002\": {\n    standard: \"EIP-1474\",\n    message: \"Resource unavailable.\"\n  },\n  \"-32003\": {\n    standard: \"EIP-1474\",\n    message: \"Transaction rejected.\"\n  },\n  \"-32004\": {\n    standard: \"EIP-1474\",\n    message: \"Method not supported.\"\n  },\n  \"-32005\": {\n    standard: \"EIP-1474\",\n    message: \"Request limit exceeded.\"\n  },\n  \"4001\": {\n    standard: \"EIP-1193\",\n    message: \"User rejected the request.\"\n  },\n  \"4100\": {\n    standard: \"EIP-1193\",\n    message: \"The requested account and/or method has not been authorized by the user.\"\n  },\n  \"4200\": {\n    standard: \"EIP-1193\",\n    message: \"The requested method is not supported by this Ethereum provider.\"\n  },\n  \"4900\": {\n    standard: \"EIP-1193\",\n    message: \"The provider is disconnected from all chains.\"\n  },\n  \"4901\": {\n    standard: \"EIP-1193\",\n    message: \"The provider is disconnected from the specified chain.\"\n  }\n};\n\n// node_modules/@metamask/rpc-errors/dist/utils.mjs\nvar FALLBACK_ERROR_CODE = errorCodes.rpc.internal;\nvar FALLBACK_MESSAGE = \"Unspecified error message. This is a bug, please report it.\";\nvar FALLBACK_ERROR = {\n  code: FALLBACK_ERROR_CODE,\n  message: getMessageFromCode(FALLBACK_ERROR_CODE)\n};\nvar JSON_RPC_SERVER_ERROR_MESSAGE = \"Unspecified server error.\";\nfunction getMessageFromCode(code, fallbackMessage = FALLBACK_MESSAGE) {\n  if (isValidCode(code)) {\n    const codeString = code.toString();\n    if (hasProperty(errorValues, codeString)) {\n      return errorValues[codeString].message;\n    }\n    if (isJsonRpcServerError(code)) {\n      return JSON_RPC_SERVER_ERROR_MESSAGE;\n    }\n  }\n  return fallbackMessage;\n}\nfunction isValidCode(code) {\n  return Number.isInteger(code);\n}\nfunction serializeError(error, { fallbackError = FALLBACK_ERROR, shouldIncludeStack = true, shouldPreserveMessage = true } = {}) {\n  if (!isJsonRpcError(fallbackError)) {\n    throw new Error(\"Must provide fallback error with integer number code and string message.\");\n  }\n  const serialized = buildError(error, fallbackError, shouldPreserveMessage);\n  if (!shouldIncludeStack) {\n    delete serialized.stack;\n  }\n  return serialized;\n}\nfunction buildError(error, fallbackError, shouldPreserveMessage) {\n  if (error && typeof error === \"object\" && \"serialize\" in error && typeof error.serialize === \"function\") {\n    return error.serialize();\n  }\n  if (isJsonRpcError(error)) {\n    return error;\n  }\n  const originalMessage = getOriginalMessage(error);\n  const cause = serializeCause(error);\n  const fallbackWithCause = {\n    ...fallbackError,\n    ...shouldPreserveMessage && originalMessage && { message: originalMessage },\n    data: { cause }\n  };\n  return fallbackWithCause;\n}\nfunction getOriginalMessage(error) {\n  if (isObject2(error) && hasProperty(error, \"message\") && typeof error.message === \"string\" && error.message.length > 0) {\n    return error.message;\n  }\n  return;\n}\nfunction isJsonRpcServerError(code) {\n  return code >= -32099 && code <= -32000;\n}\nfunction serializeCause(error) {\n  if (Array.isArray(error)) {\n    return error.map((entry) => {\n      if (isValidJson(entry)) {\n        return entry;\n      } else if (isObject2(entry)) {\n        return serializeObject(entry);\n      }\n      return null;\n    });\n  } else if (isObject2(error)) {\n    return serializeObject(error);\n  }\n  if (isValidJson(error)) {\n    return error;\n  }\n  return null;\n}\nfunction serializeObject(object3) {\n  return Object.getOwnPropertyNames(object3).reduce((acc, key) => {\n    const value = object3[key];\n    if (isValidJson(value)) {\n      acc[key] = value;\n    }\n    return acc;\n  }, {});\n}\nfunction dataHasCause(data) {\n  return isObject2(data) && hasProperty(data, \"cause\") && isObject2(data.cause);\n}\n\n// node_modules/@metamask/rpc-errors/dist/classes.mjs\nfunction $importDefault(module) {\n  if (module?.__esModule) {\n    return module.default;\n  }\n  return module;\n}\nvar safeStringify = $importDefault(import_fast_safe_stringify.default);\n\nclass JsonRpcError extends Error {\n  constructor(code, message, data) {\n    if (!Number.isInteger(code)) {\n      throw new Error('\"code\" must be an integer.');\n    }\n    if (!message || typeof message !== \"string\") {\n      throw new Error('\"message\" must be a non-empty string.');\n    }\n    if (dataHasCause(data)) {\n      super(message, { cause: data.cause });\n      if (!hasProperty(this, \"cause\")) {\n        Object.assign(this, { cause: data.cause });\n      }\n    } else {\n      super(message);\n    }\n    if (data !== undefined) {\n      this.data = data;\n    }\n    this.code = code;\n  }\n  serialize() {\n    const serialized = {\n      code: this.code,\n      message: this.message\n    };\n    if (this.data !== undefined) {\n      serialized.data = this.data;\n      if (isPlainObject(this.data)) {\n        serialized.data.cause = serializeCause(this.data.cause);\n      }\n    }\n    if (this.stack) {\n      serialized.stack = this.stack;\n    }\n    return serialized;\n  }\n  toString() {\n    return safeStringify(this.serialize(), stringifyReplacer, 2);\n  }\n}\n\nclass EthereumProviderError extends JsonRpcError {\n  constructor(code, message, data) {\n    if (!isValidEthProviderCode(code)) {\n      throw new Error('\"code\" must be an integer such that: 1000 <= code <= 4999');\n    }\n    super(code, message, data);\n  }\n}\nfunction isValidEthProviderCode(code) {\n  return Number.isInteger(code) && code >= 1000 && code <= 4999;\n}\nfunction stringifyReplacer(_, value) {\n  if (value === \"[Circular]\") {\n    return;\n  }\n  return value;\n}\n// node_modules/@metamask/rpc-errors/dist/errors.mjs\nvar rpcErrors = {\n  parse: (arg) => getJsonRpcError(errorCodes.rpc.parse, arg),\n  invalidRequest: (arg) => getJsonRpcError(errorCodes.rpc.invalidRequest, arg),\n  invalidParams: (arg) => getJsonRpcError(errorCodes.rpc.invalidParams, arg),\n  methodNotFound: (arg) => getJsonRpcError(errorCodes.rpc.methodNotFound, arg),\n  internal: (arg) => getJsonRpcError(errorCodes.rpc.internal, arg),\n  server: (opts) => {\n    if (!opts || typeof opts !== \"object\" || Array.isArray(opts)) {\n      throw new Error(\"Ethereum RPC Server errors must provide single object argument.\");\n    }\n    const { code } = opts;\n    if (!Number.isInteger(code) || code > -32005 || code < -32099) {\n      throw new Error('\"code\" must be an integer such that: -32099 <= code <= -32005');\n    }\n    return getJsonRpcError(code, opts);\n  },\n  invalidInput: (arg) => getJsonRpcError(errorCodes.rpc.invalidInput, arg),\n  resourceNotFound: (arg) => getJsonRpcError(errorCodes.rpc.resourceNotFound, arg),\n  resourceUnavailable: (arg) => getJsonRpcError(errorCodes.rpc.resourceUnavailable, arg),\n  transactionRejected: (arg) => getJsonRpcError(errorCodes.rpc.transactionRejected, arg),\n  methodNotSupported: (arg) => getJsonRpcError(errorCodes.rpc.methodNotSupported, arg),\n  limitExceeded: (arg) => getJsonRpcError(errorCodes.rpc.limitExceeded, arg)\n};\nvar providerErrors = {\n  userRejectedRequest: (arg) => {\n    return getEthProviderError(errorCodes.provider.userRejectedRequest, arg);\n  },\n  unauthorized: (arg) => {\n    return getEthProviderError(errorCodes.provider.unauthorized, arg);\n  },\n  unsupportedMethod: (arg) => {\n    return getEthProviderError(errorCodes.provider.unsupportedMethod, arg);\n  },\n  disconnected: (arg) => {\n    return getEthProviderError(errorCodes.provider.disconnected, arg);\n  },\n  chainDisconnected: (arg) => {\n    return getEthProviderError(errorCodes.provider.chainDisconnected, arg);\n  },\n  custom: (opts) => {\n    if (!opts || typeof opts !== \"object\" || Array.isArray(opts)) {\n      throw new Error(\"Ethereum Provider custom errors must provide single object argument.\");\n    }\n    const { code, message, data } = opts;\n    if (!message || typeof message !== \"string\") {\n      throw new Error('\"message\" must be a nonempty string');\n    }\n    return new EthereumProviderError(code, message, data);\n  }\n};\nfunction getJsonRpcError(code, arg) {\n  const [message, data] = parseOpts(arg);\n  return new JsonRpcError(code, message ?? getMessageFromCode(code), data);\n}\nfunction getEthProviderError(code, arg) {\n  const [message, data] = parseOpts(arg);\n  return new EthereumProviderError(code, message ?? getMessageFromCode(code), data);\n}\nfunction parseOpts(arg) {\n  if (arg) {\n    if (typeof arg === \"string\") {\n      return [arg];\n    } else if (typeof arg === \"object\" && !Array.isArray(arg)) {\n      const { message, data } = arg;\n      if (message && typeof message !== \"string\") {\n        throw new Error(\"Must specify string message.\");\n      }\n      return [message ?? undefined, data];\n    }\n  }\n  return [];\n}\n// node_modules/eventemitter3/index.mjs\nvar import__ = __toESM(require_eventemitter3(), 1);\n\n// src/types.ts\nvar GeminiSdkEvent;\n((GeminiSdkEvent2) => {\n  GeminiSdkEvent2[\"POPUP_LOADED\"] = \"POPUP_LOADED\";\n  GeminiSdkEvent2[\"POPUP_UNLOADED\"] = \"POPUP_UNLOADED\";\n  GeminiSdkEvent2[\"POPUP_APP_CONTEXT\"] = \"POPUP_APP_CONTEXT\";\n  GeminiSdkEvent2[\"SDK_CONNECT\"] = \"SDK_CONNECT\";\n  GeminiSdkEvent2[\"SDK_DISCONNECT\"] = \"SDK_DISCONNECT\";\n  GeminiSdkEvent2[\"SDK_SEND_TRANSACTION\"] = \"SDK_SEND_TRANSACTION\";\n  GeminiSdkEvent2[\"SDK_SIGN_DATA\"] = \"SDK_SIGN_DATA\";\n  GeminiSdkEvent2[\"SDK_SIGN_TYPED_DATA\"] = \"SDK_SIGN_TYPED_DATA\";\n  GeminiSdkEvent2[\"SDK_SWITCH_CHAIN\"] = \"SDK_SWITCH_CHAIN\";\n  GeminiSdkEvent2[\"SDK_OPEN_SETTINGS\"] = \"SDK_OPEN_SETTINGS\";\n})(GeminiSdkEvent ||= {});\nclass ProviderEventEmitter extends import__.default {\n}\n\n// src/utils/base64.ts\nfunction encodeBase64(array2) {\n  let base64;\n  if (typeof Buffer !== \"undefined\") {\n    base64 = Buffer.from(array2).toString(\"base64\");\n  } else {\n    base64 = btoa(Array.from(array2).map((b) => String.fromCharCode(b)).join(\"\"));\n  }\n  return base64.replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=+$/, \"\");\n}\nfunction decodeBase64(base64url) {\n  let base64 = base64url.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  while (base64.length % 4 !== 0) {\n    base64 += \"=\";\n  }\n  if (typeof Buffer !== \"undefined\") {\n    return new Uint8Array(Buffer.from(base64, \"base64\"));\n  }\n  const binaryString = atob(base64);\n  const bytes = new Uint8Array(binaryString.length);\n  for (let i = 0;i < binaryString.length; i++) {\n    bytes[i] = binaryString.charCodeAt(i);\n  }\n  return bytes;\n}\nfunction bufferToBase64URLString(buffer) {\n  const bytes = buffer instanceof Uint8Array ? buffer : new Uint8Array(buffer);\n  return encodeBase64(bytes);\n}\nfunction utf8StringToBuffer(value) {\n  if (typeof TextEncoder !== \"undefined\") {\n    return new TextEncoder().encode(value);\n  }\n  if (typeof Buffer !== \"undefined\") {\n    return new Uint8Array(Buffer.from(value, \"utf8\"));\n  }\n  const bytes = new Uint8Array(value.length);\n  for (let i = 0;i < value.length; i++) {\n    bytes[i] = value.charCodeAt(i);\n  }\n  return bytes;\n}\nfunction base64ToHex(base64) {\n  const bytes = decodeBase64(base64);\n  return Array.from(bytes).map((b) => b.toString(16).padStart(2, \"0\")).join(\"\");\n}\n// node_modules/viem/_esm/utils/encoding/toRlp.js\ninit_base();\ninit_cursor2();\ninit_toBytes();\ninit_toHex();\nfunction toRlp(bytes, to = \"hex\") {\n  const encodable = getEncodable(bytes);\n  const cursor = createCursor(new Uint8Array(encodable.length));\n  encodable.encode(cursor);\n  if (to === \"hex\")\n    return bytesToHex(cursor.bytes);\n  return cursor.bytes;\n}\nfunction getEncodable(bytes) {\n  if (Array.isArray(bytes))\n    return getEncodableList(bytes.map((x) => getEncodable(x)));\n  return getEncodableBytes(bytes);\n}\nfunction getEncodableList(list) {\n  const bodyLength = list.reduce((acc, x) => acc + x.length, 0);\n  const sizeOfBodyLength = getSizeOfLength(bodyLength);\n  const length = (() => {\n    if (bodyLength <= 55)\n      return 1 + bodyLength;\n    return 1 + sizeOfBodyLength + bodyLength;\n  })();\n  return {\n    length,\n    encode(cursor) {\n      if (bodyLength <= 55) {\n        cursor.pushByte(192 + bodyLength);\n      } else {\n        cursor.pushByte(192 + 55 + sizeOfBodyLength);\n        if (sizeOfBodyLength === 1)\n          cursor.pushUint8(bodyLength);\n        else if (sizeOfBodyLength === 2)\n          cursor.pushUint16(bodyLength);\n        else if (sizeOfBodyLength === 3)\n          cursor.pushUint24(bodyLength);\n        else\n          cursor.pushUint32(bodyLength);\n      }\n      for (const { encode } of list) {\n        encode(cursor);\n      }\n    }\n  };\n}\nfunction getEncodableBytes(bytesOrHex) {\n  const bytes = typeof bytesOrHex === \"string\" ? hexToBytes(bytesOrHex) : bytesOrHex;\n  const sizeOfBytesLength = getSizeOfLength(bytes.length);\n  const length = (() => {\n    if (bytes.length === 1 && bytes[0] < 128)\n      return 1;\n    if (bytes.length <= 55)\n      return 1 + bytes.length;\n    return 1 + sizeOfBytesLength + bytes.length;\n  })();\n  return {\n    length,\n    encode(cursor) {\n      if (bytes.length === 1 && bytes[0] < 128) {\n        cursor.pushBytes(bytes);\n      } else if (bytes.length <= 55) {\n        cursor.pushByte(128 + bytes.length);\n        cursor.pushBytes(bytes);\n      } else {\n        cursor.pushByte(128 + 55 + sizeOfBytesLength);\n        if (sizeOfBytesLength === 1)\n          cursor.pushUint8(bytes.length);\n        else if (sizeOfBytesLength === 2)\n          cursor.pushUint16(bytes.length);\n        else if (sizeOfBytesLength === 3)\n          cursor.pushUint24(bytes.length);\n        else\n          cursor.pushUint32(bytes.length);\n        cursor.pushBytes(bytes);\n      }\n    }\n  };\n}\nfunction getSizeOfLength(length) {\n  if (length < 2 ** 8)\n    return 1;\n  if (length < 2 ** 16)\n    return 2;\n  if (length < 2 ** 24)\n    return 3;\n  if (length < 2 ** 32)\n    return 4;\n  throw new BaseError(\"Length is too large.\");\n}\n// node_modules/viem/_esm/utils/formatters/transaction.js\ninit_fromHex();\nvar transactionType = {\n  \"0x0\": \"legacy\",\n  \"0x1\": \"eip2930\",\n  \"0x2\": \"eip1559\",\n  \"0x3\": \"eip4844\",\n  \"0x4\": \"eip7702\"\n};\nfunction formatTransaction(transaction) {\n  const transaction_ = {\n    ...transaction,\n    blockHash: transaction.blockHash ? transaction.blockHash : null,\n    blockNumber: transaction.blockNumber ? BigInt(transaction.blockNumber) : null,\n    chainId: transaction.chainId ? hexToNumber(transaction.chainId) : undefined,\n    gas: transaction.gas ? BigInt(transaction.gas) : undefined,\n    gasPrice: transaction.gasPrice ? BigInt(transaction.gasPrice) : undefined,\n    maxFeePerBlobGas: transaction.maxFeePerBlobGas ? BigInt(transaction.maxFeePerBlobGas) : undefined,\n    maxFeePerGas: transaction.maxFeePerGas ? BigInt(transaction.maxFeePerGas) : undefined,\n    maxPriorityFeePerGas: transaction.maxPriorityFeePerGas ? BigInt(transaction.maxPriorityFeePerGas) : undefined,\n    nonce: transaction.nonce ? hexToNumber(transaction.nonce) : undefined,\n    to: transaction.to ? transaction.to : null,\n    transactionIndex: transaction.transactionIndex ? Number(transaction.transactionIndex) : null,\n    type: transaction.type ? transactionType[transaction.type] : undefined,\n    typeHex: transaction.type ? transaction.type : undefined,\n    value: transaction.value ? BigInt(transaction.value) : undefined,\n    v: transaction.v ? BigInt(transaction.v) : undefined\n  };\n  if (transaction.authorizationList)\n    transaction_.authorizationList = formatAuthorizationList(transaction.authorizationList);\n  transaction_.yParity = (() => {\n    if (transaction.yParity)\n      return Number(transaction.yParity);\n    if (typeof transaction_.v === \"bigint\") {\n      if (transaction_.v === 0n || transaction_.v === 27n)\n        return 0;\n      if (transaction_.v === 1n || transaction_.v === 28n)\n        return 1;\n      if (transaction_.v >= 35n)\n        return transaction_.v % 2n === 0n ? 1 : 0;\n    }\n    return;\n  })();\n  if (transaction_.type === \"legacy\") {\n    delete transaction_.accessList;\n    delete transaction_.maxFeePerBlobGas;\n    delete transaction_.maxFeePerGas;\n    delete transaction_.maxPriorityFeePerGas;\n    delete transaction_.yParity;\n  }\n  if (transaction_.type === \"eip2930\") {\n    delete transaction_.maxFeePerBlobGas;\n    delete transaction_.maxFeePerGas;\n    delete transaction_.maxPriorityFeePerGas;\n  }\n  if (transaction_.type === \"eip1559\") {\n    delete transaction_.maxFeePerBlobGas;\n  }\n  return transaction_;\n}\nvar defineTransaction = /* @__PURE__ */ defineFormatter(\"transaction\", formatTransaction);\nfunction formatAuthorizationList(authorizationList) {\n  return authorizationList.map((authorization) => ({\n    address: authorization.address,\n    chainId: Number(authorization.chainId),\n    nonce: Number(authorization.nonce),\n    r: authorization.r,\n    s: authorization.s,\n    yParity: Number(authorization.yParity)\n  }));\n}\n\n// node_modules/viem/_esm/utils/formatters/block.js\nfunction formatBlock(block) {\n  const transactions = (block.transactions ?? []).map((transaction) => {\n    if (typeof transaction === \"string\")\n      return transaction;\n    return formatTransaction(transaction);\n  });\n  return {\n    ...block,\n    baseFeePerGas: block.baseFeePerGas ? BigInt(block.baseFeePerGas) : null,\n    blobGasUsed: block.blobGasUsed ? BigInt(block.blobGasUsed) : undefined,\n    difficulty: block.difficulty ? BigInt(block.difficulty) : undefined,\n    excessBlobGas: block.excessBlobGas ? BigInt(block.excessBlobGas) : undefined,\n    gasLimit: block.gasLimit ? BigInt(block.gasLimit) : undefined,\n    gasUsed: block.gasUsed ? BigInt(block.gasUsed) : undefined,\n    hash: block.hash ? block.hash : null,\n    logsBloom: block.logsBloom ? block.logsBloom : null,\n    nonce: block.nonce ? block.nonce : null,\n    number: block.number ? BigInt(block.number) : null,\n    size: block.size ? BigInt(block.size) : undefined,\n    timestamp: block.timestamp ? BigInt(block.timestamp) : undefined,\n    transactions,\n    totalDifficulty: block.totalDifficulty ? BigInt(block.totalDifficulty) : null\n  };\n}\nvar defineBlock = /* @__PURE__ */ defineFormatter(\"block\", formatBlock);\n\n// node_modules/viem/_esm/utils/blob/blobsToCommitments.js\ninit_toBytes();\ninit_toHex();\nfunction blobsToCommitments(parameters) {\n  const { kzg } = parameters;\n  const to = parameters.to ?? (typeof parameters.blobs[0] === \"string\" ? \"hex\" : \"bytes\");\n  const blobs = typeof parameters.blobs[0] === \"string\" ? parameters.blobs.map((x) => hexToBytes(x)) : parameters.blobs;\n  const commitments = [];\n  for (const blob of blobs)\n    commitments.push(Uint8Array.from(kzg.blobToKzgCommitment(blob)));\n  return to === \"bytes\" ? commitments : commitments.map((x) => bytesToHex(x));\n}\n\n// node_modules/viem/_esm/utils/blob/blobsToProofs.js\ninit_toBytes();\ninit_toHex();\nfunction blobsToProofs(parameters) {\n  const { kzg } = parameters;\n  const to = parameters.to ?? (typeof parameters.blobs[0] === \"string\" ? \"hex\" : \"bytes\");\n  const blobs = typeof parameters.blobs[0] === \"string\" ? parameters.blobs.map((x) => hexToBytes(x)) : parameters.blobs;\n  const commitments = typeof parameters.commitments[0] === \"string\" ? parameters.commitments.map((x) => hexToBytes(x)) : parameters.commitments;\n  const proofs = [];\n  for (let i = 0;i < blobs.length; i++) {\n    const blob = blobs[i];\n    const commitment = commitments[i];\n    proofs.push(Uint8Array.from(kzg.computeBlobKzgProof(blob, commitment)));\n  }\n  return to === \"bytes\" ? proofs : proofs.map((x) => bytesToHex(x));\n}\n\n// node_modules/viem/_esm/utils/blob/commitmentToVersionedHash.js\ninit_toHex();\n\n// node_modules/@noble/hashes/esm/sha256.js\ninit_sha2();\nvar sha2562 = sha256;\n\n// node_modules/viem/_esm/utils/hash/sha256.js\ninit_toBytes();\ninit_toHex();\nfunction sha2563(value, to_) {\n  const to = to_ || \"hex\";\n  const bytes = sha2562(isHex(value, { strict: false }) ? toBytes2(value) : value);\n  if (to === \"bytes\")\n    return bytes;\n  return toHex(bytes);\n}\n\n// node_modules/viem/_esm/utils/blob/commitmentToVersionedHash.js\nfunction commitmentToVersionedHash(parameters) {\n  const { commitment, version: version2 = 1 } = parameters;\n  const to = parameters.to ?? (typeof commitment === \"string\" ? \"hex\" : \"bytes\");\n  const versionedHash = sha2563(commitment, \"bytes\");\n  versionedHash.set([version2], 0);\n  return to === \"bytes\" ? versionedHash : bytesToHex(versionedHash);\n}\n\n// node_modules/viem/_esm/utils/blob/commitmentsToVersionedHashes.js\nfunction commitmentsToVersionedHashes(parameters) {\n  const { commitments, version: version2 } = parameters;\n  const to = parameters.to ?? (typeof commitments[0] === \"string\" ? \"hex\" : \"bytes\");\n  const hashes = [];\n  for (const commitment of commitments) {\n    hashes.push(commitmentToVersionedHash({\n      commitment,\n      to,\n      version: version2\n    }));\n  }\n  return hashes;\n}\n\n// node_modules/viem/_esm/constants/blob.js\nvar blobsPerTransaction = 6;\nvar bytesPerFieldElement = 32;\nvar fieldElementsPerBlob = 4096;\nvar bytesPerBlob = bytesPerFieldElement * fieldElementsPerBlob;\nvar maxBytesPerTransaction = bytesPerBlob * blobsPerTransaction - 1 - 1 * fieldElementsPerBlob * blobsPerTransaction;\n\n// node_modules/viem/_esm/constants/kzg.js\nvar versionedHashVersionKzg = 1;\n\n// node_modules/viem/_esm/errors/blob.js\ninit_base();\n\nclass BlobSizeTooLargeError extends BaseError {\n  constructor({ maxSize, size: size2 }) {\n    super(\"Blob size is too large.\", {\n      metaMessages: [`Max: ${maxSize} bytes`, `Given: ${size2} bytes`],\n      name: \"BlobSizeTooLargeError\"\n    });\n  }\n}\n\nclass EmptyBlobError extends BaseError {\n  constructor() {\n    super(\"Blob data must not be empty.\", { name: \"EmptyBlobError\" });\n  }\n}\n\nclass InvalidVersionedHashSizeError extends BaseError {\n  constructor({ hash: hash2, size: size2 }) {\n    super(`Versioned hash \"${hash2}\" size is invalid.`, {\n      metaMessages: [\"Expected: 32\", `Received: ${size2}`],\n      name: \"InvalidVersionedHashSizeError\"\n    });\n  }\n}\n\nclass InvalidVersionedHashVersionError extends BaseError {\n  constructor({ hash: hash2, version: version2 }) {\n    super(`Versioned hash \"${hash2}\" version is invalid.`, {\n      metaMessages: [\n        `Expected: ${versionedHashVersionKzg}`,\n        `Received: ${version2}`\n      ],\n      name: \"InvalidVersionedHashVersionError\"\n    });\n  }\n}\n\n// node_modules/viem/_esm/utils/blob/toBlobs.js\ninit_cursor2();\ninit_size();\ninit_toBytes();\ninit_toHex();\nfunction toBlobs(parameters) {\n  const to = parameters.to ?? (typeof parameters.data === \"string\" ? \"hex\" : \"bytes\");\n  const data = typeof parameters.data === \"string\" ? hexToBytes(parameters.data) : parameters.data;\n  const size_ = size(data);\n  if (!size_)\n    throw new EmptyBlobError;\n  if (size_ > maxBytesPerTransaction)\n    throw new BlobSizeTooLargeError({\n      maxSize: maxBytesPerTransaction,\n      size: size_\n    });\n  const blobs = [];\n  let active = true;\n  let position = 0;\n  while (active) {\n    const blob = createCursor(new Uint8Array(bytesPerBlob));\n    let size2 = 0;\n    while (size2 < fieldElementsPerBlob) {\n      const bytes = data.slice(position, position + (bytesPerFieldElement - 1));\n      blob.pushByte(0);\n      blob.pushBytes(bytes);\n      if (bytes.length < 31) {\n        blob.pushByte(128);\n        active = false;\n        break;\n      }\n      size2++;\n      position += 31;\n    }\n    blobs.push(blob);\n  }\n  return to === \"bytes\" ? blobs.map((x) => x.bytes) : blobs.map((x) => bytesToHex(x.bytes));\n}\n\n// node_modules/viem/_esm/utils/blob/toBlobSidecars.js\nfunction toBlobSidecars(parameters) {\n  const { data, kzg, to } = parameters;\n  const blobs = parameters.blobs ?? toBlobs({ data, to });\n  const commitments = parameters.commitments ?? blobsToCommitments({ blobs, kzg, to });\n  const proofs = parameters.proofs ?? blobsToProofs({ blobs, commitments, kzg, to });\n  const sidecars = [];\n  for (let i = 0;i < blobs.length; i++)\n    sidecars.push({\n      blob: blobs[i],\n      commitment: commitments[i],\n      proof: proofs[i]\n    });\n  return sidecars;\n}\n\n// node_modules/viem/_esm/utils/transaction/getTransactionType.js\ninit_transaction();\nfunction getTransactionType(transaction) {\n  if (transaction.type)\n    return transaction.type;\n  if (typeof transaction.authorizationList !== \"undefined\")\n    return \"eip7702\";\n  if (typeof transaction.blobs !== \"undefined\" || typeof transaction.blobVersionedHashes !== \"undefined\" || typeof transaction.maxFeePerBlobGas !== \"undefined\" || typeof transaction.sidecars !== \"undefined\")\n    return \"eip4844\";\n  if (typeof transaction.maxFeePerGas !== \"undefined\" || typeof transaction.maxPriorityFeePerGas !== \"undefined\") {\n    return \"eip1559\";\n  }\n  if (typeof transaction.gasPrice !== \"undefined\") {\n    if (typeof transaction.accessList !== \"undefined\")\n      return \"eip2930\";\n    return \"legacy\";\n  }\n  throw new InvalidSerializableTransactionError({ transaction });\n}\n\n// node_modules/viem/_esm/utils/formatters/log.js\nfunction formatLog(log, { args, eventName } = {}) {\n  return {\n    ...log,\n    blockHash: log.blockHash ? log.blockHash : null,\n    blockNumber: log.blockNumber ? BigInt(log.blockNumber) : null,\n    logIndex: log.logIndex ? Number(log.logIndex) : null,\n    transactionHash: log.transactionHash ? log.transactionHash : null,\n    transactionIndex: log.transactionIndex ? Number(log.transactionIndex) : null,\n    ...eventName ? { args, eventName } : {}\n  };\n}\n\n// node_modules/viem/_esm/utils/formatters/transactionReceipt.js\ninit_fromHex();\nvar receiptStatuses = {\n  \"0x0\": \"reverted\",\n  \"0x1\": \"success\"\n};\nfunction formatTransactionReceipt(transactionReceipt) {\n  const receipt = {\n    ...transactionReceipt,\n    blockNumber: transactionReceipt.blockNumber ? BigInt(transactionReceipt.blockNumber) : null,\n    contractAddress: transactionReceipt.contractAddress ? transactionReceipt.contractAddress : null,\n    cumulativeGasUsed: transactionReceipt.cumulativeGasUsed ? BigInt(transactionReceipt.cumulativeGasUsed) : null,\n    effectiveGasPrice: transactionReceipt.effectiveGasPrice ? BigInt(transactionReceipt.effectiveGasPrice) : null,\n    gasUsed: transactionReceipt.gasUsed ? BigInt(transactionReceipt.gasUsed) : null,\n    logs: transactionReceipt.logs ? transactionReceipt.logs.map((log) => formatLog(log)) : null,\n    to: transactionReceipt.to ? transactionReceipt.to : null,\n    transactionIndex: transactionReceipt.transactionIndex ? hexToNumber(transactionReceipt.transactionIndex) : null,\n    status: transactionReceipt.status ? receiptStatuses[transactionReceipt.status] : null,\n    type: transactionReceipt.type ? transactionType[transactionReceipt.type] || transactionReceipt.type : null\n  };\n  if (transactionReceipt.blobGasPrice)\n    receipt.blobGasPrice = BigInt(transactionReceipt.blobGasPrice);\n  if (transactionReceipt.blobGasUsed)\n    receipt.blobGasUsed = BigInt(transactionReceipt.blobGasUsed);\n  return receipt;\n}\nvar defineTransactionReceipt = /* @__PURE__ */ defineFormatter(\"transactionReceipt\", formatTransactionReceipt);\n\n// node_modules/viem/_esm/utils/chain/defineChain.js\nfunction defineChain(chain) {\n  return {\n    formatters: undefined,\n    fees: undefined,\n    serializers: undefined,\n    ...chain\n  };\n}\n\n// node_modules/viem/_esm/utils/abi/encodePacked.js\ninit_abi();\ninit_address();\ninit_isAddress();\ninit_pad();\ninit_toHex();\ninit_regex2();\nfunction encodePacked(types, values) {\n  if (types.length !== values.length)\n    throw new AbiEncodingLengthMismatchError({\n      expectedLength: types.length,\n      givenLength: values.length\n    });\n  const data = [];\n  for (let i = 0;i < types.length; i++) {\n    const type = types[i];\n    const value = values[i];\n    data.push(encode(type, value));\n  }\n  return concatHex(data);\n}\nfunction encode(type, value, isArray = false) {\n  if (type === \"address\") {\n    const address = value;\n    if (!isAddress(address))\n      throw new InvalidAddressError({ address });\n    return pad(address.toLowerCase(), {\n      size: isArray ? 32 : null\n    });\n  }\n  if (type === \"string\")\n    return stringToHex(value);\n  if (type === \"bytes\")\n    return value;\n  if (type === \"bool\")\n    return pad(boolToHex(value), { size: isArray ? 32 : 1 });\n  const intMatch = type.match(integerRegex);\n  if (intMatch) {\n    const [_type, baseType, bits = \"256\"] = intMatch;\n    const size2 = Number.parseInt(bits) / 8;\n    return numberToHex(value, {\n      size: isArray ? 32 : size2,\n      signed: baseType === \"int\"\n    });\n  }\n  const bytesMatch = type.match(bytesRegex);\n  if (bytesMatch) {\n    const [_type, size2] = bytesMatch;\n    if (Number.parseInt(size2) !== (value.length - 2) / 2)\n      throw new BytesSizeMismatchError({\n        expectedSize: Number.parseInt(size2),\n        givenSize: (value.length - 2) / 2\n      });\n    return pad(value, { dir: \"right\", size: isArray ? 32 : null });\n  }\n  const arrayMatch = type.match(arrayRegex);\n  if (arrayMatch && Array.isArray(value)) {\n    const [_type, childType] = arrayMatch;\n    const data = [];\n    for (let i = 0;i < value.length; i++) {\n      data.push(encode(childType, value[i], true));\n    }\n    if (data.length === 0)\n      return \"0x\";\n    return concatHex(data);\n  }\n  throw new UnsupportedPackedAbiType(type);\n}\n\n// node_modules/viem/_esm/utils/authorization/serializeAuthorizationList.js\ninit_toHex();\n\n// node_modules/viem/_esm/utils/transaction/serializeTransaction.js\ninit_transaction();\ninit_toHex();\n\n// node_modules/viem/_esm/utils/transaction/assertTransaction.js\ninit_number();\ninit_address();\ninit_base();\ninit_chain();\ninit_node();\ninit_isAddress();\ninit_size();\ninit_slice();\ninit_fromHex();\nfunction assertTransactionEIP7702(transaction) {\n  const { authorizationList } = transaction;\n  if (authorizationList) {\n    for (const authorization of authorizationList) {\n      const { chainId } = authorization;\n      const address = authorization.address;\n      if (!isAddress(address))\n        throw new InvalidAddressError({ address });\n      if (chainId < 0)\n        throw new InvalidChainIdError({ chainId });\n    }\n  }\n  assertTransactionEIP1559(transaction);\n}\nfunction assertTransactionEIP4844(transaction) {\n  const { blobVersionedHashes } = transaction;\n  if (blobVersionedHashes) {\n    if (blobVersionedHashes.length === 0)\n      throw new EmptyBlobError;\n    for (const hash2 of blobVersionedHashes) {\n      const size_ = size(hash2);\n      const version2 = hexToNumber(slice(hash2, 0, 1));\n      if (size_ !== 32)\n        throw new InvalidVersionedHashSizeError({ hash: hash2, size: size_ });\n      if (version2 !== versionedHashVersionKzg)\n        throw new InvalidVersionedHashVersionError({\n          hash: hash2,\n          version: version2\n        });\n    }\n  }\n  assertTransactionEIP1559(transaction);\n}\nfunction assertTransactionEIP1559(transaction) {\n  const { chainId, maxPriorityFeePerGas, maxFeePerGas, to } = transaction;\n  if (chainId <= 0)\n    throw new InvalidChainIdError({ chainId });\n  if (to && !isAddress(to))\n    throw new InvalidAddressError({ address: to });\n  if (maxFeePerGas && maxFeePerGas > maxUint256)\n    throw new FeeCapTooHighError({ maxFeePerGas });\n  if (maxPriorityFeePerGas && maxFeePerGas && maxPriorityFeePerGas > maxFeePerGas)\n    throw new TipAboveFeeCapError({ maxFeePerGas, maxPriorityFeePerGas });\n}\nfunction assertTransactionEIP2930(transaction) {\n  const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to } = transaction;\n  if (chainId <= 0)\n    throw new InvalidChainIdError({ chainId });\n  if (to && !isAddress(to))\n    throw new InvalidAddressError({ address: to });\n  if (maxPriorityFeePerGas || maxFeePerGas)\n    throw new BaseError(\"`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid EIP-2930 Transaction attribute.\");\n  if (gasPrice && gasPrice > maxUint256)\n    throw new FeeCapTooHighError({ maxFeePerGas: gasPrice });\n}\nfunction assertTransactionLegacy(transaction) {\n  const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to } = transaction;\n  if (to && !isAddress(to))\n    throw new InvalidAddressError({ address: to });\n  if (typeof chainId !== \"undefined\" && chainId <= 0)\n    throw new InvalidChainIdError({ chainId });\n  if (maxPriorityFeePerGas || maxFeePerGas)\n    throw new BaseError(\"`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid Legacy Transaction attribute.\");\n  if (gasPrice && gasPrice > maxUint256)\n    throw new FeeCapTooHighError({ maxFeePerGas: gasPrice });\n}\n\n// node_modules/viem/_esm/utils/transaction/serializeAccessList.js\ninit_address();\ninit_transaction();\ninit_isAddress();\nfunction serializeAccessList(accessList) {\n  if (!accessList || accessList.length === 0)\n    return [];\n  const serializedAccessList = [];\n  for (let i = 0;i < accessList.length; i++) {\n    const { address, storageKeys } = accessList[i];\n    for (let j = 0;j < storageKeys.length; j++) {\n      if (storageKeys[j].length - 2 !== 64) {\n        throw new InvalidStorageKeySizeError({ storageKey: storageKeys[j] });\n      }\n    }\n    if (!isAddress(address, { strict: false })) {\n      throw new InvalidAddressError({ address });\n    }\n    serializedAccessList.push([address, storageKeys]);\n  }\n  return serializedAccessList;\n}\n\n// node_modules/viem/_esm/utils/transaction/serializeTransaction.js\nfunction serializeTransaction(transaction, signature) {\n  const type = getTransactionType(transaction);\n  if (type === \"eip1559\")\n    return serializeTransactionEIP1559(transaction, signature);\n  if (type === \"eip2930\")\n    return serializeTransactionEIP2930(transaction, signature);\n  if (type === \"eip4844\")\n    return serializeTransactionEIP4844(transaction, signature);\n  if (type === \"eip7702\")\n    return serializeTransactionEIP7702(transaction, signature);\n  return serializeTransactionLegacy(transaction, signature);\n}\nfunction serializeTransactionEIP7702(transaction, signature) {\n  const { authorizationList, chainId, gas, nonce, to, value, maxFeePerGas, maxPriorityFeePerGas, accessList, data } = transaction;\n  assertTransactionEIP7702(transaction);\n  const serializedAccessList = serializeAccessList(accessList);\n  const serializedAuthorizationList = serializeAuthorizationList(authorizationList);\n  return concatHex([\n    \"0x04\",\n    toRlp([\n      numberToHex(chainId),\n      nonce ? numberToHex(nonce) : \"0x\",\n      maxPriorityFeePerGas ? numberToHex(maxPriorityFeePerGas) : \"0x\",\n      maxFeePerGas ? numberToHex(maxFeePerGas) : \"0x\",\n      gas ? numberToHex(gas) : \"0x\",\n      to ?? \"0x\",\n      value ? numberToHex(value) : \"0x\",\n      data ?? \"0x\",\n      serializedAccessList,\n      serializedAuthorizationList,\n      ...toYParitySignatureArray(transaction, signature)\n    ])\n  ]);\n}\nfunction serializeTransactionEIP4844(transaction, signature) {\n  const { chainId, gas, nonce, to, value, maxFeePerBlobGas, maxFeePerGas, maxPriorityFeePerGas, accessList, data } = transaction;\n  assertTransactionEIP4844(transaction);\n  let blobVersionedHashes = transaction.blobVersionedHashes;\n  let sidecars = transaction.sidecars;\n  if (transaction.blobs && (typeof blobVersionedHashes === \"undefined\" || typeof sidecars === \"undefined\")) {\n    const blobs2 = typeof transaction.blobs[0] === \"string\" ? transaction.blobs : transaction.blobs.map((x) => bytesToHex(x));\n    const kzg = transaction.kzg;\n    const commitments2 = blobsToCommitments({\n      blobs: blobs2,\n      kzg\n    });\n    if (typeof blobVersionedHashes === \"undefined\")\n      blobVersionedHashes = commitmentsToVersionedHashes({\n        commitments: commitments2\n      });\n    if (typeof sidecars === \"undefined\") {\n      const proofs2 = blobsToProofs({ blobs: blobs2, commitments: commitments2, kzg });\n      sidecars = toBlobSidecars({ blobs: blobs2, commitments: commitments2, proofs: proofs2 });\n    }\n  }\n  const serializedAccessList = serializeAccessList(accessList);\n  const serializedTransaction = [\n    numberToHex(chainId),\n    nonce ? numberToHex(nonce) : \"0x\",\n    maxPriorityFeePerGas ? numberToHex(maxPriorityFeePerGas) : \"0x\",\n    maxFeePerGas ? numberToHex(maxFeePerGas) : \"0x\",\n    gas ? numberToHex(gas) : \"0x\",\n    to ?? \"0x\",\n    value ? numberToHex(value) : \"0x\",\n    data ?? \"0x\",\n    serializedAccessList,\n    maxFeePerBlobGas ? numberToHex(maxFeePerBlobGas) : \"0x\",\n    blobVersionedHashes ?? [],\n    ...toYParitySignatureArray(transaction, signature)\n  ];\n  const blobs = [];\n  const commitments = [];\n  const proofs = [];\n  if (sidecars)\n    for (let i = 0;i < sidecars.length; i++) {\n      const { blob, commitment, proof } = sidecars[i];\n      blobs.push(blob);\n      commitments.push(commitment);\n      proofs.push(proof);\n    }\n  return concatHex([\n    \"0x03\",\n    sidecars ? toRlp([serializedTransaction, blobs, commitments, proofs]) : toRlp(serializedTransaction)\n  ]);\n}\nfunction serializeTransactionEIP1559(transaction, signature) {\n  const { chainId, gas, nonce, to, value, maxFeePerGas, maxPriorityFeePerGas, accessList, data } = transaction;\n  assertTransactionEIP1559(transaction);\n  const serializedAccessList = serializeAccessList(accessList);\n  const serializedTransaction = [\n    numberToHex(chainId),\n    nonce ? numberToHex(nonce) : \"0x\",\n    maxPriorityFeePerGas ? numberToHex(maxPriorityFeePerGas) : \"0x\",\n    maxFeePerGas ? numberToHex(maxFeePerGas) : \"0x\",\n    gas ? numberToHex(gas) : \"0x\",\n    to ?? \"0x\",\n    value ? numberToHex(value) : \"0x\",\n    data ?? \"0x\",\n    serializedAccessList,\n    ...toYParitySignatureArray(transaction, signature)\n  ];\n  return concatHex([\n    \"0x02\",\n    toRlp(serializedTransaction)\n  ]);\n}\nfunction serializeTransactionEIP2930(transaction, signature) {\n  const { chainId, gas, data, nonce, to, value, accessList, gasPrice } = transaction;\n  assertTransactionEIP2930(transaction);\n  const serializedAccessList = serializeAccessList(accessList);\n  const serializedTransaction = [\n    numberToHex(chainId),\n    nonce ? numberToHex(nonce) : \"0x\",\n    gasPrice ? numberToHex(gasPrice) : \"0x\",\n    gas ? numberToHex(gas) : \"0x\",\n    to ?? \"0x\",\n    value ? numberToHex(value) : \"0x\",\n    data ?? \"0x\",\n    serializedAccessList,\n    ...toYParitySignatureArray(transaction, signature)\n  ];\n  return concatHex([\n    \"0x01\",\n    toRlp(serializedTransaction)\n  ]);\n}\nfunction serializeTransactionLegacy(transaction, signature) {\n  const { chainId = 0, gas, data, nonce, to, value, gasPrice } = transaction;\n  assertTransactionLegacy(transaction);\n  let serializedTransaction = [\n    nonce ? numberToHex(nonce) : \"0x\",\n    gasPrice ? numberToHex(gasPrice) : \"0x\",\n    gas ? numberToHex(gas) : \"0x\",\n    to ?? \"0x\",\n    value ? numberToHex(value) : \"0x\",\n    data ?? \"0x\"\n  ];\n  if (signature) {\n    const v = (() => {\n      if (signature.v >= 35n) {\n        const inferredChainId = (signature.v - 35n) / 2n;\n        if (inferredChainId > 0)\n          return signature.v;\n        return 27n + (signature.v === 35n ? 0n : 1n);\n      }\n      if (chainId > 0)\n        return BigInt(chainId * 2) + BigInt(35n + signature.v - 27n);\n      const v2 = 27n + (signature.v === 27n ? 0n : 1n);\n      if (signature.v !== v2)\n        throw new InvalidLegacyVError({ v: signature.v });\n      return v2;\n    })();\n    const r = trim(signature.r);\n    const s = trim(signature.s);\n    serializedTransaction = [\n      ...serializedTransaction,\n      numberToHex(v),\n      r === \"0x00\" ? \"0x\" : r,\n      s === \"0x00\" ? \"0x\" : s\n    ];\n  } else if (chainId > 0) {\n    serializedTransaction = [\n      ...serializedTransaction,\n      numberToHex(chainId),\n      \"0x\",\n      \"0x\"\n    ];\n  }\n  return toRlp(serializedTransaction);\n}\nfunction toYParitySignatureArray(transaction, signature_) {\n  const signature = signature_ ?? transaction;\n  const { v, yParity } = signature;\n  if (typeof signature.r === \"undefined\")\n    return [];\n  if (typeof signature.s === \"undefined\")\n    return [];\n  if (typeof v === \"undefined\" && typeof yParity === \"undefined\")\n    return [];\n  const r = trim(signature.r);\n  const s = trim(signature.s);\n  const yParity_ = (() => {\n    if (typeof yParity === \"number\")\n      return yParity ? numberToHex(1) : \"0x\";\n    if (v === 0n)\n      return \"0x\";\n    if (v === 1n)\n      return numberToHex(1);\n    return v === 27n ? \"0x\" : numberToHex(1);\n  })();\n  return [yParity_, r === \"0x00\" ? \"0x\" : r, s === \"0x00\" ? \"0x\" : s];\n}\n\n// node_modules/viem/_esm/utils/authorization/serializeAuthorizationList.js\nfunction serializeAuthorizationList(authorizationList) {\n  if (!authorizationList || authorizationList.length === 0)\n    return [];\n  const serializedAuthorizationList = [];\n  for (const authorization of authorizationList) {\n    const { chainId, nonce, ...signature } = authorization;\n    const contractAddress = authorization.address;\n    serializedAuthorizationList.push([\n      chainId ? toHex(chainId) : \"0x\",\n      contractAddress,\n      nonce ? toHex(nonce) : \"0x\",\n      ...toYParitySignatureArray({}, signature)\n    ]);\n  }\n  return serializedAuthorizationList;\n}\n// node_modules/viem/_esm/utils/data/isBytes.js\nfunction isBytes2(value) {\n  if (!value)\n    return false;\n  if (typeof value !== \"object\")\n    return false;\n  if (!(\"BYTES_PER_ELEMENT\" in value))\n    return false;\n  return value.BYTES_PER_ELEMENT === 1 && value.constructor.name === \"Uint8Array\";\n}\n\n// node_modules/viem/_esm/utils/address/getContractAddress.js\ninit_pad();\ninit_slice();\ninit_toBytes();\ninit_keccak256();\ninit_getAddress();\nfunction getCreate2Address(opts) {\n  const from = toBytes2(getAddress(opts.from));\n  const salt = pad(isBytes2(opts.salt) ? opts.salt : toBytes2(opts.salt), {\n    size: 32\n  });\n  const bytecodeHash = (() => {\n    if (\"bytecodeHash\" in opts) {\n      if (isBytes2(opts.bytecodeHash))\n        return opts.bytecodeHash;\n      return toBytes2(opts.bytecodeHash);\n    }\n    return keccak256(opts.bytecode, \"bytes\");\n  })();\n  return getAddress(slice(keccak256(concat([toBytes2(\"0xff\"), from, salt, bytecodeHash])), 12));\n}\n\n// node_modules/viem/_esm/index.js\ninit_encodeAbiParameters();\ninit_encodeFunctionData();\ninit_keccak256();\n\n// src/utils/calculateWalletAddress.ts\nvar CONTRACT_ADDRESSES = {\n  ACCOUNT_IMPLEMENTATION: \"0x0006050168DE255a8672ACaD4821e721CBA44337\",\n  ATTESTER: \"0x000474392a9cd86a4687354f1Ce2964B52e97484\",\n  BOOTSTRAPPER: \"0x00000000D3254452a909E4eeD47455Af7E27C289\",\n  FACTORY: \"0x00E58DF70FaB983a324c4C068c82d20407579FaC\",\n  REGISTRY: \"0x000000000069E2a187AEFFb852bF3cCdC95151B2\",\n  WEBAUTHN_VALIDATOR: \"0xbA45a2BFb8De3D24cA9D7F1B551E14dFF5d690Fd\"\n};\nfunction calculateWalletAddress(params) {\n  const { publicKey, credentialId, index = 0n } = params;\n  if (!publicKey.startsWith(\"0x\") || publicKey.length !== 130) {\n    throw new Error(\"Invalid public key: must be 64-byte hex string (0x + 128 chars)\");\n  }\n  const pubKeyX = `0x${publicKey.slice(2, 66)}`;\n  const pubKeyY = `0x${publicKey.slice(66, 130)}`;\n  const webAuthnData = {\n    pubKeyX: BigInt(pubKeyX),\n    pubKeyY: BigInt(pubKeyY)\n  };\n  if (!validateWebAuthnKey(webAuthnData)) {\n    throw new Error(\"Invalid WebAuthn key: coordinates are not on secp256r1 curve\");\n  }\n  const authenticatorIdHash = generateAuthenticatorIdHash(credentialId);\n  return calculateAddressInternal({\n    authenticatorIdHash,\n    index,\n    webAuthnData\n  });\n}\nfunction generateAuthenticatorIdHash(credentialId) {\n  const padding = \"=\".repeat((4 - credentialId.length % 4) % 4);\n  const base64 = credentialId.replace(/-/g, \"+\").replace(/_/g, \"/\") + padding;\n  const binaryString = atob(base64);\n  const bytes = new Uint8Array(binaryString.length);\n  for (let i = 0;i < binaryString.length; i++) {\n    bytes[i] = binaryString.charCodeAt(i);\n  }\n  return keccak256(bytes);\n}\nfunction validateWebAuthnKey(webAuthnData) {\n  const SECP256R1_P = 0xffffffff00000001000000000000000000000000ffffffffffffffffffffffffn;\n  const SECP256R1_B = 0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604bn;\n  const { pubKeyX, pubKeyY } = webAuthnData;\n  if (pubKeyX === 0n || pubKeyY === 0n || pubKeyX >= SECP256R1_P || pubKeyY >= SECP256R1_P) {\n    return false;\n  }\n  const ySquared = pubKeyY * pubKeyY % SECP256R1_P;\n  const xCubed = pubKeyX * pubKeyX * pubKeyX % SECP256R1_P;\n  const threeX = 3n * pubKeyX % SECP256R1_P;\n  const rightSide = (xCubed + SECP256R1_P - threeX + SECP256R1_B) % SECP256R1_P;\n  return ySquared === rightSide;\n}\nfunction calculateAddressInternal(params) {\n  const { webAuthnData, authenticatorIdHash, index } = params;\n  const factoryAddress = CONTRACT_ADDRESSES.FACTORY;\n  const accountImplementation = CONTRACT_ADDRESSES.ACCOUNT_IMPLEMENTATION;\n  const webAuthnValidator = CONTRACT_ADDRESSES.WEBAUTHN_VALIDATOR;\n  const attester = CONTRACT_ADDRESSES.ATTESTER;\n  const bootstrapper = CONTRACT_ADDRESSES.BOOTSTRAPPER;\n  const registry = CONTRACT_ADDRESSES.REGISTRY;\n  const salt = keccak256(encodePacked([\"uint256\", \"uint256\", \"bytes32\", \"uint256\"], [webAuthnData.pubKeyX, webAuthnData.pubKeyY, authenticatorIdHash, index]));\n  const validatorInitData = encodeAbiParameters([\n    {\n      components: [\n        { name: \"pubKeyX\", type: \"uint256\" },\n        { name: \"pubKeyY\", type: \"uint256\" }\n      ],\n      type: \"tuple\"\n    },\n    { type: \"bytes32\" }\n  ], [webAuthnData, authenticatorIdHash]);\n  const registryConfig = {\n    attesters: [attester],\n    registry,\n    threshold: 1n\n  };\n  const bootstrapCall = encodeFunctionData({\n    abi: [\n      {\n        inputs: [\n          { name: \"validator\", type: \"address\" },\n          { name: \"validatorInitData\", type: \"bytes\" },\n          {\n            components: [\n              { name: \"registry\", type: \"address\" },\n              { name: \"attesters\", type: \"address[]\" },\n              { name: \"threshold\", type: \"uint8\" }\n            ],\n            name: \"registryConfig\",\n            type: \"tuple\"\n          }\n        ],\n        name: \"initNexusWithSingleValidator\",\n        type: \"function\"\n      }\n    ],\n    args: [webAuthnValidator, validatorInitData, registryConfig],\n    functionName: \"initNexusWithSingleValidator\"\n  });\n  const initData = encodeAbiParameters([{ type: \"address\" }, { type: \"bytes\" }], [bootstrapper, bootstrapCall]);\n  return predictProxyAddress(accountImplementation, salt, initData, factoryAddress);\n}\nfunction predictProxyAddress(implementation, salt, initData, deployer) {\n  const initializeCall = encodeFunctionData({\n    abi: [\n      {\n        inputs: [{ name: \"data\", type: \"bytes\" }],\n        name: \"initializeAccount\",\n        type: \"function\"\n      }\n    ],\n    args: [initData],\n    functionName: \"initializeAccount\"\n  });\n  const constructorArgs = encodeAbiParameters([{ type: \"address\" }, { type: \"bytes\" }], [implementation, initializeCall]);\n  const nexusProxyCreationCode = \"0x60806040526102c8803803806100148161018c565b92833981016040828203126101885781516001600160a01b03811692909190838303610188576020810151906001600160401b03821161018857019281601f8501121561018857835161006e610069826101c5565b61018c565b9481865260208601936020838301011161018857815f926020809301865e8601015260017f90b772c2cb8a51aa7a8a65fc23543c6d022d5b3f8e2b92eed79fba7eef8293005d823b15610176577f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc80546001600160a01b031916821790557fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b5f80a282511561015e575f8091610146945190845af43d15610156573d91610137610069846101c5565b9283523d5f602085013e6101e0565b505b6040516089908161023f8239f35b6060916101e0565b50505034156101485763b398979f60e01b5f5260045ffd5b634c9c8ce360e01b5f5260045260245ffd5b5f80fd5b6040519190601f01601f191682016001600160401b038111838210176101b157604052565b634e487b7160e01b5f52604160045260245ffd5b6001600160401b0381116101b157601f01601f191660200190565b9061020457508051156101f557805190602001fd5b63d6bda27560e01b5f5260045ffd5b81511580610235575b610215575090565b639996b31560e01b5f9081526001600160a01b0391909116600452602490fd5b50803b1561020d56fe608060405236156051577f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545f9081906001600160a01b0316368280378136915af43d5f803e15604d573d5ff35b3d5ffd5b00fea264697066735822122041b5f70a351952142223f22504ca7b4e6d975f3a302d114ff820442fcf815ac264736f6c634300081b0033\";\n  const initCodeHash = keccak256(encodePacked([\"bytes\", \"bytes\"], [nexusProxyCreationCode, constructorArgs]));\n  return getCreate2Address({\n    bytecodeHash: initCodeHash,\n    from: deployer,\n    salt\n  });\n}\n// node_modules/viem/_esm/op-stack/contracts.js\nvar contracts = {\n  gasPriceOracle: { address: \"0x420000000000000000000000000000000000000F\" },\n  l1Block: { address: \"0x4200000000000000000000000000000000000015\" },\n  l2CrossDomainMessenger: {\n    address: \"0x4200000000000000000000000000000000000007\"\n  },\n  l2Erc721Bridge: { address: \"0x4200000000000000000000000000000000000014\" },\n  l2StandardBridge: { address: \"0x4200000000000000000000000000000000000010\" },\n  l2ToL1MessagePasser: {\n    address: \"0x4200000000000000000000000000000000000016\"\n  }\n};\n\n// node_modules/viem/_esm/op-stack/formatters.js\ninit_fromHex();\nvar formatters = {\n  block: /* @__PURE__ */ defineBlock({\n    format(args) {\n      const transactions = args.transactions?.map((transaction) => {\n        if (typeof transaction === \"string\")\n          return transaction;\n        const formatted = formatTransaction(transaction);\n        if (formatted.typeHex === \"0x7e\") {\n          formatted.isSystemTx = transaction.isSystemTx;\n          formatted.mint = transaction.mint ? hexToBigInt(transaction.mint) : undefined;\n          formatted.sourceHash = transaction.sourceHash;\n          formatted.type = \"deposit\";\n        }\n        return formatted;\n      });\n      return {\n        transactions,\n        stateRoot: args.stateRoot\n      };\n    }\n  }),\n  transaction: /* @__PURE__ */ defineTransaction({\n    format(args) {\n      const transaction = {};\n      if (args.type === \"0x7e\") {\n        transaction.isSystemTx = args.isSystemTx;\n        transaction.mint = args.mint ? hexToBigInt(args.mint) : undefined;\n        transaction.sourceHash = args.sourceHash;\n        transaction.type = \"deposit\";\n      }\n      return transaction;\n    }\n  }),\n  transactionReceipt: /* @__PURE__ */ defineTransactionReceipt({\n    format(args) {\n      return {\n        l1GasPrice: args.l1GasPrice ? hexToBigInt(args.l1GasPrice) : null,\n        l1GasUsed: args.l1GasUsed ? hexToBigInt(args.l1GasUsed) : null,\n        l1Fee: args.l1Fee ? hexToBigInt(args.l1Fee) : null,\n        l1FeeScalar: args.l1FeeScalar ? Number(args.l1FeeScalar) : null\n      };\n    }\n  })\n};\n\n// node_modules/viem/_esm/op-stack/serializers.js\ninit_address();\ninit_isAddress();\ninit_toHex();\nfunction serializeTransaction2(transaction, signature) {\n  if (isDeposit(transaction))\n    return serializeTransactionDeposit(transaction);\n  return serializeTransaction(transaction, signature);\n}\nvar serializers = {\n  transaction: serializeTransaction2\n};\nfunction serializeTransactionDeposit(transaction) {\n  assertTransactionDeposit(transaction);\n  const { sourceHash, data, from, gas, isSystemTx, mint, to, value } = transaction;\n  const serializedTransaction = [\n    sourceHash,\n    from,\n    to ?? \"0x\",\n    mint ? toHex(mint) : \"0x\",\n    value ? toHex(value) : \"0x\",\n    gas ? toHex(gas) : \"0x\",\n    isSystemTx ? \"0x1\" : \"0x\",\n    data ?? \"0x\"\n  ];\n  return concatHex([\n    \"0x7e\",\n    toRlp(serializedTransaction)\n  ]);\n}\nfunction isDeposit(transaction) {\n  if (transaction.type === \"deposit\")\n    return true;\n  if (typeof transaction.sourceHash !== \"undefined\")\n    return true;\n  return false;\n}\nfunction assertTransactionDeposit(transaction) {\n  const { from, to } = transaction;\n  if (from && !isAddress(from))\n    throw new InvalidAddressError({ address: from });\n  if (to && !isAddress(to))\n    throw new InvalidAddressError({ address: to });\n}\n\n// node_modules/viem/_esm/op-stack/chainConfig.js\nvar chainConfig = {\n  blockTime: 2000,\n  contracts,\n  formatters,\n  serializers\n};\n\n// node_modules/viem/_esm/chains/definitions/arbitrum.js\nvar arbitrum = /* @__PURE__ */ defineChain({\n  id: 42161,\n  name: \"Arbitrum One\",\n  nativeCurrency: { name: \"Ether\", symbol: \"ETH\", decimals: 18 },\n  blockTime: 250,\n  rpcUrls: {\n    default: {\n      http: [\"https://arb1.arbitrum.io/rpc\"]\n    }\n  },\n  blockExplorers: {\n    default: {\n      name: \"Arbiscan\",\n      url: \"https://arbiscan.io\",\n      apiUrl: \"https://api.arbiscan.io/api\"\n    }\n  },\n  contracts: {\n    multicall3: {\n      address: \"0xca11bde05977b3631167028862be2a173976ca11\",\n      blockCreated: 7654707\n    }\n  }\n});\n// node_modules/viem/_esm/chains/definitions/arbitrumSepolia.js\nvar arbitrumSepolia = /* @__PURE__ */ defineChain({\n  id: 421614,\n  name: \"Arbitrum Sepolia\",\n  blockTime: 250,\n  nativeCurrency: {\n    name: \"Arbitrum Sepolia Ether\",\n    symbol: \"ETH\",\n    decimals: 18\n  },\n  rpcUrls: {\n    default: {\n      http: [\"https://sepolia-rollup.arbitrum.io/rpc\"]\n    }\n  },\n  blockExplorers: {\n    default: {\n      name: \"Arbiscan\",\n      url: \"https://sepolia.arbiscan.io\",\n      apiUrl: \"https://api-sepolia.arbiscan.io/api\"\n    }\n  },\n  contracts: {\n    multicall3: {\n      address: \"0xca11bde05977b3631167028862be2a173976ca11\",\n      blockCreated: 81930\n    }\n  },\n  testnet: true\n});\n// node_modules/viem/_esm/chains/definitions/base.js\nvar sourceId = 1;\nvar base = /* @__PURE__ */ defineChain({\n  ...chainConfig,\n  id: 8453,\n  name: \"Base\",\n  nativeCurrency: { name: \"Ether\", symbol: \"ETH\", decimals: 18 },\n  rpcUrls: {\n    default: {\n      http: [\"https://mainnet.base.org\"]\n    }\n  },\n  blockExplorers: {\n    default: {\n      name: \"Basescan\",\n      url: \"https://basescan.org\",\n      apiUrl: \"https://api.basescan.org/api\"\n    }\n  },\n  contracts: {\n    ...chainConfig.contracts,\n    disputeGameFactory: {\n      [sourceId]: {\n        address: \"0x43edB88C4B80fDD2AdFF2412A7BebF9dF42cB40e\"\n      }\n    },\n    l2OutputOracle: {\n      [sourceId]: {\n        address: \"0x56315b90c40730925ec5485cf004d835058518A0\"\n      }\n    },\n    multicall3: {\n      address: \"0xca11bde05977b3631167028862be2a173976ca11\",\n      blockCreated: 5022\n    },\n    portal: {\n      [sourceId]: {\n        address: \"0x49048044D57e1C92A77f79988d21Fa8fAF74E97e\",\n        blockCreated: 17482143\n      }\n    },\n    l1StandardBridge: {\n      [sourceId]: {\n        address: \"0x3154Cf16ccdb4C6d922629664174b904d80F2C35\",\n        blockCreated: 17482143\n      }\n    }\n  },\n  sourceId\n});\nvar basePreconf = /* @__PURE__ */ defineChain({\n  ...base,\n  experimental_preconfirmationTime: 200,\n  rpcUrls: {\n    default: {\n      http: [\"https://mainnet-preconf.base.org\"]\n    }\n  }\n});\n// node_modules/viem/_esm/chains/definitions/baseSepolia.js\nvar sourceId2 = 11155111;\nvar baseSepolia = /* @__PURE__ */ defineChain({\n  ...chainConfig,\n  id: 84532,\n  network: \"base-sepolia\",\n  name: \"Base Sepolia\",\n  nativeCurrency: { name: \"Sepolia Ether\", symbol: \"ETH\", decimals: 18 },\n  rpcUrls: {\n    default: {\n      http: [\"https://sepolia.base.org\"]\n    }\n  },\n  blockExplorers: {\n    default: {\n      name: \"Basescan\",\n      url: \"https://sepolia.basescan.org\",\n      apiUrl: \"https://api-sepolia.basescan.org/api\"\n    }\n  },\n  contracts: {\n    ...chainConfig.contracts,\n    disputeGameFactory: {\n      [sourceId2]: {\n        address: \"0xd6E6dBf4F7EA0ac412fD8b65ED297e64BB7a06E1\"\n      }\n    },\n    l2OutputOracle: {\n      [sourceId2]: {\n        address: \"0x84457ca9D0163FbC4bbfe4Dfbb20ba46e48DF254\"\n      }\n    },\n    portal: {\n      [sourceId2]: {\n        address: \"0x49f53e41452c74589e85ca1677426ba426459e85\",\n        blockCreated: 4446677\n      }\n    },\n    l1StandardBridge: {\n      [sourceId2]: {\n        address: \"0xfd0Bf71F60660E2f608ed56e1659C450eB113120\",\n        blockCreated: 4446677\n      }\n    },\n    multicall3: {\n      address: \"0xca11bde05977b3631167028862be2a173976ca11\",\n      blockCreated: 1059647\n    }\n  },\n  testnet: true,\n  sourceId: sourceId2\n});\nvar baseSepoliaPreconf = /* @__PURE__ */ defineChain({\n  ...baseSepolia,\n  experimental_preconfirmationTime: 200,\n  rpcUrls: {\n    default: {\n      http: [\"https://sepolia-preconf.base.org\"]\n    }\n  }\n});\n// node_modules/viem/_esm/chains/definitions/mainnet.js\nvar mainnet = /* @__PURE__ */ defineChain({\n  id: 1,\n  name: \"Ethereum\",\n  nativeCurrency: { name: \"Ether\", symbol: \"ETH\", decimals: 18 },\n  rpcUrls: {\n    default: {\n      http: [\"https://eth.merkle.io\"]\n    }\n  },\n  blockExplorers: {\n    default: {\n      name: \"Etherscan\",\n      url: \"https://etherscan.io\",\n      apiUrl: \"https://api.etherscan.io/api\"\n    }\n  },\n  contracts: {\n    ensRegistry: {\n      address: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\"\n    },\n    ensUniversalResolver: {\n      address: \"0xce01f8eee7E479C928F8919abD53E553a36CeF67\",\n      blockCreated: 19258213\n    },\n    multicall3: {\n      address: \"0xca11bde05977b3631167028862be2a173976ca11\",\n      blockCreated: 14353601\n    }\n  }\n});\n// node_modules/viem/_esm/chains/definitions/optimism.js\nvar sourceId3 = 1;\nvar optimism = /* @__PURE__ */ defineChain({\n  ...chainConfig,\n  id: 10,\n  name: \"OP Mainnet\",\n  nativeCurrency: { name: \"Ether\", symbol: \"ETH\", decimals: 18 },\n  rpcUrls: {\n    default: {\n      http: [\"https://mainnet.optimism.io\"]\n    }\n  },\n  blockExplorers: {\n    default: {\n      name: \"Optimism Explorer\",\n      url: \"https://optimistic.etherscan.io\",\n      apiUrl: \"https://api-optimistic.etherscan.io/api\"\n    }\n  },\n  contracts: {\n    ...chainConfig.contracts,\n    disputeGameFactory: {\n      [sourceId3]: {\n        address: \"0xe5965Ab5962eDc7477C8520243A95517CD252fA9\"\n      }\n    },\n    l2OutputOracle: {\n      [sourceId3]: {\n        address: \"0xdfe97868233d1aa22e815a266982f2cf17685a27\"\n      }\n    },\n    multicall3: {\n      address: \"0xca11bde05977b3631167028862be2a173976ca11\",\n      blockCreated: 4286263\n    },\n    portal: {\n      [sourceId3]: {\n        address: \"0xbEb5Fc579115071764c7423A4f12eDde41f106Ed\"\n      }\n    },\n    l1StandardBridge: {\n      [sourceId3]: {\n        address: \"0x99C9fc46f92E8a1c0deC1b1747d010903E884bE1\"\n      }\n    }\n  },\n  sourceId: sourceId3\n});\n// node_modules/viem/_esm/chains/definitions/optimismSepolia.js\nvar sourceId4 = 11155111;\nvar optimismSepolia = /* @__PURE__ */ defineChain({\n  ...chainConfig,\n  id: 11155420,\n  name: \"OP Sepolia\",\n  nativeCurrency: { name: \"Sepolia Ether\", symbol: \"ETH\", decimals: 18 },\n  rpcUrls: {\n    default: {\n      http: [\"https://sepolia.optimism.io\"]\n    }\n  },\n  blockExplorers: {\n    default: {\n      name: \"Blockscout\",\n      url: \"https://optimism-sepolia.blockscout.com\",\n      apiUrl: \"https://optimism-sepolia.blockscout.com/api\"\n    }\n  },\n  contracts: {\n    ...chainConfig.contracts,\n    disputeGameFactory: {\n      [sourceId4]: {\n        address: \"0x05F9613aDB30026FFd634f38e5C4dFd30a197Fa1\"\n      }\n    },\n    l2OutputOracle: {\n      [sourceId4]: {\n        address: \"0x90E9c4f8a994a250F6aEfd61CAFb4F2e895D458F\"\n      }\n    },\n    multicall3: {\n      address: \"0xca11bde05977b3631167028862be2a173976ca11\",\n      blockCreated: 1620204\n    },\n    portal: {\n      [sourceId4]: {\n        address: \"0x16Fc5058F25648194471939df75CF27A2fdC48BC\"\n      }\n    },\n    l1StandardBridge: {\n      [sourceId4]: {\n        address: \"0xFBb0621E0B23b5478B630BD55a5f21f67730B0F1\"\n      }\n    }\n  },\n  testnet: true,\n  sourceId: sourceId4\n});\n// node_modules/viem/_esm/chains/definitions/polygon.js\nvar polygon = /* @__PURE__ */ defineChain({\n  id: 137,\n  name: \"Polygon\",\n  nativeCurrency: { name: \"POL\", symbol: \"POL\", decimals: 18 },\n  rpcUrls: {\n    default: {\n      http: [\"https://polygon-rpc.com\"]\n    }\n  },\n  blockExplorers: {\n    default: {\n      name: \"PolygonScan\",\n      url: \"https://polygonscan.com\",\n      apiUrl: \"https://api.polygonscan.com/api\"\n    }\n  },\n  contracts: {\n    multicall3: {\n      address: \"0xca11bde05977b3631167028862be2a173976ca11\",\n      blockCreated: 25770160\n    }\n  }\n});\n// node_modules/viem/_esm/chains/definitions/polygonAmoy.js\nvar polygonAmoy = /* @__PURE__ */ defineChain({\n  id: 80002,\n  name: \"Polygon Amoy\",\n  nativeCurrency: { name: \"POL\", symbol: \"POL\", decimals: 18 },\n  rpcUrls: {\n    default: {\n      http: [\"https://rpc-amoy.polygon.technology\"]\n    }\n  },\n  blockExplorers: {\n    default: {\n      name: \"PolygonScan\",\n      url: \"https://amoy.polygonscan.com\",\n      apiUrl: \"https://api-amoy.polygonscan.com/api\"\n    }\n  },\n  contracts: {\n    multicall3: {\n      address: \"0xca11bde05977b3631167028862be2a173976ca11\",\n      blockCreated: 3127388\n    }\n  },\n  testnet: true\n});\n// node_modules/viem/_esm/chains/definitions/sepolia.js\nvar sepolia = /* @__PURE__ */ defineChain({\n  id: 11155111,\n  name: \"Sepolia\",\n  nativeCurrency: { name: \"Sepolia Ether\", symbol: \"ETH\", decimals: 18 },\n  rpcUrls: {\n    default: {\n      http: [\"https://sepolia.drpc.org\"]\n    }\n  },\n  blockExplorers: {\n    default: {\n      name: \"Etherscan\",\n      url: \"https://sepolia.etherscan.io\",\n      apiUrl: \"https://api-sepolia.etherscan.io/api\"\n    }\n  },\n  contracts: {\n    multicall3: {\n      address: \"0xca11bde05977b3631167028862be2a173976ca11\",\n      blockCreated: 751532\n    },\n    ensRegistry: { address: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\" },\n    ensUniversalResolver: {\n      address: \"0xc8Af999e38273D658BE1b921b88A9Ddf005769cC\",\n      blockCreated: 5317080\n    }\n  },\n  testnet: true\n});\n// src/constants.ts\nvar SDK_BACKEND_URL = \"https://keys.gemini.com\";\nvar ENS_API_URL = \"https://horizon-api.gemini.com/api/ens\";\nvar SDK_VERSION = \"0.2.0\";\nvar DEFAULT_CHAIN_ID = 42161;\nvar MAINNET_CHAIN_IDS = {\n  ARBITRUM_ONE: 42161,\n  BASE: 8453,\n  ETHEREUM: 1,\n  OP_MAINNET: 10,\n  POLYGON: 137\n};\nvar TESTNET_CHAIN_IDS = {\n  ARBITRUM_SEPOLIA: 421614,\n  BASE_SEPOLIA: 84532,\n  OP_SEPOLIA: 11155420,\n  POLYGON_AMOY: 80002,\n  SEPOLIA: 11155111\n};\nvar SUPPORTED_CHAIN_IDS = [\n  ...Object.values(MAINNET_CHAIN_IDS),\n  ...Object.values(TESTNET_CHAIN_IDS)\n];\nfunction getDefaultRpcUrl(chainId) {\n  const chainMap = {\n    [mainnet.id]: mainnet.rpcUrls.default.http[0],\n    [arbitrum.id]: arbitrum.rpcUrls.default.http[0],\n    [optimism.id]: optimism.rpcUrls.default.http[0],\n    [base.id]: base.rpcUrls.default.http[0],\n    [polygon.id]: polygon.rpcUrls.default.http[0],\n    [sepolia.id]: sepolia.rpcUrls.default.http[0],\n    [arbitrumSepolia.id]: arbitrumSepolia.rpcUrls.default.http[0],\n    [optimismSepolia.id]: optimismSepolia.rpcUrls.default.http[0],\n    [baseSepolia.id]: baseSepolia.rpcUrls.default.http[0],\n    [polygonAmoy.id]: polygonAmoy.rpcUrls.default.http[0]\n  };\n  return chainMap[chainId];\n}\nvar POPUP_WIDTH = 420;\nvar POPUP_HEIGHT = 650;\n\n// src/utils/ens.ts\nasync function reverseResolveEns(address) {\n  try {\n    const response = await fetch(`${ENS_API_URL}/reverse/${address}`);\n    if (!response.ok) {\n      throw new Error(`ENS API request failed: ${response.status} ${response.statusText}`);\n    }\n    const data = await response.json();\n    return {\n      address: data.address,\n      name: data.name || null\n    };\n  } catch (error) {\n    console.error(\"Failed to resolve ENS name:\", error);\n    return {\n      address,\n      name: null\n    };\n  }\n}\n// src/utils/popup.ts\nvar openPopup = (url) => {\n  const left = (window.innerWidth - POPUP_WIDTH) / 2 + window.screenX;\n  const top = (window.innerHeight - POPUP_HEIGHT) / 2 + window.screenY;\n  const popupId = `gemini_wallet_${crypto.randomUUID()}`;\n  const popup = window.open(url, popupId, `width=${POPUP_WIDTH}, height=${POPUP_HEIGHT}, left=${left}, top=${top}`);\n  popup?.focus();\n  if (!popup) {\n    throw rpcErrors.internal(\"Pop up window failed to open\");\n  }\n  return popup;\n};\nvar closePopup = (popup) => {\n  if (popup && !popup.closed) {\n    popup.close();\n  }\n};\n// src/utils/strings.ts\nvar hexStringFromNumber = (num) => `0x${BigInt(num).toString(16)}`;\nvar safeJsonStringify = (obj) => JSON.stringify(obj, (_, value) => typeof value === \"bigint\" ? value.toString() + \"n\" : value, 2);\n\n// src/utils/index.ts\nvar generateRequestId = () => crypto.randomUUID();\n\n// src/communicator.ts\nclass Communicator {\n  appMetadata;\n  url;\n  popup = null;\n  listeners = new Map;\n  onDisconnectCallback;\n  constructor({ appMetadata, onDisconnectCallback }) {\n    this.url = new URL(SDK_BACKEND_URL);\n    this.appMetadata = appMetadata;\n    this.onDisconnectCallback = onDisconnectCallback;\n  }\n  async postMessage(message) {\n    const popup = await this.waitForPopupLoaded();\n    popup.postMessage(message, this.url.origin);\n  }\n  async postRequestAndWaitForResponse(request) {\n    const responsePromise = this.onMessage(({ requestId }) => requestId === request.requestId);\n    await this.postMessage(request);\n    return responsePromise;\n  }\n  async onMessage(predicate) {\n    return new Promise((resolve, reject) => {\n      const listener = (event) => {\n        if (event.origin !== this.url.origin)\n          return;\n        const message = event.data;\n        if (predicate(message)) {\n          resolve(message);\n          window.removeEventListener(\"message\", listener);\n          this.listeners.delete(listener);\n        }\n      };\n      window.addEventListener(\"message\", listener);\n      this.listeners.set(listener, { reject });\n    });\n  }\n  onRequestCancelled() {\n    closePopup(this.popup ?? undefined);\n    this.popup = null;\n    this.listeners.forEach(({ reject }, listener) => {\n      reject(providerErrors.userRejectedRequest());\n      window.removeEventListener(\"message\", listener);\n    });\n    this.listeners.clear();\n  }\n  async waitForPopupLoaded() {\n    if (this.popup && !this.popup.closed) {\n      this.popup.focus();\n      return this.popup;\n    }\n    this.popup = openPopup(this.url);\n    this.onMessage(({ event }) => event === \"POPUP_UNLOADED\" /* POPUP_UNLOADED */).then(() => this.onRequestCancelled()).catch(() => {});\n    this.onMessage(({ event }) => event === \"SDK_DISCONNECT\" /* SDK_DISCONNECT */).then(() => {\n      this.onDisconnectCallback?.();\n      this.onRequestCancelled();\n    }).catch(() => {});\n    return this.onMessage(({ event }) => event === \"POPUP_LOADED\" /* POPUP_LOADED */).then((message) => {\n      this.postMessage({\n        chainId: DEFAULT_CHAIN_ID,\n        data: {\n          appMetadata: this.appMetadata,\n          origin: window.location.origin,\n          sdkVersion: SDK_VERSION\n        },\n        event: \"POPUP_APP_CONTEXT\" /* POPUP_APP_CONTEXT */,\n        origin: window.location.origin,\n        requestId: message.requestId\n      });\n      return message;\n    }).then(() => {\n      if (!this.popup)\n        throw rpcErrors.internal();\n      return this.popup;\n    });\n  }\n}\n// src/storage/storageInterface.ts\nvar STORAGE_ETH_ACCOUNTS_KEY = \"eth-accounts\";\nvar STORAGE_ETH_ACTIVE_CHAIN_KEY = \"eth-active-chain\";\nvar STORAGE_PASSKEY_CREDENTIAL_KEY = \"passkey-credential\";\nvar STORAGE_SMART_ACCOUNT_KEY = \"smart-account\";\nvar STORAGE_SETTINGS_KEY = \"settings\";\n\n// src/storage/storage.ts\nvar memoryStorage = {};\nclass GeminiStorage {\n  scope = \"@gemini\";\n  module = \"wallet\";\n  scopedKey(key) {\n    return `${this.scope}.${this.module}.${key}`;\n  }\n  async storeObject(key, item) {\n    const json = safeJsonStringify(item);\n    await this.setItem(key, json);\n  }\n  async loadObject(key, fallback) {\n    const item = await this.getItem(key);\n    if (!item) {\n      await this.storeObject(key, fallback);\n      return fallback;\n    }\n    try {\n      return JSON.parse(item);\n    } catch (error) {\n      console.error(`Error parsing JSON for key ${key}:`, error);\n      return fallback;\n    }\n  }\n  setItem(key, value) {\n    const scoped = this.scopedKey(key);\n    try {\n      localStorage.setItem(scoped, value);\n    } catch {\n      memoryStorage[scoped] = value;\n    }\n    return Promise.resolve();\n  }\n  getItem(key) {\n    const scoped = this.scopedKey(key);\n    try {\n      return Promise.resolve(localStorage.getItem(scoped) ?? undefined);\n    } catch {\n      return Promise.resolve(memoryStorage[scoped] || undefined);\n    }\n  }\n  removeItem(key) {\n    const scoped = this.scopedKey(key);\n    try {\n      localStorage.removeItem(scoped);\n    } catch {\n      delete memoryStorage[scoped];\n    }\n    return Promise.resolve();\n  }\n}\n// src/wallets/wallet.ts\nfunction isChainSupportedByGeminiSw(chainId) {\n  return SUPPORTED_CHAIN_IDS.includes(chainId);\n}\n\nclass GeminiWallet {\n  communicator;\n  storage;\n  initPromise;\n  accounts = [];\n  chain = { id: DEFAULT_CHAIN_ID };\n  constructor({\n    appMetadata,\n    chain,\n    onDisconnectCallback,\n    storage\n  }) {\n    this.communicator = new Communicator({\n      appMetadata,\n      onDisconnectCallback\n    });\n    this.storage = storage || new GeminiStorage;\n    const initialChain = chain || { id: DEFAULT_CHAIN_ID };\n    this.initPromise = this.initializeFromStorage(initialChain);\n  }\n  async initializeFromStorage(defaultChain) {\n    const fallbackChain = {\n      id: defaultChain.id,\n      rpcUrl: defaultChain.rpcUrl || getDefaultRpcUrl(defaultChain.id)\n    };\n    const [storedChain, storedAccounts] = await Promise.all([\n      this.storage.loadObject(STORAGE_ETH_ACTIVE_CHAIN_KEY, fallbackChain),\n      this.storage.loadObject(STORAGE_ETH_ACCOUNTS_KEY, this.accounts)\n    ]);\n    this.chain = {\n      ...storedChain,\n      rpcUrl: storedChain.rpcUrl || getDefaultRpcUrl(storedChain.id)\n    };\n    this.accounts = storedAccounts;\n  }\n  async ensureInitialized() {\n    await this.initPromise;\n  }\n  async connect() {\n    await this.ensureInitialized();\n    const response = await this.sendMessageToPopup({\n      chainId: this.chain.id,\n      event: \"SDK_CONNECT\" /* SDK_CONNECT */,\n      origin: window.location.origin\n    });\n    this.accounts = [response.data.address];\n    await this.storage.storeObject(STORAGE_ETH_ACCOUNTS_KEY, this.accounts);\n    return this.accounts;\n  }\n  async switchChain({\n    id\n  }) {\n    await this.ensureInitialized();\n    if (isChainSupportedByGeminiSw(id)) {\n      this.chain = {\n        id,\n        rpcUrl: getDefaultRpcUrl(id)\n      };\n      await this.storage.storeObject(STORAGE_ETH_ACTIVE_CHAIN_KEY, this.chain);\n      return;\n    }\n    const response = await this.sendMessageToPopup({\n      chainId: this.chain.id,\n      data: id,\n      event: \"SDK_SWITCH_CHAIN\" /* SDK_SWITCH_CHAIN */,\n      origin: window.location.origin\n    });\n    return response.data.error;\n  }\n  async sendTransaction(txData) {\n    await this.ensureInitialized();\n    const response = await this.sendMessageToPopup({\n      chainId: this.chain.id,\n      data: txData,\n      event: \"SDK_SEND_TRANSACTION\" /* SDK_SEND_TRANSACTION */,\n      origin: window.location.origin\n    });\n    return response.data;\n  }\n  async signData({\n    message\n  }) {\n    await this.ensureInitialized();\n    const response = await this.sendMessageToPopup({\n      chainId: this.chain.id,\n      data: { message },\n      event: \"SDK_SIGN_DATA\" /* SDK_SIGN_DATA */,\n      origin: window.location.origin\n    });\n    return response.data;\n  }\n  async signTypedData({\n    message,\n    types,\n    primaryType,\n    domain\n  }) {\n    await this.ensureInitialized();\n    const response = await this.sendMessageToPopup({\n      chainId: this.chain.id,\n      data: {\n        domain,\n        message,\n        primaryType,\n        types\n      },\n      event: \"SDK_SIGN_TYPED_DATA\" /* SDK_SIGN_TYPED_DATA */,\n      origin: window.location.origin\n    });\n    return response.data;\n  }\n  async openSettings() {\n    await this.ensureInitialized();\n    await this.sendMessageToPopup({\n      chainId: this.chain.id,\n      data: {},\n      event: \"SDK_OPEN_SETTINGS\" /* SDK_OPEN_SETTINGS */,\n      origin: window.location.origin\n    });\n  }\n  sendMessageToPopup(request) {\n    return this.communicator.postRequestAndWaitForResponse({\n      ...request,\n      requestId: window?.crypto?.randomUUID()\n    });\n  }\n}\n// src/provider/provider.utils.ts\nvar fetchRpcRequest = async (request, rpcUrl) => {\n  const requestBody = {\n    ...request,\n    id: window?.crypto?.randomUUID(),\n    jsonrpc: \"2.0\"\n  };\n  const res = await window.fetch(rpcUrl, {\n    body: JSON.stringify(requestBody),\n    headers: {\n      \"Content-Type\": \"application/json\"\n    },\n    method: \"POST\",\n    mode: \"cors\"\n  });\n  const { result, error } = await res.json();\n  if (error) {\n    throw error;\n  }\n  return result;\n};\nfunction validateRpcRequestArgs(args) {\n  if (!args || typeof args !== \"object\" || Array.isArray(args)) {\n    throw rpcErrors.invalidParams({\n      message: \"Expected a single, non-array, object argument.\"\n    });\n  }\n  const { method, params } = args;\n  if (typeof method !== \"string\" || method.length === 0) {\n    throw rpcErrors.invalidParams({\n      message: \"'args.method' must be a non-empty string.\"\n    });\n  }\n  if (params !== undefined && !Array.isArray(params) && (typeof params !== \"object\" || params === null)) {\n    throw rpcErrors.invalidParams({\n      message: \"'args.params' must be an object or array if provided.\"\n    });\n  }\n}\nfunction convertSendValuesToBigInt(tx) {\n  const FIELDS_TO_NORMALIZE = [\"value\", \"gas\", \"gasPrice\", \"maxPriorityFeePerGas\", \"maxFeePerGas\"];\n  const normalized = { ...tx };\n  for (const field of FIELDS_TO_NORMALIZE) {\n    if (!(field in tx)) {\n      continue;\n    }\n    const value = tx[field];\n    if (typeof value === \"bigint\") {\n      continue;\n    }\n    if (isHex(value)) {\n      normalized[field] = BigInt(value);\n    }\n  }\n  return normalized;\n}\n\n// src/provider/provider.ts\nclass GeminiWalletProvider extends ProviderEventEmitter {\n  config;\n  wallet = undefined;\n  constructor(providerConfig) {\n    super();\n    this.config = providerConfig;\n    const userDisconnectCallback = providerConfig.onDisconnectCallback;\n    this.wallet = new GeminiWallet({\n      ...providerConfig,\n      onDisconnectCallback: () => {\n        userDisconnectCallback?.();\n        this.disconnect();\n      }\n    });\n  }\n  async request(args) {\n    try {\n      validateRpcRequestArgs(args);\n      if (!this.wallet?.accounts?.length) {\n        switch (args.method) {\n          case \"eth_requestAccounts\": {\n            if (!this.wallet) {\n              const userDisconnectCallback = this.config.onDisconnectCallback;\n              this.wallet = new GeminiWallet({\n                ...this.config,\n                onDisconnectCallback: () => {\n                  userDisconnectCallback?.();\n                  this.disconnect();\n                }\n              });\n            }\n            await this.wallet.connect();\n            this.emit(\"accountsChanged\", this.wallet.accounts);\n            break;\n          }\n          case \"net_version\":\n            return DEFAULT_CHAIN_ID;\n          case \"eth_chainId\":\n            return hexStringFromNumber(DEFAULT_CHAIN_ID);\n          default: {\n            throw providerErrors.unauthorized();\n          }\n        }\n      }\n      let response;\n      let requestParams;\n      switch (args.method) {\n        case \"eth_requestAccounts\":\n        case \"eth_accounts\":\n          response = this.wallet.accounts;\n          break;\n        case \"net_version\":\n          response = this.wallet.chain.id;\n          break;\n        case \"eth_chainId\":\n          response = hexStringFromNumber(this.wallet.chain.id);\n          break;\n        case \"personal_sign\":\n        case \"wallet_sign\":\n          requestParams = args.params;\n          response = await this.wallet.signData({\n            account: requestParams[1],\n            message: requestParams[0]\n          });\n          if (response.error) {\n            throw rpcErrors.transactionRejected(response.error);\n          } else {\n            response = response.hash;\n          }\n          break;\n        case \"eth_sendTransaction\":\n        case \"wallet_sendTransaction\":\n          requestParams = args.params;\n          requestParams = convertSendValuesToBigInt(requestParams[0]);\n          response = await this.wallet.sendTransaction(requestParams);\n          if (response.error) {\n            throw rpcErrors.transactionRejected(response.error);\n          } else {\n            response = response.hash;\n          }\n          break;\n        case \"wallet_switchEthereumChain\": {\n          const rawParams = args.params;\n          let chainId;\n          if (Array.isArray(rawParams) && rawParams[0]?.chainId) {\n            chainId = parseInt(rawParams[0].chainId, 16);\n          } else if (rawParams && typeof rawParams === \"object\" && \"id\" in rawParams && Number.isInteger(rawParams.id)) {\n            chainId = rawParams.id;\n          } else {\n            throw rpcErrors.invalidParams(\"Invalid chain id argument. Expected [{ chainId: hex_string }] or { id: number }.\");\n          }\n          response = await this.wallet.switchChain({ id: chainId });\n          if (response) {\n            throw providerErrors.custom({ code: 4902, message: response });\n          }\n          await this.emit(\"chainChanged\", hexStringFromNumber(chainId));\n          break;\n        }\n        case \"eth_signTypedData_v1\":\n        case \"eth_signTypedData_v2\":\n        case \"eth_signTypedData_v3\":\n        case \"eth_signTypedData_v4\":\n        case \"eth_signTypedData\": {\n          requestParams = args.params;\n          const signedTypedDataParams = JSON.parse(requestParams[1]);\n          response = await this.wallet.signTypedData({\n            account: requestParams[0],\n            domain: signedTypedDataParams.domain,\n            message: signedTypedDataParams.message,\n            primaryType: signedTypedDataParams.primaryType,\n            types: signedTypedDataParams.types\n          });\n          if (response.error) {\n            throw rpcErrors.transactionRejected(response.error);\n          } else {\n            response = response.hash;\n          }\n          break;\n        }\n        case \"eth_ecRecover\":\n        case \"eth_subscribe\":\n        case \"eth_unsubscribe\":\n        case \"personal_ecRecover\":\n        case \"eth_signTransaction\":\n        case \"wallet_watchAsset\":\n        case \"wallet_sendCalls\":\n        case \"wallet_getCallsStatus\":\n        case \"wallet_getCapabilities\":\n        case \"wallet_showCallsStatus\":\n        case \"wallet_grantPermissions\":\n          throw rpcErrors.methodNotSupported(\"Not yet implemented.\");\n        case \"eth_sign\":\n        case \"eth_coinbase\":\n        case \"wallet_addEthereumChain\":\n          throw rpcErrors.methodNotSupported();\n        default:\n          if (!this.wallet.chain.rpcUrl) {\n            throw rpcErrors.internal(`RPC URL missing for current chain (${this.wallet.chain.id})`);\n          }\n          return fetchRpcRequest(args, this.wallet.chain.rpcUrl);\n      }\n      return response;\n    } catch (error) {\n      const { code } = error;\n      if (code === errorCodes.provider.unauthorized) {\n        this.disconnect();\n      }\n      return Promise.reject(serializeError(error));\n    }\n  }\n  async openSettings() {\n    await this.wallet?.openSettings();\n  }\n  async reverseResolveEns(address) {\n    return await reverseResolveEns(address);\n  }\n  async disconnect() {\n    if (this.wallet) {\n      const storage = this.config.storage || new GeminiStorage;\n      await storage.removeItem(STORAGE_ETH_ACCOUNTS_KEY);\n      await storage.removeItem(STORAGE_ETH_ACTIVE_CHAIN_KEY);\n    }\n    this.wallet = undefined;\n    await this.emit(\"disconnect\", \"User initiated disconnection\");\n  }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdlbWluaS13YWxsZXQvY29yZS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GLDhCQUE4QjtBQUNsSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSx3REFBd0QsYUFBYTtBQUNyRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQW1CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsWUFBWTtBQUMzQyxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMseUJBQXlCO0FBQ3ZDO0FBQ0EsdUJBQXVCLFdBQVc7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHVCQUF1QjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsc0NBQXNDO0FBQ3BELFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsY0FBYztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFlBQVk7QUFDakM7QUFDQTtBQUNBO0FBQ0EsY0FBYyxvQkFBb0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMscURBQXFEO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMseUJBQXlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFFBQVE7QUFDN0I7QUFDQSxzQkFBc0IsUUFBUTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHlCQUF5QjtBQUNyQyxxQkFBcUIsUUFBUTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0IsdURBQXVELFFBQVEsMkNBQTJDLDZCQUE2QjtBQUN2STtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0NBQWdDO0FBQzVDLFlBQVksT0FBTztBQUNuQiw0REFBNEQsZ0JBQWdCLEtBQUssUUFBUTtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsTUFBTTtBQUN0RTtBQUNBO0FBQ0EsVUFBVSxjQUFjO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0osZUFBZTtBQUNmO0FBQ0EsVUFBVSxlQUFlO0FBQ3pCLFVBQVUsT0FBTztBQUNqQixVQUFVLG9EQUFvRCxLQUFLLElBQUksbUNBQW1DLFdBQVcsU0FBUyxvQkFBb0IsYUFBYSxNQUFNO0FBQ3JLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDLFVBQVUsNERBQTREO0FBQ3RFLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSwwRkFBMEY7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixXQUFXO0FBQ3pDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxTQUFTO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsdUJBQXVCO0FBQ2xFO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsbUNBQW1DO0FBQzlFO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQixxQ0FBcUM7QUFDM0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsK0VBQStFLGFBQWE7QUFDNUY7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsMEhBQTBILGFBQWE7QUFDdkksR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsWUFBWSxvQkFBb0IsYUFBYTtBQUMxRztBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsNkZBQTZGLGFBQWE7QUFDMUcsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EscUVBQXFFLGFBQWE7QUFDbEYsS0FBSztBQUNMO0FBQ0EsaUNBQWlDLFdBQVc7QUFDNUM7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EscUVBQXFFLGFBQWE7QUFDbEY7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLGFBQWE7QUFDekYsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsY0FBYztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxZQUFZLG9CQUFvQixhQUFhO0FBQ25HO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHVDQUF1QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QixjQUFjO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixZQUFZO0FBQ2xDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixvQkFBb0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQywwRkFBMEYsSUFBSTtBQUMvSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELDBCQUEwQjtBQUMvRSxZQUFZO0FBQ1o7QUFDQTtB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Q0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDRDQUE0QztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw0Q0FBNEM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0RBQW9EO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwwQ0FBMEM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwwQ0FBMEM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0RBQW9EO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxtQkFBbUIsdURBQXVEO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxZQUFZLFdBQVcsUUFBUTtBQUNuRTtBQUNBLGlEQUFpRCxpQkFBaUIsRUFBRSxvQkFBb0I7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsb0JBQW9CO0FBQ3ZELG1EQUFtRCxZQUFZLFdBQVcsYUFBYSxTQUFTLEtBQUssUUFBUSxJQUFJO0FBQ2pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qyx5QkFBeUI7QUFDakU7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQ0FBbUM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFdBQVc7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsUUFBUTtBQUM3QyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsUUFBUTtBQUN0QztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsT0FBTywwR0FBMEc7QUFDdkksc0JBQXNCLE9BQU87QUFDN0I7QUFDQTtBQUNBLEtBQUssZ0JBQWdCO0FBQ3JCLDZCQUE2QixPQUFPO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxXQUFXLEdBQUcsWUFBWSxHQUFHLElBQUk7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sa0RBQWtELElBQUk7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNILFVBQVUsZ0JBQWdCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLFVBQVUsaUJBQWlCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1osa0ZBQWtGLHFCQUFxQixPQUFPLFlBQVk7QUFDMUg7QUFDQSxxREFBcUQsYUFBYTtBQUNsRTtBQUNBLDBDQUEwQywrQkFBK0I7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLHFCQUFxQjtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFtQ0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9iaXRsZWFzZS1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AZ2VtaW5pLXdhbGxldC9jb3JlL2Rpc3QvaW5kZXguanM/ODg2NyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19jcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xudmFyIF9fZ2V0UHJvdG9PZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fdG9FU00gPSAobW9kLCBpc05vZGVNb2RlLCB0YXJnZXQpID0+IHtcbiAgdGFyZ2V0ID0gbW9kICE9IG51bGwgPyBfX2NyZWF0ZShfX2dldFByb3RvT2YobW9kKSkgOiB7fTtcbiAgY29uc3QgdG8gPSBpc05vZGVNb2RlIHx8ICFtb2QgfHwgIW1vZC5fX2VzTW9kdWxlID8gX19kZWZQcm9wKHRhcmdldCwgXCJkZWZhdWx0XCIsIHsgdmFsdWU6IG1vZCwgZW51bWVyYWJsZTogdHJ1ZSB9KSA6IHRhcmdldDtcbiAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKG1vZCkpXG4gICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSlcbiAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7XG4gICAgICAgIGdldDogKCkgPT4gbW9kW2tleV0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgIH0pO1xuICByZXR1cm4gdG87XG59O1xudmFyIF9fY29tbW9uSlMgPSAoY2IsIG1vZCkgPT4gKCkgPT4gKG1vZCB8fCBjYigobW9kID0geyBleHBvcnRzOiB7fSB9KS5leHBvcnRzLCBtb2QpLCBtb2QuZXhwb3J0cyk7XG52YXIgX19lc20gPSAoZm4sIHJlcykgPT4gKCkgPT4gKGZuICYmIChyZXMgPSBmbihmbiA9IDApKSwgcmVzKTtcblxuLy8gbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL191NjQuanNcbmZ1bmN0aW9uIGZyb21CaWcobiwgbGUgPSBmYWxzZSkge1xuICBpZiAobGUpXG4gICAgcmV0dXJuIHsgaDogTnVtYmVyKG4gJiBVMzJfTUFTSzY0KSwgbDogTnVtYmVyKG4gPj4gXzMybiAmIFUzMl9NQVNLNjQpIH07XG4gIHJldHVybiB7IGg6IE51bWJlcihuID4+IF8zMm4gJiBVMzJfTUFTSzY0KSB8IDAsIGw6IE51bWJlcihuICYgVTMyX01BU0s2NCkgfCAwIH07XG59XG5mdW5jdGlvbiBzcGxpdChsc3QsIGxlID0gZmFsc2UpIHtcbiAgY29uc3QgbGVuID0gbHN0Lmxlbmd0aDtcbiAgbGV0IEFoID0gbmV3IFVpbnQzMkFycmF5KGxlbik7XG4gIGxldCBBbCA9IG5ldyBVaW50MzJBcnJheShsZW4pO1xuICBmb3IgKGxldCBpID0gMDtpIDwgbGVuOyBpKyspIHtcbiAgICBjb25zdCB7IGgsIGwgfSA9IGZyb21CaWcobHN0W2ldLCBsZSk7XG4gICAgW0FoW2ldLCBBbFtpXV0gPSBbaCwgbF07XG4gIH1cbiAgcmV0dXJuIFtBaCwgQWxdO1xufVxudmFyIFUzMl9NQVNLNjQsIF8zMm4sIHJvdGxTSCA9IChoLCBsLCBzKSA9PiBoIDw8IHMgfCBsID4+PiAzMiAtIHMsIHJvdGxTTCA9IChoLCBsLCBzKSA9PiBsIDw8IHMgfCBoID4+PiAzMiAtIHMsIHJvdGxCSCA9IChoLCBsLCBzKSA9PiBsIDw8IHMgLSAzMiB8IGggPj4+IDY0IC0gcywgcm90bEJMID0gKGgsIGwsIHMpID0+IGggPDwgcyAtIDMyIHwgbCA+Pj4gNjQgLSBzO1xudmFyIGluaXRfX3U2NCA9IF9fZXNtKCgpID0+IHtcbiAgVTMyX01BU0s2NCA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMiAqKiAzMiAtIDEpO1xuICBfMzJuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgzMik7XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3V0aWxzLmpzXG5mdW5jdGlvbiBpc0J5dGVzKGEpIHtcbiAgcmV0dXJuIGEgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8IEFycmF5QnVmZmVyLmlzVmlldyhhKSAmJiBhLmNvbnN0cnVjdG9yLm5hbWUgPT09IFwiVWludDhBcnJheVwiO1xufVxuZnVuY3Rpb24gYW51bWJlcihuKSB7XG4gIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIobikgfHwgbiA8IDApXG4gICAgdGhyb3cgbmV3IEVycm9yKFwicG9zaXRpdmUgaW50ZWdlciBleHBlY3RlZCwgZ290IFwiICsgbik7XG59XG5mdW5jdGlvbiBhYnl0ZXMoYiwgLi4ubGVuZ3Rocykge1xuICBpZiAoIWlzQnl0ZXMoYikpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVWludDhBcnJheSBleHBlY3RlZFwiKTtcbiAgaWYgKGxlbmd0aHMubGVuZ3RoID4gMCAmJiAhbGVuZ3Rocy5pbmNsdWRlcyhiLmxlbmd0aCkpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVWludDhBcnJheSBleHBlY3RlZCBvZiBsZW5ndGggXCIgKyBsZW5ndGhzICsgXCIsIGdvdCBsZW5ndGg9XCIgKyBiLmxlbmd0aCk7XG59XG5mdW5jdGlvbiBhZXhpc3RzKGluc3RhbmNlLCBjaGVja0ZpbmlzaGVkID0gdHJ1ZSkge1xuICBpZiAoaW5zdGFuY2UuZGVzdHJveWVkKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkhhc2ggaW5zdGFuY2UgaGFzIGJlZW4gZGVzdHJveWVkXCIpO1xuICBpZiAoY2hlY2tGaW5pc2hlZCAmJiBpbnN0YW5jZS5maW5pc2hlZClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJIYXNoI2RpZ2VzdCgpIGhhcyBhbHJlYWR5IGJlZW4gY2FsbGVkXCIpO1xufVxuZnVuY3Rpb24gYW91dHB1dChvdXQsIGluc3RhbmNlKSB7XG4gIGFieXRlcyhvdXQpO1xuICBjb25zdCBtaW4gPSBpbnN0YW5jZS5vdXRwdXRMZW47XG4gIGlmIChvdXQubGVuZ3RoIDwgbWluKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZGlnZXN0SW50bygpIGV4cGVjdHMgb3V0cHV0IGJ1ZmZlciBvZiBsZW5ndGggYXQgbGVhc3QgXCIgKyBtaW4pO1xuICB9XG59XG5mdW5jdGlvbiB1MzIoYXJyKSB7XG4gIHJldHVybiBuZXcgVWludDMyQXJyYXkoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIE1hdGguZmxvb3IoYXJyLmJ5dGVMZW5ndGggLyA0KSk7XG59XG5mdW5jdGlvbiBjbGVhbiguLi5hcnJheXMpIHtcbiAgZm9yIChsZXQgaSA9IDA7aSA8IGFycmF5cy5sZW5ndGg7IGkrKykge1xuICAgIGFycmF5c1tpXS5maWxsKDApO1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVWaWV3KGFycikge1xuICByZXR1cm4gbmV3IERhdGFWaWV3KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBhcnIuYnl0ZUxlbmd0aCk7XG59XG5mdW5jdGlvbiByb3RyKHdvcmQsIHNoaWZ0KSB7XG4gIHJldHVybiB3b3JkIDw8IDMyIC0gc2hpZnQgfCB3b3JkID4+PiBzaGlmdDtcbn1cbmZ1bmN0aW9uIGJ5dGVTd2FwKHdvcmQpIHtcbiAgcmV0dXJuIHdvcmQgPDwgMjQgJiA0Mjc4MTkwMDgwIHwgd29yZCA8PCA4ICYgMTY3MTE2ODAgfCB3b3JkID4+PiA4ICYgNjUyODAgfCB3b3JkID4+PiAyNCAmIDI1NTtcbn1cbmZ1bmN0aW9uIGJ5dGVTd2FwMzIoYXJyKSB7XG4gIGZvciAobGV0IGkgPSAwO2kgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBhcnJbaV0gPSBieXRlU3dhcChhcnJbaV0pO1xuICB9XG4gIHJldHVybiBhcnI7XG59XG5mdW5jdGlvbiB1dGY4VG9CeXRlcyhzdHIpIHtcbiAgaWYgKHR5cGVvZiBzdHIgIT09IFwic3RyaW5nXCIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwic3RyaW5nIGV4cGVjdGVkXCIpO1xuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHN0cikpO1xufVxuZnVuY3Rpb24gdG9CeXRlcyhkYXRhKSB7XG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIilcbiAgICBkYXRhID0gdXRmOFRvQnl0ZXMoZGF0YSk7XG4gIGFieXRlcyhkYXRhKTtcbiAgcmV0dXJuIGRhdGE7XG59XG5cbmNsYXNzIEhhc2gge1xufVxuZnVuY3Rpb24gY3JlYXRlSGFzaGVyKGhhc2hDb25zKSB7XG4gIGNvbnN0IGhhc2hDID0gKG1zZykgPT4gaGFzaENvbnMoKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgY29uc3QgdG1wID0gaGFzaENvbnMoKTtcbiAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gIGhhc2hDLmNyZWF0ZSA9ICgpID0+IGhhc2hDb25zKCk7XG4gIHJldHVybiBoYXNoQztcbn1cbnZhciBpc0xFLCBzd2FwMzJJZkJFO1xudmFyIGluaXRfdXRpbHMgPSBfX2VzbSgoKSA9PiB7XG4gIC8qISBub2JsZS1oYXNoZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbiAgaXNMRSA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gbmV3IFVpbnQ4QXJyYXkobmV3IFVpbnQzMkFycmF5KFsyODc0NTQwMjBdKS5idWZmZXIpWzBdID09PSA2OCkoKTtcbiAgc3dhcDMySWZCRSA9IGlzTEUgPyAodSkgPT4gdSA6IGJ5dGVTd2FwMzI7XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3NoYTMuanNcbmZ1bmN0aW9uIGtlY2Nha1Aocywgcm91bmRzID0gMjQpIHtcbiAgY29uc3QgQiA9IG5ldyBVaW50MzJBcnJheSg1ICogMik7XG4gIGZvciAobGV0IHJvdW5kID0gMjQgLSByb3VuZHM7cm91bmQgPCAyNDsgcm91bmQrKykge1xuICAgIGZvciAobGV0IHggPSAwO3ggPCAxMDsgeCsrKVxuICAgICAgQlt4XSA9IHNbeF0gXiBzW3ggKyAxMF0gXiBzW3ggKyAyMF0gXiBzW3ggKyAzMF0gXiBzW3ggKyA0MF07XG4gICAgZm9yIChsZXQgeCA9IDA7eCA8IDEwOyB4ICs9IDIpIHtcbiAgICAgIGNvbnN0IGlkeDEgPSAoeCArIDgpICUgMTA7XG4gICAgICBjb25zdCBpZHgwID0gKHggKyAyKSAlIDEwO1xuICAgICAgY29uc3QgQjAgPSBCW2lkeDBdO1xuICAgICAgY29uc3QgQjEgPSBCW2lkeDAgKyAxXTtcbiAgICAgIGNvbnN0IFRoID0gcm90bEgoQjAsIEIxLCAxKSBeIEJbaWR4MV07XG4gICAgICBjb25zdCBUbCA9IHJvdGxMKEIwLCBCMSwgMSkgXiBCW2lkeDEgKyAxXTtcbiAgICAgIGZvciAobGV0IHkgPSAwO3kgPCA1MDsgeSArPSAxMCkge1xuICAgICAgICBzW3ggKyB5XSBePSBUaDtcbiAgICAgICAgc1t4ICsgeSArIDFdIF49IFRsO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgY3VySCA9IHNbMl07XG4gICAgbGV0IGN1ckwgPSBzWzNdO1xuICAgIGZvciAobGV0IHQgPSAwO3QgPCAyNDsgdCsrKSB7XG4gICAgICBjb25zdCBzaGlmdCA9IFNIQTNfUk9UTFt0XTtcbiAgICAgIGNvbnN0IFRoID0gcm90bEgoY3VySCwgY3VyTCwgc2hpZnQpO1xuICAgICAgY29uc3QgVGwgPSByb3RsTChjdXJILCBjdXJMLCBzaGlmdCk7XG4gICAgICBjb25zdCBQSSA9IFNIQTNfUElbdF07XG4gICAgICBjdXJIID0gc1tQSV07XG4gICAgICBjdXJMID0gc1tQSSArIDFdO1xuICAgICAgc1tQSV0gPSBUaDtcbiAgICAgIHNbUEkgKyAxXSA9IFRsO1xuICAgIH1cbiAgICBmb3IgKGxldCB5ID0gMDt5IDwgNTA7IHkgKz0gMTApIHtcbiAgICAgIGZvciAobGV0IHggPSAwO3ggPCAxMDsgeCsrKVxuICAgICAgICBCW3hdID0gc1t5ICsgeF07XG4gICAgICBmb3IgKGxldCB4ID0gMDt4IDwgMTA7IHgrKylcbiAgICAgICAgc1t5ICsgeF0gXj0gfkJbKHggKyAyKSAlIDEwXSAmIEJbKHggKyA0KSAlIDEwXTtcbiAgICB9XG4gICAgc1swXSBePSBTSEEzX0lPVEFfSFtyb3VuZF07XG4gICAgc1sxXSBePSBTSEEzX0lPVEFfTFtyb3VuZF07XG4gIH1cbiAgY2xlYW4oQik7XG59XG52YXIgXzBuLCBfMW4sIF8ybiwgXzduLCBfMjU2biwgXzB4NzFuLCBTSEEzX1BJLCBTSEEzX1JPVEwsIF9TSEEzX0lPVEEsIElPVEFTLCBTSEEzX0lPVEFfSCwgU0hBM19JT1RBX0wsIHJvdGxIID0gKGgsIGwsIHMpID0+IHMgPiAzMiA/IHJvdGxCSChoLCBsLCBzKSA6IHJvdGxTSChoLCBsLCBzKSwgcm90bEwgPSAoaCwgbCwgcykgPT4gcyA+IDMyID8gcm90bEJMKGgsIGwsIHMpIDogcm90bFNMKGgsIGwsIHMpLCBLZWNjYWssIGdlbiA9IChzdWZmaXgsIGJsb2NrTGVuLCBvdXRwdXRMZW4pID0+IGNyZWF0ZUhhc2hlcigoKSA9PiBuZXcgS2VjY2FrKGJsb2NrTGVuLCBzdWZmaXgsIG91dHB1dExlbikpLCBrZWNjYWtfMjU2O1xudmFyIGluaXRfc2hhMyA9IF9fZXNtKCgpID0+IHtcbiAgaW5pdF9fdTY0KCk7XG4gIGluaXRfdXRpbHMoKTtcbiAgXzBuID0gQmlnSW50KDApO1xuICBfMW4gPSBCaWdJbnQoMSk7XG4gIF8ybiA9IEJpZ0ludCgyKTtcbiAgXzduID0gQmlnSW50KDcpO1xuICBfMjU2biA9IEJpZ0ludCgyNTYpO1xuICBfMHg3MW4gPSBCaWdJbnQoMTEzKTtcbiAgU0hBM19QSSA9IFtdO1xuICBTSEEzX1JPVEwgPSBbXTtcbiAgX1NIQTNfSU9UQSA9IFtdO1xuICBmb3IgKGxldCByb3VuZCA9IDAsIFIgPSBfMW4sIHggPSAxLCB5ID0gMDtyb3VuZCA8IDI0OyByb3VuZCsrKSB7XG4gICAgW3gsIHldID0gW3ksICgyICogeCArIDMgKiB5KSAlIDVdO1xuICAgIFNIQTNfUEkucHVzaCgyICogKDUgKiB5ICsgeCkpO1xuICAgIFNIQTNfUk9UTC5wdXNoKChyb3VuZCArIDEpICogKHJvdW5kICsgMikgLyAyICUgNjQpO1xuICAgIGxldCB0ID0gXzBuO1xuICAgIGZvciAobGV0IGogPSAwO2ogPCA3OyBqKyspIHtcbiAgICAgIFIgPSAoUiA8PCBfMW4gXiAoUiA+PiBfN24pICogXzB4NzFuKSAlIF8yNTZuO1xuICAgICAgaWYgKFIgJiBfMm4pXG4gICAgICAgIHQgXj0gXzFuIDw8IChfMW4gPDwgLyogQF9fUFVSRV9fICovIEJpZ0ludChqKSkgLSBfMW47XG4gICAgfVxuICAgIF9TSEEzX0lPVEEucHVzaCh0KTtcbiAgfVxuICBJT1RBUyA9IHNwbGl0KF9TSEEzX0lPVEEsIHRydWUpO1xuICBTSEEzX0lPVEFfSCA9IElPVEFTWzBdO1xuICBTSEEzX0lPVEFfTCA9IElPVEFTWzFdO1xuICBLZWNjYWsgPSBjbGFzcyBLZWNjYWsgZXh0ZW5kcyBIYXNoIHtcbiAgICBjb25zdHJ1Y3RvcihibG9ja0xlbiwgc3VmZml4LCBvdXRwdXRMZW4sIGVuYWJsZVhPRiA9IGZhbHNlLCByb3VuZHMgPSAyNCkge1xuICAgICAgc3VwZXIoKTtcbiAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgIHRoaXMucG9zT3V0ID0gMDtcbiAgICAgIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICB0aGlzLmVuYWJsZVhPRiA9IGZhbHNlO1xuICAgICAgdGhpcy5ibG9ja0xlbiA9IGJsb2NrTGVuO1xuICAgICAgdGhpcy5zdWZmaXggPSBzdWZmaXg7XG4gICAgICB0aGlzLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgIHRoaXMuZW5hYmxlWE9GID0gZW5hYmxlWE9GO1xuICAgICAgdGhpcy5yb3VuZHMgPSByb3VuZHM7XG4gICAgICBhbnVtYmVyKG91dHB1dExlbik7XG4gICAgICBpZiAoISgwIDwgYmxvY2tMZW4gJiYgYmxvY2tMZW4gPCAyMDApKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvbmx5IGtlY2Nhay1mMTYwMCBmdW5jdGlvbiBpcyBzdXBwb3J0ZWRcIik7XG4gICAgICB0aGlzLnN0YXRlID0gbmV3IFVpbnQ4QXJyYXkoMjAwKTtcbiAgICAgIHRoaXMuc3RhdGUzMiA9IHUzMih0aGlzLnN0YXRlKTtcbiAgICB9XG4gICAgY2xvbmUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY2xvbmVJbnRvKCk7XG4gICAgfVxuICAgIGtlY2NhaygpIHtcbiAgICAgIHN3YXAzMklmQkUodGhpcy5zdGF0ZTMyKTtcbiAgICAgIGtlY2Nha1AodGhpcy5zdGF0ZTMyLCB0aGlzLnJvdW5kcyk7XG4gICAgICBzd2FwMzJJZkJFKHRoaXMuc3RhdGUzMik7XG4gICAgICB0aGlzLnBvc091dCA9IDA7XG4gICAgICB0aGlzLnBvcyA9IDA7XG4gICAgfVxuICAgIHVwZGF0ZShkYXRhKSB7XG4gICAgICBhZXhpc3RzKHRoaXMpO1xuICAgICAgZGF0YSA9IHRvQnl0ZXMoZGF0YSk7XG4gICAgICBhYnl0ZXMoZGF0YSk7XG4gICAgICBjb25zdCB7IGJsb2NrTGVuLCBzdGF0ZSB9ID0gdGhpcztcbiAgICAgIGNvbnN0IGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgZm9yIChsZXQgcG9zID0gMDtwb3MgPCBsZW47ICkge1xuICAgICAgICBjb25zdCB0YWtlID0gTWF0aC5taW4oYmxvY2tMZW4gLSB0aGlzLnBvcywgbGVuIC0gcG9zKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7aSA8IHRha2U7IGkrKylcbiAgICAgICAgICBzdGF0ZVt0aGlzLnBvcysrXSBePSBkYXRhW3BvcysrXTtcbiAgICAgICAgaWYgKHRoaXMucG9zID09PSBibG9ja0xlbilcbiAgICAgICAgICB0aGlzLmtlY2NhaygpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGZpbmlzaCgpIHtcbiAgICAgIGlmICh0aGlzLmZpbmlzaGVkKVxuICAgICAgICByZXR1cm47XG4gICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIGNvbnN0IHsgc3RhdGUsIHN1ZmZpeCwgcG9zLCBibG9ja0xlbiB9ID0gdGhpcztcbiAgICAgIHN0YXRlW3Bvc10gXj0gc3VmZml4O1xuICAgICAgaWYgKChzdWZmaXggJiAxMjgpICE9PSAwICYmIHBvcyA9PT0gYmxvY2tMZW4gLSAxKVxuICAgICAgICB0aGlzLmtlY2NhaygpO1xuICAgICAgc3RhdGVbYmxvY2tMZW4gLSAxXSBePSAxMjg7XG4gICAgICB0aGlzLmtlY2NhaygpO1xuICAgIH1cbiAgICB3cml0ZUludG8ob3V0KSB7XG4gICAgICBhZXhpc3RzKHRoaXMsIGZhbHNlKTtcbiAgICAgIGFieXRlcyhvdXQpO1xuICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgIGNvbnN0IGJ1ZmZlck91dCA9IHRoaXMuc3RhdGU7XG4gICAgICBjb25zdCB7IGJsb2NrTGVuIH0gPSB0aGlzO1xuICAgICAgZm9yIChsZXQgcG9zID0gMCwgbGVuID0gb3V0Lmxlbmd0aDtwb3MgPCBsZW47ICkge1xuICAgICAgICBpZiAodGhpcy5wb3NPdXQgPj0gYmxvY2tMZW4pXG4gICAgICAgICAgdGhpcy5rZWNjYWsoKTtcbiAgICAgICAgY29uc3QgdGFrZSA9IE1hdGgubWluKGJsb2NrTGVuIC0gdGhpcy5wb3NPdXQsIGxlbiAtIHBvcyk7XG4gICAgICAgIG91dC5zZXQoYnVmZmVyT3V0LnN1YmFycmF5KHRoaXMucG9zT3V0LCB0aGlzLnBvc091dCArIHRha2UpLCBwb3MpO1xuICAgICAgICB0aGlzLnBvc091dCArPSB0YWtlO1xuICAgICAgICBwb3MgKz0gdGFrZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIHhvZkludG8ob3V0KSB7XG4gICAgICBpZiAoIXRoaXMuZW5hYmxlWE9GKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJYT0YgaXMgbm90IHBvc3NpYmxlIGZvciB0aGlzIGluc3RhbmNlXCIpO1xuICAgICAgcmV0dXJuIHRoaXMud3JpdGVJbnRvKG91dCk7XG4gICAgfVxuICAgIHhvZihieXRlcykge1xuICAgICAgYW51bWJlcihieXRlcyk7XG4gICAgICByZXR1cm4gdGhpcy54b2ZJbnRvKG5ldyBVaW50OEFycmF5KGJ5dGVzKSk7XG4gICAgfVxuICAgIGRpZ2VzdEludG8ob3V0KSB7XG4gICAgICBhb3V0cHV0KG91dCwgdGhpcyk7XG4gICAgICBpZiAodGhpcy5maW5pc2hlZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZGlnZXN0KCkgd2FzIGFscmVhZHkgY2FsbGVkXCIpO1xuICAgICAgdGhpcy53cml0ZUludG8ob3V0KTtcbiAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgZGlnZXN0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuZGlnZXN0SW50byhuZXcgVWludDhBcnJheSh0aGlzLm91dHB1dExlbikpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgY2xlYW4odGhpcy5zdGF0ZSk7XG4gICAgfVxuICAgIF9jbG9uZUludG8odG8pIHtcbiAgICAgIGNvbnN0IHsgYmxvY2tMZW4sIHN1ZmZpeCwgb3V0cHV0TGVuLCByb3VuZHMsIGVuYWJsZVhPRiB9ID0gdGhpcztcbiAgICAgIHRvIHx8ICh0byA9IG5ldyBLZWNjYWsoYmxvY2tMZW4sIHN1ZmZpeCwgb3V0cHV0TGVuLCBlbmFibGVYT0YsIHJvdW5kcykpO1xuICAgICAgdG8uc3RhdGUzMi5zZXQodGhpcy5zdGF0ZTMyKTtcbiAgICAgIHRvLnBvcyA9IHRoaXMucG9zO1xuICAgICAgdG8ucG9zT3V0ID0gdGhpcy5wb3NPdXQ7XG4gICAgICB0by5maW5pc2hlZCA9IHRoaXMuZmluaXNoZWQ7XG4gICAgICB0by5yb3VuZHMgPSByb3VuZHM7XG4gICAgICB0by5zdWZmaXggPSBzdWZmaXg7XG4gICAgICB0by5vdXRwdXRMZW4gPSBvdXRwdXRMZW47XG4gICAgICB0by5lbmFibGVYT0YgPSBlbmFibGVYT0Y7XG4gICAgICB0by5kZXN0cm95ZWQgPSB0aGlzLmRlc3Ryb3llZDtcbiAgICAgIHJldHVybiB0bztcbiAgICB9XG4gIH07XG4gIGtlY2Nha18yNTYgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGdlbigxLCAxMzYsIDI1NiAvIDgpKSgpO1xufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9mYXN0LXNhZmUtc3RyaW5naWZ5L2luZGV4LmpzXG52YXIgcmVxdWlyZV9mYXN0X3NhZmVfc3RyaW5naWZ5ID0gX19jb21tb25KUygoZXhwb3J0cywgbW9kdWxlKSA9PiB7XG4gIG1vZHVsZS5leHBvcnRzID0gc3RyaW5naWZ5O1xuICBzdHJpbmdpZnkuZGVmYXVsdCA9IHN0cmluZ2lmeTtcbiAgc3RyaW5naWZ5LnN0YWJsZSA9IGRldGVybWluaXN0aWNTdHJpbmdpZnk7XG4gIHN0cmluZ2lmeS5zdGFibGVTdHJpbmdpZnkgPSBkZXRlcm1pbmlzdGljU3RyaW5naWZ5O1xuICB2YXIgTElNSVRfUkVQTEFDRV9OT0RFID0gXCJbLi4uXVwiO1xuICB2YXIgQ0lSQ1VMQVJfUkVQTEFDRV9OT0RFID0gXCJbQ2lyY3VsYXJdXCI7XG4gIHZhciBhcnIgPSBbXTtcbiAgdmFyIHJlcGxhY2VyU3RhY2sgPSBbXTtcbiAgZnVuY3Rpb24gZGVmYXVsdE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRlcHRoTGltaXQ6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSLFxuICAgICAgZWRnZXNMaW1pdDogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIHN0cmluZ2lmeShvYmosIHJlcGxhY2VyLCBzcGFjZXIsIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIG9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucygpO1xuICAgIH1cbiAgICBkZWNpcmMob2JqLCBcIlwiLCAwLCBbXSwgdW5kZWZpbmVkLCAwLCBvcHRpb25zKTtcbiAgICB2YXIgcmVzO1xuICAgIHRyeSB7XG4gICAgICBpZiAocmVwbGFjZXJTdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmVzID0gSlNPTi5zdHJpbmdpZnkob2JqLCByZXBsYWNlciwgc3BhY2VyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlcyA9IEpTT04uc3RyaW5naWZ5KG9iaiwgcmVwbGFjZUdldHRlclZhbHVlcyhyZXBsYWNlciksIHNwYWNlcik7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoXykge1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KFwiW3VuYWJsZSB0byBzZXJpYWxpemUsIGNpcmN1bGFyIHJlZmVyZW5jZSBpcyB0b28gY29tcGxleCB0byBhbmFseXplXVwiKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgd2hpbGUgKGFyci5sZW5ndGggIT09IDApIHtcbiAgICAgICAgdmFyIHBhcnQgPSBhcnIucG9wKCk7XG4gICAgICAgIGlmIChwYXJ0Lmxlbmd0aCA9PT0gNCkge1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwYXJ0WzBdLCBwYXJ0WzFdLCBwYXJ0WzNdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXJ0WzBdW3BhcnRbMV1dID0gcGFydFsyXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9XG4gIGZ1bmN0aW9uIHNldFJlcGxhY2UocmVwbGFjZSwgdmFsLCBrLCBwYXJlbnQpIHtcbiAgICB2YXIgcHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwYXJlbnQsIGspO1xuICAgIGlmIChwcm9wZXJ0eURlc2NyaXB0b3IuZ2V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChwcm9wZXJ0eURlc2NyaXB0b3IuY29uZmlndXJhYmxlKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwYXJlbnQsIGssIHsgdmFsdWU6IHJlcGxhY2UgfSk7XG4gICAgICAgIGFyci5wdXNoKFtwYXJlbnQsIGssIHZhbCwgcHJvcGVydHlEZXNjcmlwdG9yXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXBsYWNlclN0YWNrLnB1c2goW3ZhbCwgaywgcmVwbGFjZV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwYXJlbnRba10gPSByZXBsYWNlO1xuICAgICAgYXJyLnB1c2goW3BhcmVudCwgaywgdmFsXSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGRlY2lyYyh2YWwsIGssIGVkZ2VJbmRleCwgc3RhY2ssIHBhcmVudCwgZGVwdGgsIG9wdGlvbnMpIHtcbiAgICBkZXB0aCArPSAxO1xuICAgIHZhciBpO1xuICAgIGlmICh0eXBlb2YgdmFsID09PSBcIm9iamVjdFwiICYmIHZhbCAhPT0gbnVsbCkge1xuICAgICAgZm9yIChpID0gMDtpIDwgc3RhY2subGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHN0YWNrW2ldID09PSB2YWwpIHtcbiAgICAgICAgICBzZXRSZXBsYWNlKENJUkNVTEFSX1JFUExBQ0VfTk9ERSwgdmFsLCBrLCBwYXJlbnQpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlcHRoTGltaXQgIT09IFwidW5kZWZpbmVkXCIgJiYgZGVwdGggPiBvcHRpb25zLmRlcHRoTGltaXQpIHtcbiAgICAgICAgc2V0UmVwbGFjZShMSU1JVF9SRVBMQUNFX05PREUsIHZhbCwgaywgcGFyZW50KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmVkZ2VzTGltaXQgIT09IFwidW5kZWZpbmVkXCIgJiYgZWRnZUluZGV4ICsgMSA+IG9wdGlvbnMuZWRnZXNMaW1pdCkge1xuICAgICAgICBzZXRSZXBsYWNlKExJTUlUX1JFUExBQ0VfTk9ERSwgdmFsLCBrLCBwYXJlbnQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzdGFjay5wdXNoKHZhbCk7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgIGZvciAoaSA9IDA7aSA8IHZhbC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGRlY2lyYyh2YWxbaV0sIGksIGksIHN0YWNrLCB2YWwsIGRlcHRoLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICAgICAgICBmb3IgKGkgPSAwO2kgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgZGVjaXJjKHZhbFtrZXldLCBrZXksIGksIHN0YWNrLCB2YWwsIGRlcHRoLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3RhY2sucG9wKCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGNvbXBhcmVGdW5jdGlvbihhLCBiKSB7XG4gICAgaWYgKGEgPCBiKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGlmIChhID4gYikge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG4gIGZ1bmN0aW9uIGRldGVybWluaXN0aWNTdHJpbmdpZnkob2JqLCByZXBsYWNlciwgc3BhY2VyLCBvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBvcHRpb25zID0gZGVmYXVsdE9wdGlvbnMoKTtcbiAgICB9XG4gICAgdmFyIHRtcCA9IGRldGVybWluaXN0aWNEZWNpcmMob2JqLCBcIlwiLCAwLCBbXSwgdW5kZWZpbmVkLCAwLCBvcHRpb25zKSB8fCBvYmo7XG4gICAgdmFyIHJlcztcbiAgICB0cnkge1xuICAgICAgaWYgKHJlcGxhY2VyU3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJlcyA9IEpTT04uc3RyaW5naWZ5KHRtcCwgcmVwbGFjZXIsIHNwYWNlcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXMgPSBKU09OLnN0cmluZ2lmeSh0bXAsIHJlcGxhY2VHZXR0ZXJWYWx1ZXMocmVwbGFjZXIpLCBzcGFjZXIpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShcIlt1bmFibGUgdG8gc2VyaWFsaXplLCBjaXJjdWxhciByZWZlcmVuY2UgaXMgdG9vIGNvbXBsZXggdG8gYW5hbHl6ZV1cIik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHdoaWxlIChhcnIubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gYXJyLnBvcCgpO1xuICAgICAgICBpZiAocGFydC5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocGFydFswXSwgcGFydFsxXSwgcGFydFszXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFydFswXVtwYXJ0WzFdXSA9IHBhcnRbMl07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuICBmdW5jdGlvbiBkZXRlcm1pbmlzdGljRGVjaXJjKHZhbCwgaywgZWRnZUluZGV4LCBzdGFjaywgcGFyZW50LCBkZXB0aCwgb3B0aW9ucykge1xuICAgIGRlcHRoICs9IDE7XG4gICAgdmFyIGk7XG4gICAgaWYgKHR5cGVvZiB2YWwgPT09IFwib2JqZWN0XCIgJiYgdmFsICE9PSBudWxsKSB7XG4gICAgICBmb3IgKGkgPSAwO2kgPCBzdGFjay5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoc3RhY2tbaV0gPT09IHZhbCkge1xuICAgICAgICAgIHNldFJlcGxhY2UoQ0lSQ1VMQVJfUkVQTEFDRV9OT0RFLCB2YWwsIGssIHBhcmVudCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbC50b0pTT04gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVwdGhMaW1pdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkZXB0aCA+IG9wdGlvbnMuZGVwdGhMaW1pdCkge1xuICAgICAgICBzZXRSZXBsYWNlKExJTUlUX1JFUExBQ0VfTk9ERSwgdmFsLCBrLCBwYXJlbnQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMuZWRnZXNMaW1pdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBlZGdlSW5kZXggKyAxID4gb3B0aW9ucy5lZGdlc0xpbWl0KSB7XG4gICAgICAgIHNldFJlcGxhY2UoTElNSVRfUkVQTEFDRV9OT0RFLCB2YWwsIGssIHBhcmVudCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHN0YWNrLnB1c2godmFsKTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAgZm9yIChpID0gMDtpIDwgdmFsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgZGV0ZXJtaW5pc3RpY0RlY2lyYyh2YWxbaV0sIGksIGksIHN0YWNrLCB2YWwsIGRlcHRoLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHRtcCA9IHt9O1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbCkuc29ydChjb21wYXJlRnVuY3Rpb24pO1xuICAgICAgICBmb3IgKGkgPSAwO2kgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgZGV0ZXJtaW5pc3RpY0RlY2lyYyh2YWxba2V5XSwga2V5LCBpLCBzdGFjaywgdmFsLCBkZXB0aCwgb3B0aW9ucyk7XG4gICAgICAgICAgdG1wW2tleV0gPSB2YWxba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHBhcmVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIGFyci5wdXNoKFtwYXJlbnQsIGssIHZhbF0pO1xuICAgICAgICAgIHBhcmVudFtrXSA9IHRtcDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdG1wO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzdGFjay5wb3AoKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcmVwbGFjZUdldHRlclZhbHVlcyhyZXBsYWNlcikge1xuICAgIHJlcGxhY2VyID0gdHlwZW9mIHJlcGxhY2VyICE9PSBcInVuZGVmaW5lZFwiID8gcmVwbGFjZXIgOiBmdW5jdGlvbihrLCB2KSB7XG4gICAgICByZXR1cm4gdjtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbihrZXksIHZhbCkge1xuICAgICAgaWYgKHJlcGxhY2VyU3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDtpIDwgcmVwbGFjZXJTdGFjay5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBwYXJ0ID0gcmVwbGFjZXJTdGFja1tpXTtcbiAgICAgICAgICBpZiAocGFydFsxXSA9PT0ga2V5ICYmIHBhcnRbMF0gPT09IHZhbCkge1xuICAgICAgICAgICAgdmFsID0gcGFydFsyXTtcbiAgICAgICAgICAgIHJlcGxhY2VyU3RhY2suc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVwbGFjZXIuY2FsbCh0aGlzLCBrZXksIHZhbCk7XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9ldmVudGVtaXR0ZXIzL2luZGV4LmpzXG52YXIgcmVxdWlyZV9ldmVudGVtaXR0ZXIzID0gX19jb21tb25KUygoZXhwb3J0cywgbW9kdWxlKSA9PiB7XG4gIHZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuICB2YXIgcHJlZml4ID0gXCJ+XCI7XG4gIGZ1bmN0aW9uIEV2ZW50cygpIHt9XG4gIGlmIChPYmplY3QuY3JlYXRlKSB7XG4gICAgRXZlbnRzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgaWYgKCFuZXcgRXZlbnRzKCkuX19wcm90b19fKVxuICAgICAgcHJlZml4ID0gZmFsc2U7XG4gIH1cbiAgZnVuY3Rpb24gRUUoZm4sIGNvbnRleHQsIG9uY2UpIHtcbiAgICB0aGlzLmZuID0gZm47XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLm9uY2UgPSBvbmNlIHx8IGZhbHNlO1xuICB9XG4gIGZ1bmN0aW9uIGFkZExpc3RlbmVyKGVtaXR0ZXIsIGV2ZW50LCBmbiwgY29udGV4dCwgb25jZSkge1xuICAgIGlmICh0eXBlb2YgZm4gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZSBsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG4gICAgfVxuICAgIHZhciBsaXN0ZW5lciA9IG5ldyBFRShmbiwgY29udGV4dCB8fCBlbWl0dGVyLCBvbmNlKSwgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcbiAgICBpZiAoIWVtaXR0ZXIuX2V2ZW50c1tldnRdKVxuICAgICAgZW1pdHRlci5fZXZlbnRzW2V2dF0gPSBsaXN0ZW5lciwgZW1pdHRlci5fZXZlbnRzQ291bnQrKztcbiAgICBlbHNlIGlmICghZW1pdHRlci5fZXZlbnRzW2V2dF0uZm4pXG4gICAgICBlbWl0dGVyLl9ldmVudHNbZXZ0XS5wdXNoKGxpc3RlbmVyKTtcbiAgICBlbHNlXG4gICAgICBlbWl0dGVyLl9ldmVudHNbZXZ0XSA9IFtlbWl0dGVyLl9ldmVudHNbZXZ0XSwgbGlzdGVuZXJdO1xuICAgIHJldHVybiBlbWl0dGVyO1xuICB9XG4gIGZ1bmN0aW9uIGNsZWFyRXZlbnQoZW1pdHRlciwgZXZ0KSB7XG4gICAgaWYgKC0tZW1pdHRlci5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICBlbWl0dGVyLl9ldmVudHMgPSBuZXcgRXZlbnRzO1xuICAgIGVsc2VcbiAgICAgIGRlbGV0ZSBlbWl0dGVyLl9ldmVudHNbZXZ0XTtcbiAgfVxuICBmdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gICAgdGhpcy5fZXZlbnRzID0gbmV3IEV2ZW50cztcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gIH1cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgICB2YXIgbmFtZXMgPSBbXSwgZXZlbnRzLCBuYW1lO1xuICAgIGlmICh0aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgIHJldHVybiBuYW1lcztcbiAgICBmb3IgKG5hbWUgaW4gZXZlbnRzID0gdGhpcy5fZXZlbnRzKSB7XG4gICAgICBpZiAoaGFzLmNhbGwoZXZlbnRzLCBuYW1lKSlcbiAgICAgICAgbmFtZXMucHVzaChwcmVmaXggPyBuYW1lLnNsaWNlKDEpIDogbmFtZSk7XG4gICAgfVxuICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgICByZXR1cm4gbmFtZXMuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZXZlbnRzKSk7XG4gICAgfVxuICAgIHJldHVybiBuYW1lcztcbiAgfTtcbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnMoZXZlbnQpIHtcbiAgICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudCwgaGFuZGxlcnMgPSB0aGlzLl9ldmVudHNbZXZ0XTtcbiAgICBpZiAoIWhhbmRsZXJzKVxuICAgICAgcmV0dXJuIFtdO1xuICAgIGlmIChoYW5kbGVycy5mbilcbiAgICAgIHJldHVybiBbaGFuZGxlcnMuZm5dO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gaGFuZGxlcnMubGVuZ3RoLCBlZSA9IG5ldyBBcnJheShsKTtpIDwgbDsgaSsrKSB7XG4gICAgICBlZVtpXSA9IGhhbmRsZXJzW2ldLmZuO1xuICAgIH1cbiAgICByZXR1cm4gZWU7XG4gIH07XG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uIGxpc3RlbmVyQ291bnQoZXZlbnQpIHtcbiAgICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudCwgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW2V2dF07XG4gICAgaWYgKCFsaXN0ZW5lcnMpXG4gICAgICByZXR1cm4gMDtcbiAgICBpZiAobGlzdGVuZXJzLmZuKVxuICAgICAgcmV0dXJuIDE7XG4gICAgcmV0dXJuIGxpc3RlbmVycy5sZW5ndGg7XG4gIH07XG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQoZXZlbnQsIGExLCBhMiwgYTMsIGE0LCBhNSkge1xuICAgIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuICAgIGlmICghdGhpcy5fZXZlbnRzW2V2dF0pXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzLCBpO1xuICAgIGlmIChsaXN0ZW5lcnMuZm4pIHtcbiAgICAgIGlmIChsaXN0ZW5lcnMub25jZSlcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXJzLmZuLCB1bmRlZmluZWQsIHRydWUpO1xuICAgICAgc3dpdGNoIChsZW4pIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCksIHRydWU7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExKSwgdHJ1ZTtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyKSwgdHJ1ZTtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMyksIHRydWU7XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMsIGE0KSwgdHJ1ZTtcbiAgICAgICAgY2FzZSA2OlxuICAgICAgICAgIHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMywgYTQsIGE1KSwgdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDEsIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0gMSk7aSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgfVxuICAgICAgbGlzdGVuZXJzLmZuLmFwcGx5KGxpc3RlbmVycy5jb250ZXh0LCBhcmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGxlbmd0aCA9IGxpc3RlbmVycy5sZW5ndGgsIGo7XG4gICAgICBmb3IgKGkgPSAwO2kgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAobGlzdGVuZXJzW2ldLm9uY2UpXG4gICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXJzW2ldLmZuLCB1bmRlZmluZWQsIHRydWUpO1xuICAgICAgICBzd2l0Y2ggKGxlbikge1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEsIGEyKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSwgYTIsIGEzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBpZiAoIWFyZ3MpXG4gICAgICAgICAgICAgIGZvciAoaiA9IDEsIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0gMSk7aiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tqIC0gMV0gPSBhcmd1bWVudHNbal07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpc3RlbmVyc1tpXS5mbi5hcHBseShsaXN0ZW5lcnNbaV0uY29udGV4dCwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBmdW5jdGlvbiBvbihldmVudCwgZm4sIGNvbnRleHQpIHtcbiAgICByZXR1cm4gYWRkTGlzdGVuZXIodGhpcywgZXZlbnQsIGZuLCBjb250ZXh0LCBmYWxzZSk7XG4gIH07XG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UoZXZlbnQsIGZuLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIGFkZExpc3RlbmVyKHRoaXMsIGV2ZW50LCBmbiwgY29udGV4dCwgdHJ1ZSk7XG4gIH07XG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcihldmVudCwgZm4sIGNvbnRleHQsIG9uY2UpIHtcbiAgICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcbiAgICBpZiAoIXRoaXMuX2V2ZW50c1tldnRdKVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgaWYgKCFmbikge1xuICAgICAgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XTtcbiAgICBpZiAobGlzdGVuZXJzLmZuKSB7XG4gICAgICBpZiAobGlzdGVuZXJzLmZuID09PSBmbiAmJiAoIW9uY2UgfHwgbGlzdGVuZXJzLm9uY2UpICYmICghY29udGV4dCB8fCBsaXN0ZW5lcnMuY29udGV4dCA9PT0gY29udGV4dCkpIHtcbiAgICAgICAgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgZXZlbnRzID0gW10sIGxlbmd0aCA9IGxpc3RlbmVycy5sZW5ndGg7aSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChsaXN0ZW5lcnNbaV0uZm4gIT09IGZuIHx8IG9uY2UgJiYgIWxpc3RlbmVyc1tpXS5vbmNlIHx8IGNvbnRleHQgJiYgbGlzdGVuZXJzW2ldLmNvbnRleHQgIT09IGNvbnRleHQpIHtcbiAgICAgICAgICBldmVudHMucHVzaChsaXN0ZW5lcnNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZXZlbnRzLmxlbmd0aClcbiAgICAgICAgdGhpcy5fZXZlbnRzW2V2dF0gPSBldmVudHMubGVuZ3RoID09PSAxID8gZXZlbnRzWzBdIDogZXZlbnRzO1xuICAgICAgZWxzZVxuICAgICAgICBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyhldmVudCkge1xuICAgIHZhciBldnQ7XG4gICAgaWYgKGV2ZW50KSB7XG4gICAgICBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuICAgICAgaWYgKHRoaXMuX2V2ZW50c1tldnRdKVxuICAgICAgICBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudHM7XG4gICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7XG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uO1xuICBFdmVudEVtaXR0ZXIucHJlZml4ZWQgPSBwcmVmaXg7XG4gIEV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG4gIGlmICh0eXBlb2YgbW9kdWxlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYWJpdHlwZS9kaXN0L2VzbS9yZWdleC5qc1xuZnVuY3Rpb24gZXhlY1R5cGVkKHJlZ2V4LCBzdHJpbmcyKSB7XG4gIGNvbnN0IG1hdGNoID0gcmVnZXguZXhlYyhzdHJpbmcyKTtcbiAgcmV0dXJuIG1hdGNoPy5ncm91cHM7XG59XG52YXIgaW5pdF9yZWdleCA9ICgpID0+IHt9O1xuXG4vLyBub2RlX21vZHVsZXMvYWJpdHlwZS9kaXN0L2VzbS9odW1hbi1yZWFkYWJsZS9mb3JtYXRBYmlQYXJhbWV0ZXIuanNcbmZ1bmN0aW9uIGZvcm1hdEFiaVBhcmFtZXRlcihhYmlQYXJhbWV0ZXIpIHtcbiAgbGV0IHR5cGUgPSBhYmlQYXJhbWV0ZXIudHlwZTtcbiAgaWYgKHR1cGxlUmVnZXgudGVzdChhYmlQYXJhbWV0ZXIudHlwZSkgJiYgXCJjb21wb25lbnRzXCIgaW4gYWJpUGFyYW1ldGVyKSB7XG4gICAgdHlwZSA9IFwiKFwiO1xuICAgIGNvbnN0IGxlbmd0aCA9IGFiaVBhcmFtZXRlci5jb21wb25lbnRzLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDtpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNvbXBvbmVudCA9IGFiaVBhcmFtZXRlci5jb21wb25lbnRzW2ldO1xuICAgICAgdHlwZSArPSBmb3JtYXRBYmlQYXJhbWV0ZXIoY29tcG9uZW50KTtcbiAgICAgIGlmIChpIDwgbGVuZ3RoIC0gMSlcbiAgICAgICAgdHlwZSArPSBcIiwgXCI7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IGV4ZWNUeXBlZCh0dXBsZVJlZ2V4LCBhYmlQYXJhbWV0ZXIudHlwZSk7XG4gICAgdHlwZSArPSBgKSR7cmVzdWx0Py5hcnJheSA/PyBcIlwifWA7XG4gICAgcmV0dXJuIGZvcm1hdEFiaVBhcmFtZXRlcih7XG4gICAgICAuLi5hYmlQYXJhbWV0ZXIsXG4gICAgICB0eXBlXG4gICAgfSk7XG4gIH1cbiAgaWYgKFwiaW5kZXhlZFwiIGluIGFiaVBhcmFtZXRlciAmJiBhYmlQYXJhbWV0ZXIuaW5kZXhlZClcbiAgICB0eXBlID0gYCR7dHlwZX0gaW5kZXhlZGA7XG4gIGlmIChhYmlQYXJhbWV0ZXIubmFtZSlcbiAgICByZXR1cm4gYCR7dHlwZX0gJHthYmlQYXJhbWV0ZXIubmFtZX1gO1xuICByZXR1cm4gdHlwZTtcbn1cbnZhciB0dXBsZVJlZ2V4O1xudmFyIGluaXRfZm9ybWF0QWJpUGFyYW1ldGVyID0gX19lc20oKCkgPT4ge1xuICBpbml0X3JlZ2V4KCk7XG4gIHR1cGxlUmVnZXggPSAvXnR1cGxlKD88YXJyYXk+KFxcWyhcXGQqKVxcXSkqKSQvO1xufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9hYml0eXBlL2Rpc3QvZXNtL2h1bWFuLXJlYWRhYmxlL2Zvcm1hdEFiaVBhcmFtZXRlcnMuanNcbmZ1bmN0aW9uIGZvcm1hdEFiaVBhcmFtZXRlcnMoYWJpUGFyYW1ldGVycykge1xuICBsZXQgcGFyYW1zID0gXCJcIjtcbiAgY29uc3QgbGVuZ3RoID0gYWJpUGFyYW1ldGVycy5sZW5ndGg7XG4gIGZvciAobGV0IGkgPSAwO2kgPCBsZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGFiaVBhcmFtZXRlciA9IGFiaVBhcmFtZXRlcnNbaV07XG4gICAgcGFyYW1zICs9IGZvcm1hdEFiaVBhcmFtZXRlcihhYmlQYXJhbWV0ZXIpO1xuICAgIGlmIChpICE9PSBsZW5ndGggLSAxKVxuICAgICAgcGFyYW1zICs9IFwiLCBcIjtcbiAgfVxuICByZXR1cm4gcGFyYW1zO1xufVxudmFyIGluaXRfZm9ybWF0QWJpUGFyYW1ldGVycyA9IF9fZXNtKCgpID0+IHtcbiAgaW5pdF9mb3JtYXRBYmlQYXJhbWV0ZXIoKTtcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYWJpdHlwZS9kaXN0L2VzbS9odW1hbi1yZWFkYWJsZS9mb3JtYXRBYmlJdGVtLmpzXG5mdW5jdGlvbiBmb3JtYXRBYmlJdGVtKGFiaUl0ZW0pIHtcbiAgaWYgKGFiaUl0ZW0udHlwZSA9PT0gXCJmdW5jdGlvblwiKVxuICAgIHJldHVybiBgZnVuY3Rpb24gJHthYmlJdGVtLm5hbWV9KCR7Zm9ybWF0QWJpUGFyYW1ldGVycyhhYmlJdGVtLmlucHV0cyl9KSR7YWJpSXRlbS5zdGF0ZU11dGFiaWxpdHkgJiYgYWJpSXRlbS5zdGF0ZU11dGFiaWxpdHkgIT09IFwibm9ucGF5YWJsZVwiID8gYCAke2FiaUl0ZW0uc3RhdGVNdXRhYmlsaXR5fWAgOiBcIlwifSR7YWJpSXRlbS5vdXRwdXRzPy5sZW5ndGggPyBgIHJldHVybnMgKCR7Zm9ybWF0QWJpUGFyYW1ldGVycyhhYmlJdGVtLm91dHB1dHMpfSlgIDogXCJcIn1gO1xuICBpZiAoYWJpSXRlbS50eXBlID09PSBcImV2ZW50XCIpXG4gICAgcmV0dXJuIGBldmVudCAke2FiaUl0ZW0ubmFtZX0oJHtmb3JtYXRBYmlQYXJhbWV0ZXJzKGFiaUl0ZW0uaW5wdXRzKX0pYDtcbiAgaWYgKGFiaUl0ZW0udHlwZSA9PT0gXCJlcnJvclwiKVxuICAgIHJldHVybiBgZXJyb3IgJHthYmlJdGVtLm5hbWV9KCR7Zm9ybWF0QWJpUGFyYW1ldGVycyhhYmlJdGVtLmlucHV0cyl9KWA7XG4gIGlmIChhYmlJdGVtLnR5cGUgPT09IFwiY29uc3RydWN0b3JcIilcbiAgICByZXR1cm4gYGNvbnN0cnVjdG9yKCR7Zm9ybWF0QWJpUGFyYW1ldGVycyhhYmlJdGVtLmlucHV0cyl9KSR7YWJpSXRlbS5zdGF0ZU11dGFiaWxpdHkgPT09IFwicGF5YWJsZVwiID8gXCIgcGF5YWJsZVwiIDogXCJcIn1gO1xuICBpZiAoYWJpSXRlbS50eXBlID09PSBcImZhbGxiYWNrXCIpXG4gICAgcmV0dXJuIGBmYWxsYmFjaygpIGV4dGVybmFsJHthYmlJdGVtLnN0YXRlTXV0YWJpbGl0eSA9PT0gXCJwYXlhYmxlXCIgPyBcIiBwYXlhYmxlXCIgOiBcIlwifWA7XG4gIHJldHVybiBcInJlY2VpdmUoKSBleHRlcm5hbCBwYXlhYmxlXCI7XG59XG52YXIgaW5pdF9mb3JtYXRBYmlJdGVtID0gX19lc20oKCkgPT4ge1xuICBpbml0X2Zvcm1hdEFiaVBhcmFtZXRlcnMoKTtcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYWJpdHlwZS9kaXN0L2VzbS9leHBvcnRzL2luZGV4LmpzXG52YXIgaW5pdF9leHBvcnRzID0gX19lc20oKCkgPT4ge1xuICBpbml0X2Zvcm1hdEFiaUl0ZW0oKTtcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL2FiaS9mb3JtYXRBYmlJdGVtLmpzXG5mdW5jdGlvbiBmb3JtYXRBYmlJdGVtMihhYmlJdGVtLCB7IGluY2x1ZGVOYW1lID0gZmFsc2UgfSA9IHt9KSB7XG4gIGlmIChhYmlJdGVtLnR5cGUgIT09IFwiZnVuY3Rpb25cIiAmJiBhYmlJdGVtLnR5cGUgIT09IFwiZXZlbnRcIiAmJiBhYmlJdGVtLnR5cGUgIT09IFwiZXJyb3JcIilcbiAgICB0aHJvdyBuZXcgSW52YWxpZERlZmluaXRpb25UeXBlRXJyb3IoYWJpSXRlbS50eXBlKTtcbiAgcmV0dXJuIGAke2FiaUl0ZW0ubmFtZX0oJHtmb3JtYXRBYmlQYXJhbXMoYWJpSXRlbS5pbnB1dHMsIHsgaW5jbHVkZU5hbWUgfSl9KWA7XG59XG5mdW5jdGlvbiBmb3JtYXRBYmlQYXJhbXMocGFyYW1zLCB7IGluY2x1ZGVOYW1lID0gZmFsc2UgfSA9IHt9KSB7XG4gIGlmICghcGFyYW1zKVxuICAgIHJldHVybiBcIlwiO1xuICByZXR1cm4gcGFyYW1zLm1hcCgocGFyYW0pID0+IGZvcm1hdEFiaVBhcmFtKHBhcmFtLCB7IGluY2x1ZGVOYW1lIH0pKS5qb2luKGluY2x1ZGVOYW1lID8gXCIsIFwiIDogXCIsXCIpO1xufVxuZnVuY3Rpb24gZm9ybWF0QWJpUGFyYW0ocGFyYW0sIHsgaW5jbHVkZU5hbWUgfSkge1xuICBpZiAocGFyYW0udHlwZS5zdGFydHNXaXRoKFwidHVwbGVcIikpIHtcbiAgICByZXR1cm4gYCgke2Zvcm1hdEFiaVBhcmFtcyhwYXJhbS5jb21wb25lbnRzLCB7IGluY2x1ZGVOYW1lIH0pfSkke3BhcmFtLnR5cGUuc2xpY2UoXCJ0dXBsZVwiLmxlbmd0aCl9YDtcbiAgfVxuICByZXR1cm4gcGFyYW0udHlwZSArIChpbmNsdWRlTmFtZSAmJiBwYXJhbS5uYW1lID8gYCAke3BhcmFtLm5hbWV9YCA6IFwiXCIpO1xufVxudmFyIGluaXRfZm9ybWF0QWJpSXRlbTIgPSBfX2VzbSgoKSA9PiB7XG4gIGluaXRfYWJpKCk7XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy9kYXRhL2lzSGV4LmpzXG5mdW5jdGlvbiBpc0hleCh2YWx1ZSwgeyBzdHJpY3QgPSB0cnVlIH0gPSB7fSkge1xuICBpZiAoIXZhbHVlKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIilcbiAgICByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBzdHJpY3QgPyAvXjB4WzAtOWEtZkEtRl0qJC8udGVzdCh2YWx1ZSkgOiB2YWx1ZS5zdGFydHNXaXRoKFwiMHhcIik7XG59XG5cbi8vIG5vZGVfbW9kdWxlcy92aWVtL19lc20vdXRpbHMvZGF0YS9zaXplLmpzXG5mdW5jdGlvbiBzaXplKHZhbHVlKSB7XG4gIGlmIChpc0hleCh2YWx1ZSwgeyBzdHJpY3Q6IGZhbHNlIH0pKVxuICAgIHJldHVybiBNYXRoLmNlaWwoKHZhbHVlLmxlbmd0aCAtIDIpIC8gMik7XG4gIHJldHVybiB2YWx1ZS5sZW5ndGg7XG59XG52YXIgaW5pdF9zaXplID0gKCkgPT4ge307XG5cbi8vIG5vZGVfbW9kdWxlcy92aWVtL19lc20vZXJyb3JzL3ZlcnNpb24uanNcbnZhciB2ZXJzaW9uID0gXCIyLjMzLjNcIjtcblxuLy8gbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS9lcnJvcnMvYmFzZS5qc1xuZnVuY3Rpb24gd2FsayhlcnIsIGZuKSB7XG4gIGlmIChmbj8uKGVycikpXG4gICAgcmV0dXJuIGVycjtcbiAgaWYgKGVyciAmJiB0eXBlb2YgZXJyID09PSBcIm9iamVjdFwiICYmIFwiY2F1c2VcIiBpbiBlcnIgJiYgZXJyLmNhdXNlICE9PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIHdhbGsoZXJyLmNhdXNlLCBmbik7XG4gIHJldHVybiBmbiA/IG51bGwgOiBlcnI7XG59XG52YXIgZXJyb3JDb25maWcsIEJhc2VFcnJvcjtcbnZhciBpbml0X2Jhc2UgPSBfX2VzbSgoKSA9PiB7XG4gIGVycm9yQ29uZmlnID0ge1xuICAgIGdldERvY3NVcmw6ICh7IGRvY3NCYXNlVXJsLCBkb2NzUGF0aCA9IFwiXCIsIGRvY3NTbHVnIH0pID0+IGRvY3NQYXRoID8gYCR7ZG9jc0Jhc2VVcmwgPz8gXCJodHRwczovL3ZpZW0uc2hcIn0ke2RvY3NQYXRofSR7ZG9jc1NsdWcgPyBgIyR7ZG9jc1NsdWd9YCA6IFwiXCJ9YCA6IHVuZGVmaW5lZCxcbiAgICB2ZXJzaW9uOiBgdmllbUAke3ZlcnNpb259YFxuICB9O1xuICBCYXNlRXJyb3IgPSBjbGFzcyBCYXNlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3Ioc2hvcnRNZXNzYWdlLCBhcmdzID0ge30pIHtcbiAgICAgIGNvbnN0IGRldGFpbHMgPSAoKCkgPT4ge1xuICAgICAgICBpZiAoYXJncy5jYXVzZSBpbnN0YW5jZW9mIEJhc2VFcnJvcilcbiAgICAgICAgICByZXR1cm4gYXJncy5jYXVzZS5kZXRhaWxzO1xuICAgICAgICBpZiAoYXJncy5jYXVzZT8ubWVzc2FnZSlcbiAgICAgICAgICByZXR1cm4gYXJncy5jYXVzZS5tZXNzYWdlO1xuICAgICAgICByZXR1cm4gYXJncy5kZXRhaWxzO1xuICAgICAgfSkoKTtcbiAgICAgIGNvbnN0IGRvY3NQYXRoID0gKCgpID0+IHtcbiAgICAgICAgaWYgKGFyZ3MuY2F1c2UgaW5zdGFuY2VvZiBCYXNlRXJyb3IpXG4gICAgICAgICAgcmV0dXJuIGFyZ3MuY2F1c2UuZG9jc1BhdGggfHwgYXJncy5kb2NzUGF0aDtcbiAgICAgICAgcmV0dXJuIGFyZ3MuZG9jc1BhdGg7XG4gICAgICB9KSgpO1xuICAgICAgY29uc3QgZG9jc1VybCA9IGVycm9yQ29uZmlnLmdldERvY3NVcmw/Lih7IC4uLmFyZ3MsIGRvY3NQYXRoIH0pO1xuICAgICAgY29uc3QgbWVzc2FnZSA9IFtcbiAgICAgICAgc2hvcnRNZXNzYWdlIHx8IFwiQW4gZXJyb3Igb2NjdXJyZWQuXCIsXG4gICAgICAgIFwiXCIsXG4gICAgICAgIC4uLmFyZ3MubWV0YU1lc3NhZ2VzID8gWy4uLmFyZ3MubWV0YU1lc3NhZ2VzLCBcIlwiXSA6IFtdLFxuICAgICAgICAuLi5kb2NzVXJsID8gW2BEb2NzOiAke2RvY3NVcmx9YF0gOiBbXSxcbiAgICAgICAgLi4uZGV0YWlscyA/IFtgRGV0YWlsczogJHtkZXRhaWxzfWBdIDogW10sXG4gICAgICAgIC4uLmVycm9yQ29uZmlnLnZlcnNpb24gPyBbYFZlcnNpb246ICR7ZXJyb3JDb25maWcudmVyc2lvbn1gXSA6IFtdXG4gICAgICBdLmpvaW4oYFxuYCk7XG4gICAgICBzdXBlcihtZXNzYWdlLCBhcmdzLmNhdXNlID8geyBjYXVzZTogYXJncy5jYXVzZSB9IDogdW5kZWZpbmVkKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRldGFpbHNcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRvY3NQYXRoXCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZFxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtZXRhTWVzc2FnZXNcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNob3J0TWVzc2FnZVwiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWRcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidmVyc2lvblwiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWRcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBcIkJhc2VFcnJvclwiXG4gICAgICB9KTtcbiAgICAgIHRoaXMuZGV0YWlscyA9IGRldGFpbHM7XG4gICAgICB0aGlzLmRvY3NQYXRoID0gZG9jc1BhdGg7XG4gICAgICB0aGlzLm1ldGFNZXNzYWdlcyA9IGFyZ3MubWV0YU1lc3NhZ2VzO1xuICAgICAgdGhpcy5uYW1lID0gYXJncy5uYW1lID8/IHRoaXMubmFtZTtcbiAgICAgIHRoaXMuc2hvcnRNZXNzYWdlID0gc2hvcnRNZXNzYWdlO1xuICAgICAgdGhpcy52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICB9XG4gICAgd2Fsayhmbikge1xuICAgICAgcmV0dXJuIHdhbGsodGhpcywgZm4pO1xuICAgIH1cbiAgfTtcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvdmllbS9fZXNtL2Vycm9ycy9hYmkuanNcbnZhciBBYmlFbmNvZGluZ0FycmF5TGVuZ3RoTWlzbWF0Y2hFcnJvciwgQWJpRW5jb2RpbmdCeXRlc1NpemVNaXNtYXRjaEVycm9yLCBBYmlFbmNvZGluZ0xlbmd0aE1pc21hdGNoRXJyb3IsIEFiaUZ1bmN0aW9uTm90Rm91bmRFcnJvciwgQWJpSXRlbUFtYmlndWl0eUVycm9yLCBCeXRlc1NpemVNaXNtYXRjaEVycm9yLCBJbnZhbGlkQWJpRW5jb2RpbmdUeXBlRXJyb3IsIEludmFsaWRBcnJheUVycm9yLCBJbnZhbGlkRGVmaW5pdGlvblR5cGVFcnJvciwgVW5zdXBwb3J0ZWRQYWNrZWRBYmlUeXBlO1xudmFyIGluaXRfYWJpID0gX19lc20oKCkgPT4ge1xuICBpbml0X2Zvcm1hdEFiaUl0ZW0yKCk7XG4gIGluaXRfc2l6ZSgpO1xuICBpbml0X2Jhc2UoKTtcbiAgQWJpRW5jb2RpbmdBcnJheUxlbmd0aE1pc21hdGNoRXJyb3IgPSBjbGFzcyBBYmlFbmNvZGluZ0FycmF5TGVuZ3RoTWlzbWF0Y2hFcnJvciBleHRlbmRzIEJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBleHBlY3RlZExlbmd0aCwgZ2l2ZW5MZW5ndGgsIHR5cGUgfSkge1xuICAgICAgc3VwZXIoW1xuICAgICAgICBgQUJJIGVuY29kaW5nIGFycmF5IGxlbmd0aCBtaXNtYXRjaCBmb3IgdHlwZSAke3R5cGV9LmAsXG4gICAgICAgIGBFeHBlY3RlZCBsZW5ndGg6ICR7ZXhwZWN0ZWRMZW5ndGh9YCxcbiAgICAgICAgYEdpdmVuIGxlbmd0aDogJHtnaXZlbkxlbmd0aH1gXG4gICAgICBdLmpvaW4oYFxuYCksIHsgbmFtZTogXCJBYmlFbmNvZGluZ0FycmF5TGVuZ3RoTWlzbWF0Y2hFcnJvclwiIH0pO1xuICAgIH1cbiAgfTtcbiAgQWJpRW5jb2RpbmdCeXRlc1NpemVNaXNtYXRjaEVycm9yID0gY2xhc3MgQWJpRW5jb2RpbmdCeXRlc1NpemVNaXNtYXRjaEVycm9yIGV4dGVuZHMgQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGV4cGVjdGVkU2l6ZSwgdmFsdWUgfSkge1xuICAgICAgc3VwZXIoYFNpemUgb2YgYnl0ZXMgXCIke3ZhbHVlfVwiIChieXRlcyR7c2l6ZSh2YWx1ZSl9KSBkb2VzIG5vdCBtYXRjaCBleHBlY3RlZCBzaXplIChieXRlcyR7ZXhwZWN0ZWRTaXplfSkuYCwgeyBuYW1lOiBcIkFiaUVuY29kaW5nQnl0ZXNTaXplTWlzbWF0Y2hFcnJvclwiIH0pO1xuICAgIH1cbiAgfTtcbiAgQWJpRW5jb2RpbmdMZW5ndGhNaXNtYXRjaEVycm9yID0gY2xhc3MgQWJpRW5jb2RpbmdMZW5ndGhNaXNtYXRjaEVycm9yIGV4dGVuZHMgQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGV4cGVjdGVkTGVuZ3RoLCBnaXZlbkxlbmd0aCB9KSB7XG4gICAgICBzdXBlcihbXG4gICAgICAgIFwiQUJJIGVuY29kaW5nIHBhcmFtcy92YWx1ZXMgbGVuZ3RoIG1pc21hdGNoLlwiLFxuICAgICAgICBgRXhwZWN0ZWQgbGVuZ3RoIChwYXJhbXMpOiAke2V4cGVjdGVkTGVuZ3RofWAsXG4gICAgICAgIGBHaXZlbiBsZW5ndGggKHZhbHVlcyk6ICR7Z2l2ZW5MZW5ndGh9YFxuICAgICAgXS5qb2luKGBcbmApLCB7IG5hbWU6IFwiQWJpRW5jb2RpbmdMZW5ndGhNaXNtYXRjaEVycm9yXCIgfSk7XG4gICAgfVxuICB9O1xuICBBYmlGdW5jdGlvbk5vdEZvdW5kRXJyb3IgPSBjbGFzcyBBYmlGdW5jdGlvbk5vdEZvdW5kRXJyb3IgZXh0ZW5kcyBCYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGZ1bmN0aW9uTmFtZSwgeyBkb2NzUGF0aCB9ID0ge30pIHtcbiAgICAgIHN1cGVyKFtcbiAgICAgICAgYEZ1bmN0aW9uICR7ZnVuY3Rpb25OYW1lID8gYFwiJHtmdW5jdGlvbk5hbWV9XCIgYCA6IFwiXCJ9bm90IGZvdW5kIG9uIEFCSS5gLFxuICAgICAgICBcIk1ha2Ugc3VyZSB5b3UgYXJlIHVzaW5nIHRoZSBjb3JyZWN0IEFCSSBhbmQgdGhhdCB0aGUgZnVuY3Rpb24gZXhpc3RzIG9uIGl0LlwiXG4gICAgICBdLmpvaW4oYFxuYCksIHtcbiAgICAgICAgZG9jc1BhdGgsXG4gICAgICAgIG5hbWU6IFwiQWJpRnVuY3Rpb25Ob3RGb3VuZEVycm9yXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgQWJpSXRlbUFtYmlndWl0eUVycm9yID0gY2xhc3MgQWJpSXRlbUFtYmlndWl0eUVycm9yIGV4dGVuZHMgQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih4LCB5KSB7XG4gICAgICBzdXBlcihcIkZvdW5kIGFtYmlndW91cyB0eXBlcyBpbiBvdmVybG9hZGVkIEFCSSBpdGVtcy5cIiwge1xuICAgICAgICBtZXRhTWVzc2FnZXM6IFtcbiAgICAgICAgICBgXFxgJHt4LnR5cGV9XFxgIGluIFxcYCR7Zm9ybWF0QWJpSXRlbTIoeC5hYmlJdGVtKX1cXGAsIGFuZGAsXG4gICAgICAgICAgYFxcYCR7eS50eXBlfVxcYCBpbiBcXGAke2Zvcm1hdEFiaUl0ZW0yKHkuYWJpSXRlbSl9XFxgYCxcbiAgICAgICAgICBcIlwiLFxuICAgICAgICAgIFwiVGhlc2UgdHlwZXMgZW5jb2RlIGRpZmZlcmVudGx5IGFuZCBjYW5ub3QgYmUgZGlzdGluZ3Vpc2hlZCBhdCBydW50aW1lLlwiLFxuICAgICAgICAgIFwiUmVtb3ZlIG9uZSBvZiB0aGUgYW1iaWd1b3VzIGl0ZW1zIGluIHRoZSBBQkkuXCJcbiAgICAgICAgXSxcbiAgICAgICAgbmFtZTogXCJBYmlJdGVtQW1iaWd1aXR5RXJyb3JcIlxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICBCeXRlc1NpemVNaXNtYXRjaEVycm9yID0gY2xhc3MgQnl0ZXNTaXplTWlzbWF0Y2hFcnJvciBleHRlbmRzIEJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBleHBlY3RlZFNpemUsIGdpdmVuU2l6ZSB9KSB7XG4gICAgICBzdXBlcihgRXhwZWN0ZWQgYnl0ZXMke2V4cGVjdGVkU2l6ZX0sIGdvdCBieXRlcyR7Z2l2ZW5TaXplfS5gLCB7XG4gICAgICAgIG5hbWU6IFwiQnl0ZXNTaXplTWlzbWF0Y2hFcnJvclwiXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIEludmFsaWRBYmlFbmNvZGluZ1R5cGVFcnJvciA9IGNsYXNzIEludmFsaWRBYmlFbmNvZGluZ1R5cGVFcnJvciBleHRlbmRzIEJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IodHlwZSwgeyBkb2NzUGF0aCB9KSB7XG4gICAgICBzdXBlcihbXG4gICAgICAgIGBUeXBlIFwiJHt0eXBlfVwiIGlzIG5vdCBhIHZhbGlkIGVuY29kaW5nIHR5cGUuYCxcbiAgICAgICAgXCJQbGVhc2UgcHJvdmlkZSBhIHZhbGlkIEFCSSB0eXBlLlwiXG4gICAgICBdLmpvaW4oYFxuYCksIHsgZG9jc1BhdGgsIG5hbWU6IFwiSW52YWxpZEFiaUVuY29kaW5nVHlwZVwiIH0pO1xuICAgIH1cbiAgfTtcbiAgSW52YWxpZEFycmF5RXJyb3IgPSBjbGFzcyBJbnZhbGlkQXJyYXlFcnJvciBleHRlbmRzIEJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICAgIHN1cGVyKFtgVmFsdWUgXCIke3ZhbHVlfVwiIGlzIG5vdCBhIHZhbGlkIGFycmF5LmBdLmpvaW4oYFxuYCksIHtcbiAgICAgICAgbmFtZTogXCJJbnZhbGlkQXJyYXlFcnJvclwiXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIEludmFsaWREZWZpbml0aW9uVHlwZUVycm9yID0gY2xhc3MgSW52YWxpZERlZmluaXRpb25UeXBlRXJyb3IgZXh0ZW5kcyBCYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHR5cGUpIHtcbiAgICAgIHN1cGVyKFtcbiAgICAgICAgYFwiJHt0eXBlfVwiIGlzIG5vdCBhIHZhbGlkIGRlZmluaXRpb24gdHlwZS5gLFxuICAgICAgICAnVmFsaWQgdHlwZXM6IFwiZnVuY3Rpb25cIiwgXCJldmVudFwiLCBcImVycm9yXCInXG4gICAgICBdLmpvaW4oYFxuYCksIHsgbmFtZTogXCJJbnZhbGlkRGVmaW5pdGlvblR5cGVFcnJvclwiIH0pO1xuICAgIH1cbiAgfTtcbiAgVW5zdXBwb3J0ZWRQYWNrZWRBYmlUeXBlID0gY2xhc3MgVW5zdXBwb3J0ZWRQYWNrZWRBYmlUeXBlIGV4dGVuZHMgQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih0eXBlKSB7XG4gICAgICBzdXBlcihgVHlwZSBcIiR7dHlwZX1cIiBpcyBub3Qgc3VwcG9ydGVkIGZvciBwYWNrZWQgZW5jb2RpbmcuYCwge1xuICAgICAgICBuYW1lOiBcIlVuc3VwcG9ydGVkUGFja2VkQWJpVHlwZVwiXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS9lcnJvcnMvZGF0YS5qc1xudmFyIFNsaWNlT2Zmc2V0T3V0T2ZCb3VuZHNFcnJvciwgU2l6ZUV4Y2VlZHNQYWRkaW5nU2l6ZUVycm9yO1xudmFyIGluaXRfZGF0YSA9IF9fZXNtKCgpID0+IHtcbiAgaW5pdF9iYXNlKCk7XG4gIFNsaWNlT2Zmc2V0T3V0T2ZCb3VuZHNFcnJvciA9IGNsYXNzIFNsaWNlT2Zmc2V0T3V0T2ZCb3VuZHNFcnJvciBleHRlbmRzIEJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBvZmZzZXQsIHBvc2l0aW9uLCBzaXplOiBzaXplMiB9KSB7XG4gICAgICBzdXBlcihgU2xpY2UgJHtwb3NpdGlvbiA9PT0gXCJzdGFydFwiID8gXCJzdGFydGluZ1wiIDogXCJlbmRpbmdcIn0gYXQgb2Zmc2V0IFwiJHtvZmZzZXR9XCIgaXMgb3V0LW9mLWJvdW5kcyAoc2l6ZTogJHtzaXplMn0pLmAsIHsgbmFtZTogXCJTbGljZU9mZnNldE91dE9mQm91bmRzRXJyb3JcIiB9KTtcbiAgICB9XG4gIH07XG4gIFNpemVFeGNlZWRzUGFkZGluZ1NpemVFcnJvciA9IGNsYXNzIFNpemVFeGNlZWRzUGFkZGluZ1NpemVFcnJvciBleHRlbmRzIEJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBzaXplOiBzaXplMiwgdGFyZ2V0U2l6ZSwgdHlwZSB9KSB7XG4gICAgICBzdXBlcihgJHt0eXBlLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpfSR7dHlwZS5zbGljZSgxKS50b0xvd2VyQ2FzZSgpfSBzaXplICgke3NpemUyfSkgZXhjZWVkcyBwYWRkaW5nIHNpemUgKCR7dGFyZ2V0U2l6ZX0pLmAsIHsgbmFtZTogXCJTaXplRXhjZWVkc1BhZGRpbmdTaXplRXJyb3JcIiB9KTtcbiAgICB9XG4gIH07XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy9kYXRhL3BhZC5qc1xuZnVuY3Rpb24gcGFkKGhleE9yQnl0ZXMsIHsgZGlyLCBzaXplOiBzaXplMiA9IDMyIH0gPSB7fSkge1xuICBpZiAodHlwZW9mIGhleE9yQnl0ZXMgPT09IFwic3RyaW5nXCIpXG4gICAgcmV0dXJuIHBhZEhleChoZXhPckJ5dGVzLCB7IGRpciwgc2l6ZTogc2l6ZTIgfSk7XG4gIHJldHVybiBwYWRCeXRlcyhoZXhPckJ5dGVzLCB7IGRpciwgc2l6ZTogc2l6ZTIgfSk7XG59XG5mdW5jdGlvbiBwYWRIZXgoaGV4XywgeyBkaXIsIHNpemU6IHNpemUyID0gMzIgfSA9IHt9KSB7XG4gIGlmIChzaXplMiA9PT0gbnVsbClcbiAgICByZXR1cm4gaGV4XztcbiAgY29uc3QgaGV4ID0gaGV4Xy5yZXBsYWNlKFwiMHhcIiwgXCJcIik7XG4gIGlmIChoZXgubGVuZ3RoID4gc2l6ZTIgKiAyKVxuICAgIHRocm93IG5ldyBTaXplRXhjZWVkc1BhZGRpbmdTaXplRXJyb3Ioe1xuICAgICAgc2l6ZTogTWF0aC5jZWlsKGhleC5sZW5ndGggLyAyKSxcbiAgICAgIHRhcmdldFNpemU6IHNpemUyLFxuICAgICAgdHlwZTogXCJoZXhcIlxuICAgIH0pO1xuICByZXR1cm4gYDB4JHtoZXhbZGlyID09PSBcInJpZ2h0XCIgPyBcInBhZEVuZFwiIDogXCJwYWRTdGFydFwiXShzaXplMiAqIDIsIFwiMFwiKX1gO1xufVxuZnVuY3Rpb24gcGFkQnl0ZXMoYnl0ZXMsIHsgZGlyLCBzaXplOiBzaXplMiA9IDMyIH0gPSB7fSkge1xuICBpZiAoc2l6ZTIgPT09IG51bGwpXG4gICAgcmV0dXJuIGJ5dGVzO1xuICBpZiAoYnl0ZXMubGVuZ3RoID4gc2l6ZTIpXG4gICAgdGhyb3cgbmV3IFNpemVFeGNlZWRzUGFkZGluZ1NpemVFcnJvcih7XG4gICAgICBzaXplOiBieXRlcy5sZW5ndGgsXG4gICAgICB0YXJnZXRTaXplOiBzaXplMixcbiAgICAgIHR5cGU6IFwiYnl0ZXNcIlxuICAgIH0pO1xuICBjb25zdCBwYWRkZWRCeXRlcyA9IG5ldyBVaW50OEFycmF5KHNpemUyKTtcbiAgZm9yIChsZXQgaSA9IDA7aSA8IHNpemUyOyBpKyspIHtcbiAgICBjb25zdCBwYWRFbmQgPSBkaXIgPT09IFwicmlnaHRcIjtcbiAgICBwYWRkZWRCeXRlc1twYWRFbmQgPyBpIDogc2l6ZTIgLSBpIC0gMV0gPSBieXRlc1twYWRFbmQgPyBpIDogYnl0ZXMubGVuZ3RoIC0gaSAtIDFdO1xuICB9XG4gIHJldHVybiBwYWRkZWRCeXRlcztcbn1cbnZhciBpbml0X3BhZCA9IF9fZXNtKCgpID0+IHtcbiAgaW5pdF9kYXRhKCk7XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS9lcnJvcnMvZW5jb2RpbmcuanNcbnZhciBJbnRlZ2VyT3V0T2ZSYW5nZUVycm9yLCBTaXplT3ZlcmZsb3dFcnJvcjtcbnZhciBpbml0X2VuY29kaW5nID0gX19lc20oKCkgPT4ge1xuICBpbml0X2Jhc2UoKTtcbiAgSW50ZWdlck91dE9mUmFuZ2VFcnJvciA9IGNsYXNzIEludGVnZXJPdXRPZlJhbmdlRXJyb3IgZXh0ZW5kcyBCYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgbWF4LCBtaW4sIHNpZ25lZCwgc2l6ZTogc2l6ZTIsIHZhbHVlIH0pIHtcbiAgICAgIHN1cGVyKGBOdW1iZXIgXCIke3ZhbHVlfVwiIGlzIG5vdCBpbiBzYWZlICR7c2l6ZTIgPyBgJHtzaXplMiAqIDh9LWJpdCAke3NpZ25lZCA/IFwic2lnbmVkXCIgOiBcInVuc2lnbmVkXCJ9IGAgOiBcIlwifWludGVnZXIgcmFuZ2UgJHttYXggPyBgKCR7bWlufSB0byAke21heH0pYCA6IGAoYWJvdmUgJHttaW59KWB9YCwgeyBuYW1lOiBcIkludGVnZXJPdXRPZlJhbmdlRXJyb3JcIiB9KTtcbiAgICB9XG4gIH07XG4gIFNpemVPdmVyZmxvd0Vycm9yID0gY2xhc3MgU2l6ZU92ZXJmbG93RXJyb3IgZXh0ZW5kcyBCYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgZ2l2ZW5TaXplLCBtYXhTaXplIH0pIHtcbiAgICAgIHN1cGVyKGBTaXplIGNhbm5vdCBleGNlZWQgJHttYXhTaXplfSBieXRlcy4gR2l2ZW4gc2l6ZTogJHtnaXZlblNpemV9IGJ5dGVzLmAsIHsgbmFtZTogXCJTaXplT3ZlcmZsb3dFcnJvclwiIH0pO1xuICAgIH1cbiAgfTtcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL2RhdGEvdHJpbS5qc1xuZnVuY3Rpb24gdHJpbShoZXhPckJ5dGVzLCB7IGRpciA9IFwibGVmdFwiIH0gPSB7fSkge1xuICBsZXQgZGF0YSA9IHR5cGVvZiBoZXhPckJ5dGVzID09PSBcInN0cmluZ1wiID8gaGV4T3JCeXRlcy5yZXBsYWNlKFwiMHhcIiwgXCJcIikgOiBoZXhPckJ5dGVzO1xuICBsZXQgc2xpY2VMZW5ndGggPSAwO1xuICBmb3IgKGxldCBpID0gMDtpIDwgZGF0YS5sZW5ndGggLSAxOyBpKyspIHtcbiAgICBpZiAoZGF0YVtkaXIgPT09IFwibGVmdFwiID8gaSA6IGRhdGEubGVuZ3RoIC0gaSAtIDFdLnRvU3RyaW5nKCkgPT09IFwiMFwiKVxuICAgICAgc2xpY2VMZW5ndGgrKztcbiAgICBlbHNlXG4gICAgICBicmVhaztcbiAgfVxuICBkYXRhID0gZGlyID09PSBcImxlZnRcIiA/IGRhdGEuc2xpY2Uoc2xpY2VMZW5ndGgpIDogZGF0YS5zbGljZSgwLCBkYXRhLmxlbmd0aCAtIHNsaWNlTGVuZ3RoKTtcbiAgaWYgKHR5cGVvZiBoZXhPckJ5dGVzID09PSBcInN0cmluZ1wiKSB7XG4gICAgaWYgKGRhdGEubGVuZ3RoID09PSAxICYmIGRpciA9PT0gXCJyaWdodFwiKVxuICAgICAgZGF0YSA9IGAke2RhdGF9MGA7XG4gICAgcmV0dXJuIGAweCR7ZGF0YS5sZW5ndGggJSAyID09PSAxID8gYDAke2RhdGF9YCA6IGRhdGF9YDtcbiAgfVxuICByZXR1cm4gZGF0YTtcbn1cblxuLy8gbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy9lbmNvZGluZy9mcm9tSGV4LmpzXG5mdW5jdGlvbiBhc3NlcnRTaXplKGhleE9yQnl0ZXMsIHsgc2l6ZTogc2l6ZTIgfSkge1xuICBpZiAoc2l6ZShoZXhPckJ5dGVzKSA+IHNpemUyKVxuICAgIHRocm93IG5ldyBTaXplT3ZlcmZsb3dFcnJvcih7XG4gICAgICBnaXZlblNpemU6IHNpemUoaGV4T3JCeXRlcyksXG4gICAgICBtYXhTaXplOiBzaXplMlxuICAgIH0pO1xufVxuZnVuY3Rpb24gaGV4VG9CaWdJbnQoaGV4LCBvcHRzID0ge30pIHtcbiAgY29uc3QgeyBzaWduZWQgfSA9IG9wdHM7XG4gIGlmIChvcHRzLnNpemUpXG4gICAgYXNzZXJ0U2l6ZShoZXgsIHsgc2l6ZTogb3B0cy5zaXplIH0pO1xuICBjb25zdCB2YWx1ZSA9IEJpZ0ludChoZXgpO1xuICBpZiAoIXNpZ25lZClcbiAgICByZXR1cm4gdmFsdWU7XG4gIGNvbnN0IHNpemUyID0gKGhleC5sZW5ndGggLSAyKSAvIDI7XG4gIGNvbnN0IG1heCA9ICgxbiA8PCBCaWdJbnQoc2l6ZTIpICogOG4gLSAxbikgLSAxbjtcbiAgaWYgKHZhbHVlIDw9IG1heClcbiAgICByZXR1cm4gdmFsdWU7XG4gIHJldHVybiB2YWx1ZSAtIEJpZ0ludChgMHgke1wiZlwiLnBhZFN0YXJ0KHNpemUyICogMiwgXCJmXCIpfWApIC0gMW47XG59XG5mdW5jdGlvbiBoZXhUb051bWJlcihoZXgsIG9wdHMgPSB7fSkge1xuICByZXR1cm4gTnVtYmVyKGhleFRvQmlnSW50KGhleCwgb3B0cykpO1xufVxudmFyIGluaXRfZnJvbUhleCA9IF9fZXNtKCgpID0+IHtcbiAgaW5pdF9lbmNvZGluZygpO1xuICBpbml0X3NpemUoKTtcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL2VuY29kaW5nL3RvSGV4LmpzXG5mdW5jdGlvbiB0b0hleCh2YWx1ZSwgb3B0cyA9IHt9KSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIHZhbHVlID09PSBcImJpZ2ludFwiKVxuICAgIHJldHVybiBudW1iZXJUb0hleCh2YWx1ZSwgb3B0cyk7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gc3RyaW5nVG9IZXgodmFsdWUsIG9wdHMpO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiKVxuICAgIHJldHVybiBib29sVG9IZXgodmFsdWUsIG9wdHMpO1xuICByZXR1cm4gYnl0ZXNUb0hleCh2YWx1ZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBib29sVG9IZXgodmFsdWUsIG9wdHMgPSB7fSkge1xuICBjb25zdCBoZXggPSBgMHgke051bWJlcih2YWx1ZSl9YDtcbiAgaWYgKHR5cGVvZiBvcHRzLnNpemUgPT09IFwibnVtYmVyXCIpIHtcbiAgICBhc3NlcnRTaXplKGhleCwgeyBzaXplOiBvcHRzLnNpemUgfSk7XG4gICAgcmV0dXJuIHBhZChoZXgsIHsgc2l6ZTogb3B0cy5zaXplIH0pO1xuICB9XG4gIHJldHVybiBoZXg7XG59XG5mdW5jdGlvbiBieXRlc1RvSGV4KHZhbHVlLCBvcHRzID0ge30pIHtcbiAgbGV0IHN0cmluZzIgPSBcIlwiO1xuICBmb3IgKGxldCBpID0gMDtpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICBzdHJpbmcyICs9IGhleGVzW3ZhbHVlW2ldXTtcbiAgfVxuICBjb25zdCBoZXggPSBgMHgke3N0cmluZzJ9YDtcbiAgaWYgKHR5cGVvZiBvcHRzLnNpemUgPT09IFwibnVtYmVyXCIpIHtcbiAgICBhc3NlcnRTaXplKGhleCwgeyBzaXplOiBvcHRzLnNpemUgfSk7XG4gICAgcmV0dXJuIHBhZChoZXgsIHsgZGlyOiBcInJpZ2h0XCIsIHNpemU6IG9wdHMuc2l6ZSB9KTtcbiAgfVxuICByZXR1cm4gaGV4O1xufVxuZnVuY3Rpb24gbnVtYmVyVG9IZXgodmFsdWVfLCBvcHRzID0ge30pIHtcbiAgY29uc3QgeyBzaWduZWQsIHNpemU6IHNpemUyIH0gPSBvcHRzO1xuICBjb25zdCB2YWx1ZSA9IEJpZ0ludCh2YWx1ZV8pO1xuICBsZXQgbWF4VmFsdWU7XG4gIGlmIChzaXplMikge1xuICAgIGlmIChzaWduZWQpXG4gICAgICBtYXhWYWx1ZSA9ICgxbiA8PCBCaWdJbnQoc2l6ZTIpICogOG4gLSAxbikgLSAxbjtcbiAgICBlbHNlXG4gICAgICBtYXhWYWx1ZSA9IDJuICoqIChCaWdJbnQoc2l6ZTIpICogOG4pIC0gMW47XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlXyA9PT0gXCJudW1iZXJcIikge1xuICAgIG1heFZhbHVlID0gQmlnSW50KE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKTtcbiAgfVxuICBjb25zdCBtaW5WYWx1ZSA9IHR5cGVvZiBtYXhWYWx1ZSA9PT0gXCJiaWdpbnRcIiAmJiBzaWduZWQgPyAtbWF4VmFsdWUgLSAxbiA6IDA7XG4gIGlmIChtYXhWYWx1ZSAmJiB2YWx1ZSA+IG1heFZhbHVlIHx8IHZhbHVlIDwgbWluVmFsdWUpIHtcbiAgICBjb25zdCBzdWZmaXggPSB0eXBlb2YgdmFsdWVfID09PSBcImJpZ2ludFwiID8gXCJuXCIgOiBcIlwiO1xuICAgIHRocm93IG5ldyBJbnRlZ2VyT3V0T2ZSYW5nZUVycm9yKHtcbiAgICAgIG1heDogbWF4VmFsdWUgPyBgJHttYXhWYWx1ZX0ke3N1ZmZpeH1gIDogdW5kZWZpbmVkLFxuICAgICAgbWluOiBgJHttaW5WYWx1ZX0ke3N1ZmZpeH1gLFxuICAgICAgc2lnbmVkLFxuICAgICAgc2l6ZTogc2l6ZTIsXG4gICAgICB2YWx1ZTogYCR7dmFsdWVffSR7c3VmZml4fWBcbiAgICB9KTtcbiAgfVxuICBjb25zdCBoZXggPSBgMHgkeyhzaWduZWQgJiYgdmFsdWUgPCAwID8gKDFuIDw8IEJpZ0ludChzaXplMiAqIDgpKSArIEJpZ0ludCh2YWx1ZSkgOiB2YWx1ZSkudG9TdHJpbmcoMTYpfWA7XG4gIGlmIChzaXplMilcbiAgICByZXR1cm4gcGFkKGhleCwgeyBzaXplOiBzaXplMiB9KTtcbiAgcmV0dXJuIGhleDtcbn1cbmZ1bmN0aW9uIHN0cmluZ1RvSGV4KHZhbHVlXywgb3B0cyA9IHt9KSB7XG4gIGNvbnN0IHZhbHVlID0gZW5jb2Rlci5lbmNvZGUodmFsdWVfKTtcbiAgcmV0dXJuIGJ5dGVzVG9IZXgodmFsdWUsIG9wdHMpO1xufVxudmFyIGhleGVzLCBlbmNvZGVyO1xudmFyIGluaXRfdG9IZXggPSBfX2VzbSgoKSA9PiB7XG4gIGluaXRfZW5jb2RpbmcoKTtcbiAgaW5pdF9wYWQoKTtcbiAgaW5pdF9mcm9tSGV4KCk7XG4gIGhleGVzID0gLyogQF9fUFVSRV9fICovIEFycmF5LmZyb20oeyBsZW5ndGg6IDI1NiB9LCAoX3YsIGkpID0+IGkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsIFwiMFwiKSk7XG4gIGVuY29kZXIgPSAvKiBAX19QVVJFX18gKi8gbmV3IFRleHRFbmNvZGVyO1xufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy92aWVtL19lc20vdXRpbHMvZW5jb2RpbmcvdG9CeXRlcy5qc1xuZnVuY3Rpb24gdG9CeXRlczIodmFsdWUsIG9wdHMgPSB7fSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJiaWdpbnRcIilcbiAgICByZXR1cm4gbnVtYmVyVG9CeXRlcyh2YWx1ZSwgb3B0cyk7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiKVxuICAgIHJldHVybiBib29sVG9CeXRlcyh2YWx1ZSwgb3B0cyk7XG4gIGlmIChpc0hleCh2YWx1ZSkpXG4gICAgcmV0dXJuIGhleFRvQnl0ZXModmFsdWUsIG9wdHMpO1xuICByZXR1cm4gc3RyaW5nVG9CeXRlcyh2YWx1ZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBib29sVG9CeXRlcyh2YWx1ZSwgb3B0cyA9IHt9KSB7XG4gIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoMSk7XG4gIGJ5dGVzWzBdID0gTnVtYmVyKHZhbHVlKTtcbiAgaWYgKHR5cGVvZiBvcHRzLnNpemUgPT09IFwibnVtYmVyXCIpIHtcbiAgICBhc3NlcnRTaXplKGJ5dGVzLCB7IHNpemU6IG9wdHMuc2l6ZSB9KTtcbiAgICByZXR1cm4gcGFkKGJ5dGVzLCB7IHNpemU6IG9wdHMuc2l6ZSB9KTtcbiAgfVxuICByZXR1cm4gYnl0ZXM7XG59XG5mdW5jdGlvbiBjaGFyQ29kZVRvQmFzZTE2KGNoYXIpIHtcbiAgaWYgKGNoYXIgPj0gY2hhckNvZGVNYXAuemVybyAmJiBjaGFyIDw9IGNoYXJDb2RlTWFwLm5pbmUpXG4gICAgcmV0dXJuIGNoYXIgLSBjaGFyQ29kZU1hcC56ZXJvO1xuICBpZiAoY2hhciA+PSBjaGFyQ29kZU1hcC5BICYmIGNoYXIgPD0gY2hhckNvZGVNYXAuRilcbiAgICByZXR1cm4gY2hhciAtIChjaGFyQ29kZU1hcC5BIC0gMTApO1xuICBpZiAoY2hhciA+PSBjaGFyQ29kZU1hcC5hICYmIGNoYXIgPD0gY2hhckNvZGVNYXAuZilcbiAgICByZXR1cm4gY2hhciAtIChjaGFyQ29kZU1hcC5hIC0gMTApO1xuICByZXR1cm47XG59XG5mdW5jdGlvbiBoZXhUb0J5dGVzKGhleF8sIG9wdHMgPSB7fSkge1xuICBsZXQgaGV4ID0gaGV4XztcbiAgaWYgKG9wdHMuc2l6ZSkge1xuICAgIGFzc2VydFNpemUoaGV4LCB7IHNpemU6IG9wdHMuc2l6ZSB9KTtcbiAgICBoZXggPSBwYWQoaGV4LCB7IGRpcjogXCJyaWdodFwiLCBzaXplOiBvcHRzLnNpemUgfSk7XG4gIH1cbiAgbGV0IGhleFN0cmluZyA9IGhleC5zbGljZSgyKTtcbiAgaWYgKGhleFN0cmluZy5sZW5ndGggJSAyKVxuICAgIGhleFN0cmluZyA9IGAwJHtoZXhTdHJpbmd9YDtcbiAgY29uc3QgbGVuZ3RoID0gaGV4U3RyaW5nLmxlbmd0aCAvIDI7XG4gIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgZm9yIChsZXQgaW5kZXggPSAwLCBqID0gMDtpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgIGNvbnN0IG5pYmJsZUxlZnQgPSBjaGFyQ29kZVRvQmFzZTE2KGhleFN0cmluZy5jaGFyQ29kZUF0KGorKykpO1xuICAgIGNvbnN0IG5pYmJsZVJpZ2h0ID0gY2hhckNvZGVUb0Jhc2UxNihoZXhTdHJpbmcuY2hhckNvZGVBdChqKyspKTtcbiAgICBpZiAobmliYmxlTGVmdCA9PT0gdW5kZWZpbmVkIHx8IG5pYmJsZVJpZ2h0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBCYXNlRXJyb3IoYEludmFsaWQgYnl0ZSBzZXF1ZW5jZSAoXCIke2hleFN0cmluZ1tqIC0gMl19JHtoZXhTdHJpbmdbaiAtIDFdfVwiIGluIFwiJHtoZXhTdHJpbmd9XCIpLmApO1xuICAgIH1cbiAgICBieXRlc1tpbmRleF0gPSBuaWJibGVMZWZ0ICogMTYgKyBuaWJibGVSaWdodDtcbiAgfVxuICByZXR1cm4gYnl0ZXM7XG59XG5mdW5jdGlvbiBudW1iZXJUb0J5dGVzKHZhbHVlLCBvcHRzKSB7XG4gIGNvbnN0IGhleCA9IG51bWJlclRvSGV4KHZhbHVlLCBvcHRzKTtcbiAgcmV0dXJuIGhleFRvQnl0ZXMoaGV4KTtcbn1cbmZ1bmN0aW9uIHN0cmluZ1RvQnl0ZXModmFsdWUsIG9wdHMgPSB7fSkge1xuICBjb25zdCBieXRlcyA9IGVuY29kZXIyLmVuY29kZSh2YWx1ZSk7XG4gIGlmICh0eXBlb2Ygb3B0cy5zaXplID09PSBcIm51bWJlclwiKSB7XG4gICAgYXNzZXJ0U2l6ZShieXRlcywgeyBzaXplOiBvcHRzLnNpemUgfSk7XG4gICAgcmV0dXJuIHBhZChieXRlcywgeyBkaXI6IFwicmlnaHRcIiwgc2l6ZTogb3B0cy5zaXplIH0pO1xuICB9XG4gIHJldHVybiBieXRlcztcbn1cbnZhciBlbmNvZGVyMiwgY2hhckNvZGVNYXA7XG52YXIgaW5pdF90b0J5dGVzID0gX19lc20oKCkgPT4ge1xuICBpbml0X2Jhc2UoKTtcbiAgaW5pdF9wYWQoKTtcbiAgaW5pdF9mcm9tSGV4KCk7XG4gIGluaXRfdG9IZXgoKTtcbiAgZW5jb2RlcjIgPSAvKiBAX19QVVJFX18gKi8gbmV3IFRleHRFbmNvZGVyO1xuICBjaGFyQ29kZU1hcCA9IHtcbiAgICB6ZXJvOiA0OCxcbiAgICBuaW5lOiA1NyxcbiAgICBBOiA2NSxcbiAgICBGOiA3MCxcbiAgICBhOiA5NyxcbiAgICBmOiAxMDJcbiAgfTtcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL2hhc2gva2VjY2FrMjU2LmpzXG5mdW5jdGlvbiBrZWNjYWsyNTYodmFsdWUsIHRvXykge1xuICBjb25zdCB0byA9IHRvXyB8fCBcImhleFwiO1xuICBjb25zdCBieXRlcyA9IGtlY2Nha18yNTYoaXNIZXgodmFsdWUsIHsgc3RyaWN0OiBmYWxzZSB9KSA/IHRvQnl0ZXMyKHZhbHVlKSA6IHZhbHVlKTtcbiAgaWYgKHRvID09PSBcImJ5dGVzXCIpXG4gICAgcmV0dXJuIGJ5dGVzO1xuICByZXR1cm4gdG9IZXgoYnl0ZXMpO1xufVxudmFyIGluaXRfa2VjY2FrMjU2ID0gX19lc20oKCkgPT4ge1xuICBpbml0X3NoYTMoKTtcbiAgaW5pdF90b0J5dGVzKCk7XG4gIGluaXRfdG9IZXgoKTtcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL2hhc2gvaGFzaFNpZ25hdHVyZS5qc1xuZnVuY3Rpb24gaGFzaFNpZ25hdHVyZShzaWcpIHtcbiAgcmV0dXJuIGhhc2goc2lnKTtcbn1cbnZhciBoYXNoID0gKHZhbHVlKSA9PiBrZWNjYWsyNTYodG9CeXRlczIodmFsdWUpKTtcbnZhciBpbml0X2hhc2hTaWduYXR1cmUgPSBfX2VzbSgoKSA9PiB7XG4gIGluaXRfdG9CeXRlcygpO1xuICBpbml0X2tlY2NhazI1NigpO1xufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy92aWVtL19lc20vdXRpbHMvaGFzaC9ub3JtYWxpemVTaWduYXR1cmUuanNcbmZ1bmN0aW9uIG5vcm1hbGl6ZVNpZ25hdHVyZShzaWduYXR1cmUpIHtcbiAgbGV0IGFjdGl2ZSA9IHRydWU7XG4gIGxldCBjdXJyZW50ID0gXCJcIjtcbiAgbGV0IGxldmVsID0gMDtcbiAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gIGxldCB2YWxpZCA9IGZhbHNlO1xuICBmb3IgKGxldCBpID0gMDtpIDwgc2lnbmF0dXJlLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY2hhciA9IHNpZ25hdHVyZVtpXTtcbiAgICBpZiAoW1wiKFwiLCBcIilcIiwgXCIsXCJdLmluY2x1ZGVzKGNoYXIpKVxuICAgICAgYWN0aXZlID0gdHJ1ZTtcbiAgICBpZiAoY2hhciA9PT0gXCIoXCIpXG4gICAgICBsZXZlbCsrO1xuICAgIGlmIChjaGFyID09PSBcIilcIilcbiAgICAgIGxldmVsLS07XG4gICAgaWYgKCFhY3RpdmUpXG4gICAgICBjb250aW51ZTtcbiAgICBpZiAobGV2ZWwgPT09IDApIHtcbiAgICAgIGlmIChjaGFyID09PSBcIiBcIiAmJiBbXCJldmVudFwiLCBcImZ1bmN0aW9uXCIsIFwiXCJdLmluY2x1ZGVzKHJlc3VsdCkpXG4gICAgICAgIHJlc3VsdCA9IFwiXCI7XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmVzdWx0ICs9IGNoYXI7XG4gICAgICAgIGlmIChjaGFyID09PSBcIilcIikge1xuICAgICAgICAgIHZhbGlkID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChjaGFyID09PSBcIiBcIikge1xuICAgICAgaWYgKHNpZ25hdHVyZVtpIC0gMV0gIT09IFwiLFwiICYmIGN1cnJlbnQgIT09IFwiLFwiICYmIGN1cnJlbnQgIT09IFwiLChcIikge1xuICAgICAgICBjdXJyZW50ID0gXCJcIjtcbiAgICAgICAgYWN0aXZlID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgcmVzdWx0ICs9IGNoYXI7XG4gICAgY3VycmVudCArPSBjaGFyO1xuICB9XG4gIGlmICghdmFsaWQpXG4gICAgdGhyb3cgbmV3IEJhc2VFcnJvcihcIlVuYWJsZSB0byBub3JtYWxpemUgc2lnbmF0dXJlLlwiKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbnZhciBpbml0X25vcm1hbGl6ZVNpZ25hdHVyZSA9IF9fZXNtKCgpID0+IHtcbiAgaW5pdF9iYXNlKCk7XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy9oYXNoL3RvU2lnbmF0dXJlLmpzXG52YXIgdG9TaWduYXR1cmUgPSAoZGVmKSA9PiB7XG4gIGNvbnN0IGRlZl8gPSAoKCkgPT4ge1xuICAgIGlmICh0eXBlb2YgZGVmID09PSBcInN0cmluZ1wiKVxuICAgICAgcmV0dXJuIGRlZjtcbiAgICByZXR1cm4gZm9ybWF0QWJpSXRlbShkZWYpO1xuICB9KSgpO1xuICByZXR1cm4gbm9ybWFsaXplU2lnbmF0dXJlKGRlZl8pO1xufTtcbnZhciBpbml0X3RvU2lnbmF0dXJlID0gX19lc20oKCkgPT4ge1xuICBpbml0X2V4cG9ydHMoKTtcbiAgaW5pdF9ub3JtYWxpemVTaWduYXR1cmUoKTtcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL2hhc2gvdG9TaWduYXR1cmVIYXNoLmpzXG5mdW5jdGlvbiB0b1NpZ25hdHVyZUhhc2goZm4pIHtcbiAgcmV0dXJuIGhhc2hTaWduYXR1cmUodG9TaWduYXR1cmUoZm4pKTtcbn1cbnZhciBpbml0X3RvU2lnbmF0dXJlSGFzaCA9IF9fZXNtKCgpID0+IHtcbiAgaW5pdF9oYXNoU2lnbmF0dXJlKCk7XG4gIGluaXRfdG9TaWduYXR1cmUoKTtcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL2hhc2gvdG9FdmVudFNlbGVjdG9yLmpzXG52YXIgdG9FdmVudFNlbGVjdG9yO1xudmFyIGluaXRfdG9FdmVudFNlbGVjdG9yID0gX19lc20oKCkgPT4ge1xuICBpbml0X3RvU2lnbmF0dXJlSGFzaCgpO1xuICB0b0V2ZW50U2VsZWN0b3IgPSB0b1NpZ25hdHVyZUhhc2g7XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS9lcnJvcnMvYWRkcmVzcy5qc1xudmFyIEludmFsaWRBZGRyZXNzRXJyb3I7XG52YXIgaW5pdF9hZGRyZXNzID0gX19lc20oKCkgPT4ge1xuICBpbml0X2Jhc2UoKTtcbiAgSW52YWxpZEFkZHJlc3NFcnJvciA9IGNsYXNzIEludmFsaWRBZGRyZXNzRXJyb3IgZXh0ZW5kcyBCYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgYWRkcmVzcyB9KSB7XG4gICAgICBzdXBlcihgQWRkcmVzcyBcIiR7YWRkcmVzc31cIiBpcyBpbnZhbGlkLmAsIHtcbiAgICAgICAgbWV0YU1lc3NhZ2VzOiBbXG4gICAgICAgICAgXCItIEFkZHJlc3MgbXVzdCBiZSBhIGhleCB2YWx1ZSBvZiAyMCBieXRlcyAoNDAgaGV4IGNoYXJhY3RlcnMpLlwiLFxuICAgICAgICAgIFwiLSBBZGRyZXNzIG11c3QgbWF0Y2ggaXRzIGNoZWNrc3VtIGNvdW50ZXJwYXJ0LlwiXG4gICAgICAgIF0sXG4gICAgICAgIG5hbWU6IFwiSW52YWxpZEFkZHJlc3NFcnJvclwiXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy9scnUuanNcbnZhciBMcnVNYXA7XG52YXIgaW5pdF9scnUgPSBfX2VzbSgoKSA9PiB7XG4gIExydU1hcCA9IGNsYXNzIExydU1hcCBleHRlbmRzIE1hcCB7XG4gICAgY29uc3RydWN0b3Ioc2l6ZTIpIHtcbiAgICAgIHN1cGVyKCk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtYXhTaXplXCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZFxuICAgICAgfSk7XG4gICAgICB0aGlzLm1heFNpemUgPSBzaXplMjtcbiAgICB9XG4gICAgZ2V0KGtleSkge1xuICAgICAgY29uc3QgdmFsdWUgPSBzdXBlci5nZXQoa2V5KTtcbiAgICAgIGlmIChzdXBlci5oYXMoa2V5KSAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuZGVsZXRlKGtleSk7XG4gICAgICAgIHN1cGVyLnNldChrZXksIHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgIHN1cGVyLnNldChrZXksIHZhbHVlKTtcbiAgICAgIGlmICh0aGlzLm1heFNpemUgJiYgdGhpcy5zaXplID4gdGhpcy5tYXhTaXplKSB7XG4gICAgICAgIGNvbnN0IGZpcnN0S2V5ID0gdGhpcy5rZXlzKCkubmV4dCgpLnZhbHVlO1xuICAgICAgICBpZiAoZmlyc3RLZXkpXG4gICAgICAgICAgdGhpcy5kZWxldGUoZmlyc3RLZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9O1xufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy92aWVtL19lc20vdXRpbHMvYWRkcmVzcy9nZXRBZGRyZXNzLmpzXG5mdW5jdGlvbiBjaGVja3N1bUFkZHJlc3MoYWRkcmVzc18sIGNoYWluSWQpIHtcbiAgaWYgKGNoZWNrc3VtQWRkcmVzc0NhY2hlLmhhcyhgJHthZGRyZXNzX30uJHtjaGFpbklkfWApKVxuICAgIHJldHVybiBjaGVja3N1bUFkZHJlc3NDYWNoZS5nZXQoYCR7YWRkcmVzc199LiR7Y2hhaW5JZH1gKTtcbiAgY29uc3QgaGV4QWRkcmVzcyA9IGNoYWluSWQgPyBgJHtjaGFpbklkfSR7YWRkcmVzc18udG9Mb3dlckNhc2UoKX1gIDogYWRkcmVzc18uc3Vic3RyaW5nKDIpLnRvTG93ZXJDYXNlKCk7XG4gIGNvbnN0IGhhc2gyID0ga2VjY2FrMjU2KHN0cmluZ1RvQnl0ZXMoaGV4QWRkcmVzcyksIFwiYnl0ZXNcIik7XG4gIGNvbnN0IGFkZHJlc3MgPSAoY2hhaW5JZCA/IGhleEFkZHJlc3Muc3Vic3RyaW5nKGAke2NoYWluSWR9MHhgLmxlbmd0aCkgOiBoZXhBZGRyZXNzKS5zcGxpdChcIlwiKTtcbiAgZm9yIChsZXQgaSA9IDA7aSA8IDQwOyBpICs9IDIpIHtcbiAgICBpZiAoaGFzaDJbaSA+PiAxXSA+PiA0ID49IDggJiYgYWRkcmVzc1tpXSkge1xuICAgICAgYWRkcmVzc1tpXSA9IGFkZHJlc3NbaV0udG9VcHBlckNhc2UoKTtcbiAgICB9XG4gICAgaWYgKChoYXNoMltpID4+IDFdICYgMTUpID49IDggJiYgYWRkcmVzc1tpICsgMV0pIHtcbiAgICAgIGFkZHJlc3NbaSArIDFdID0gYWRkcmVzc1tpICsgMV0udG9VcHBlckNhc2UoKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgcmVzdWx0ID0gYDB4JHthZGRyZXNzLmpvaW4oXCJcIil9YDtcbiAgY2hlY2tzdW1BZGRyZXNzQ2FjaGUuc2V0KGAke2FkZHJlc3NffS4ke2NoYWluSWR9YCwgcmVzdWx0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdldEFkZHJlc3MoYWRkcmVzcywgY2hhaW5JZCkge1xuICBpZiAoIWlzQWRkcmVzcyhhZGRyZXNzLCB7IHN0cmljdDogZmFsc2UgfSkpXG4gICAgdGhyb3cgbmV3IEludmFsaWRBZGRyZXNzRXJyb3IoeyBhZGRyZXNzIH0pO1xuICByZXR1cm4gY2hlY2tzdW1BZGRyZXNzKGFkZHJlc3MsIGNoYWluSWQpO1xufVxudmFyIGNoZWNrc3VtQWRkcmVzc0NhY2hlO1xudmFyIGluaXRfZ2V0QWRkcmVzcyA9IF9fZXNtKCgpID0+IHtcbiAgaW5pdF9hZGRyZXNzKCk7XG4gIGluaXRfdG9CeXRlcygpO1xuICBpbml0X2tlY2NhazI1NigpO1xuICBpbml0X2xydSgpO1xuICBpbml0X2lzQWRkcmVzcygpO1xuICBjaGVja3N1bUFkZHJlc3NDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTHJ1TWFwKDgxOTIpO1xufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy92aWVtL19lc20vdXRpbHMvYWRkcmVzcy9pc0FkZHJlc3MuanNcbmZ1bmN0aW9uIGlzQWRkcmVzcyhhZGRyZXNzLCBvcHRpb25zKSB7XG4gIGNvbnN0IHsgc3RyaWN0ID0gdHJ1ZSB9ID0gb3B0aW9ucyA/PyB7fTtcbiAgY29uc3QgY2FjaGVLZXkgPSBgJHthZGRyZXNzfS4ke3N0cmljdH1gO1xuICBpZiAoaXNBZGRyZXNzQ2FjaGUuaGFzKGNhY2hlS2V5KSlcbiAgICByZXR1cm4gaXNBZGRyZXNzQ2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgY29uc3QgcmVzdWx0ID0gKCgpID0+IHtcbiAgICBpZiAoIWFkZHJlc3NSZWdleC50ZXN0KGFkZHJlc3MpKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChhZGRyZXNzLnRvTG93ZXJDYXNlKCkgPT09IGFkZHJlc3MpXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoc3RyaWN0KVxuICAgICAgcmV0dXJuIGNoZWNrc3VtQWRkcmVzcyhhZGRyZXNzKSA9PT0gYWRkcmVzcztcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSkoKTtcbiAgaXNBZGRyZXNzQ2FjaGUuc2V0KGNhY2hlS2V5LCByZXN1bHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxudmFyIGFkZHJlc3NSZWdleCwgaXNBZGRyZXNzQ2FjaGU7XG52YXIgaW5pdF9pc0FkZHJlc3MgPSBfX2VzbSgoKSA9PiB7XG4gIGluaXRfbHJ1KCk7XG4gIGluaXRfZ2V0QWRkcmVzcygpO1xuICBhZGRyZXNzUmVnZXggPSAvXjB4W2EtZkEtRjAtOV17NDB9JC87XG4gIGlzQWRkcmVzc0NhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBMcnVNYXAoODE5Mik7XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy9kYXRhL2NvbmNhdC5qc1xuZnVuY3Rpb24gY29uY2F0KHZhbHVlcykge1xuICBpZiAodHlwZW9mIHZhbHVlc1swXSA9PT0gXCJzdHJpbmdcIilcbiAgICByZXR1cm4gY29uY2F0SGV4KHZhbHVlcyk7XG4gIHJldHVybiBjb25jYXRCeXRlcyh2YWx1ZXMpO1xufVxuZnVuY3Rpb24gY29uY2F0Qnl0ZXModmFsdWVzKSB7XG4gIGxldCBsZW5ndGggPSAwO1xuICBmb3IgKGNvbnN0IGFyciBvZiB2YWx1ZXMpIHtcbiAgICBsZW5ndGggKz0gYXJyLmxlbmd0aDtcbiAgfVxuICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICBsZXQgb2Zmc2V0ID0gMDtcbiAgZm9yIChjb25zdCBhcnIgb2YgdmFsdWVzKSB7XG4gICAgcmVzdWx0LnNldChhcnIsIG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IGFyci5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGNvbmNhdEhleCh2YWx1ZXMpIHtcbiAgcmV0dXJuIGAweCR7dmFsdWVzLnJlZHVjZSgoYWNjLCB4KSA9PiBhY2MgKyB4LnJlcGxhY2UoXCIweFwiLCBcIlwiKSwgXCJcIil9YDtcbn1cblxuLy8gbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy9kYXRhL3NsaWNlLmpzXG5mdW5jdGlvbiBzbGljZSh2YWx1ZSwgc3RhcnQsIGVuZCwgeyBzdHJpY3QgfSA9IHt9KSB7XG4gIGlmIChpc0hleCh2YWx1ZSwgeyBzdHJpY3Q6IGZhbHNlIH0pKVxuICAgIHJldHVybiBzbGljZUhleCh2YWx1ZSwgc3RhcnQsIGVuZCwge1xuICAgICAgc3RyaWN0XG4gICAgfSk7XG4gIHJldHVybiBzbGljZUJ5dGVzKHZhbHVlLCBzdGFydCwgZW5kLCB7XG4gICAgc3RyaWN0XG4gIH0pO1xufVxuZnVuY3Rpb24gYXNzZXJ0U3RhcnRPZmZzZXQodmFsdWUsIHN0YXJ0KSB7XG4gIGlmICh0eXBlb2Ygc3RhcnQgPT09IFwibnVtYmVyXCIgJiYgc3RhcnQgPiAwICYmIHN0YXJ0ID4gc2l6ZSh2YWx1ZSkgLSAxKVxuICAgIHRocm93IG5ldyBTbGljZU9mZnNldE91dE9mQm91bmRzRXJyb3Ioe1xuICAgICAgb2Zmc2V0OiBzdGFydCxcbiAgICAgIHBvc2l0aW9uOiBcInN0YXJ0XCIsXG4gICAgICBzaXplOiBzaXplKHZhbHVlKVxuICAgIH0pO1xufVxuZnVuY3Rpb24gYXNzZXJ0RW5kT2Zmc2V0KHZhbHVlLCBzdGFydCwgZW5kKSB7XG4gIGlmICh0eXBlb2Ygc3RhcnQgPT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIGVuZCA9PT0gXCJudW1iZXJcIiAmJiBzaXplKHZhbHVlKSAhPT0gZW5kIC0gc3RhcnQpIHtcbiAgICB0aHJvdyBuZXcgU2xpY2VPZmZzZXRPdXRPZkJvdW5kc0Vycm9yKHtcbiAgICAgIG9mZnNldDogZW5kLFxuICAgICAgcG9zaXRpb246IFwiZW5kXCIsXG4gICAgICBzaXplOiBzaXplKHZhbHVlKVxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBzbGljZUJ5dGVzKHZhbHVlXywgc3RhcnQsIGVuZCwgeyBzdHJpY3QgfSA9IHt9KSB7XG4gIGFzc2VydFN0YXJ0T2Zmc2V0KHZhbHVlXywgc3RhcnQpO1xuICBjb25zdCB2YWx1ZSA9IHZhbHVlXy5zbGljZShzdGFydCwgZW5kKTtcbiAgaWYgKHN0cmljdClcbiAgICBhc3NlcnRFbmRPZmZzZXQodmFsdWUsIHN0YXJ0LCBlbmQpO1xuICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBzbGljZUhleCh2YWx1ZV8sIHN0YXJ0LCBlbmQsIHsgc3RyaWN0IH0gPSB7fSkge1xuICBhc3NlcnRTdGFydE9mZnNldCh2YWx1ZV8sIHN0YXJ0KTtcbiAgY29uc3QgdmFsdWUgPSBgMHgke3ZhbHVlXy5yZXBsYWNlKFwiMHhcIiwgXCJcIikuc2xpY2UoKHN0YXJ0ID8/IDApICogMiwgKGVuZCA/PyB2YWx1ZV8ubGVuZ3RoKSAqIDIpfWA7XG4gIGlmIChzdHJpY3QpXG4gICAgYXNzZXJ0RW5kT2Zmc2V0KHZhbHVlLCBzdGFydCwgZW5kKTtcbiAgcmV0dXJuIHZhbHVlO1xufVxudmFyIGluaXRfc2xpY2UgPSBfX2VzbSgoKSA9PiB7XG4gIGluaXRfZGF0YSgpO1xuICBpbml0X3NpemUoKTtcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL3JlZ2V4LmpzXG52YXIgYXJyYXlSZWdleCwgYnl0ZXNSZWdleCwgaW50ZWdlclJlZ2V4O1xudmFyIGluaXRfcmVnZXgyID0gX19lc20oKCkgPT4ge1xuICBhcnJheVJlZ2V4ID0gL14oLiopXFxbKFswLTldKilcXF0kLztcbiAgYnl0ZXNSZWdleCA9IC9eYnl0ZXMoWzEtOV18MVswLTldfDJbMC05XXwzWzAtMl0pPyQvO1xuICBpbnRlZ2VyUmVnZXggPSAvXih1P2ludCkoOHwxNnwyNHwzMnw0MHw0OHw1Nnw2NHw3Mnw4MHw4OHw5NnwxMDR8MTEyfDEyMHwxMjh8MTM2fDE0NHwxNTJ8MTYwfDE2OHwxNzZ8MTg0fDE5MnwyMDB8MjA4fDIxNnwyMjR8MjMyfDI0MHwyNDh8MjU2KT8kLztcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL2FiaS9lbmNvZGVBYmlQYXJhbWV0ZXJzLmpzXG5mdW5jdGlvbiBlbmNvZGVBYmlQYXJhbWV0ZXJzKHBhcmFtcywgdmFsdWVzKSB7XG4gIGlmIChwYXJhbXMubGVuZ3RoICE9PSB2YWx1ZXMubGVuZ3RoKVxuICAgIHRocm93IG5ldyBBYmlFbmNvZGluZ0xlbmd0aE1pc21hdGNoRXJyb3Ioe1xuICAgICAgZXhwZWN0ZWRMZW5ndGg6IHBhcmFtcy5sZW5ndGgsXG4gICAgICBnaXZlbkxlbmd0aDogdmFsdWVzLmxlbmd0aFxuICAgIH0pO1xuICBjb25zdCBwcmVwYXJlZFBhcmFtcyA9IHByZXBhcmVQYXJhbXMoe1xuICAgIHBhcmFtcyxcbiAgICB2YWx1ZXNcbiAgfSk7XG4gIGNvbnN0IGRhdGEgPSBlbmNvZGVQYXJhbXMocHJlcGFyZWRQYXJhbXMpO1xuICBpZiAoZGF0YS5sZW5ndGggPT09IDApXG4gICAgcmV0dXJuIFwiMHhcIjtcbiAgcmV0dXJuIGRhdGE7XG59XG5mdW5jdGlvbiBwcmVwYXJlUGFyYW1zKHsgcGFyYW1zLCB2YWx1ZXMgfSkge1xuICBjb25zdCBwcmVwYXJlZFBhcmFtcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDtpIDwgcGFyYW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgcHJlcGFyZWRQYXJhbXMucHVzaChwcmVwYXJlUGFyYW0oeyBwYXJhbTogcGFyYW1zW2ldLCB2YWx1ZTogdmFsdWVzW2ldIH0pKTtcbiAgfVxuICByZXR1cm4gcHJlcGFyZWRQYXJhbXM7XG59XG5mdW5jdGlvbiBwcmVwYXJlUGFyYW0oeyBwYXJhbSwgdmFsdWUgfSkge1xuICBjb25zdCBhcnJheUNvbXBvbmVudHMgPSBnZXRBcnJheUNvbXBvbmVudHMocGFyYW0udHlwZSk7XG4gIGlmIChhcnJheUNvbXBvbmVudHMpIHtcbiAgICBjb25zdCBbbGVuZ3RoLCB0eXBlXSA9IGFycmF5Q29tcG9uZW50cztcbiAgICByZXR1cm4gZW5jb2RlQXJyYXkodmFsdWUsIHsgbGVuZ3RoLCBwYXJhbTogeyAuLi5wYXJhbSwgdHlwZSB9IH0pO1xuICB9XG4gIGlmIChwYXJhbS50eXBlID09PSBcInR1cGxlXCIpIHtcbiAgICByZXR1cm4gZW5jb2RlVHVwbGUodmFsdWUsIHtcbiAgICAgIHBhcmFtXG4gICAgfSk7XG4gIH1cbiAgaWYgKHBhcmFtLnR5cGUgPT09IFwiYWRkcmVzc1wiKSB7XG4gICAgcmV0dXJuIGVuY29kZUFkZHJlc3ModmFsdWUpO1xuICB9XG4gIGlmIChwYXJhbS50eXBlID09PSBcImJvb2xcIikge1xuICAgIHJldHVybiBlbmNvZGVCb29sKHZhbHVlKTtcbiAgfVxuICBpZiAocGFyYW0udHlwZS5zdGFydHNXaXRoKFwidWludFwiKSB8fCBwYXJhbS50eXBlLnN0YXJ0c1dpdGgoXCJpbnRcIikpIHtcbiAgICBjb25zdCBzaWduZWQgPSBwYXJhbS50eXBlLnN0YXJ0c1dpdGgoXCJpbnRcIik7XG4gICAgY29uc3QgWywgLCBzaXplMiA9IFwiMjU2XCJdID0gaW50ZWdlclJlZ2V4LmV4ZWMocGFyYW0udHlwZSkgPz8gW107XG4gICAgcmV0dXJuIGVuY29kZU51bWJlcih2YWx1ZSwge1xuICAgICAgc2lnbmVkLFxuICAgICAgc2l6ZTogTnVtYmVyKHNpemUyKVxuICAgIH0pO1xuICB9XG4gIGlmIChwYXJhbS50eXBlLnN0YXJ0c1dpdGgoXCJieXRlc1wiKSkge1xuICAgIHJldHVybiBlbmNvZGVCeXRlcyh2YWx1ZSwgeyBwYXJhbSB9KTtcbiAgfVxuICBpZiAocGFyYW0udHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBlbmNvZGVTdHJpbmcodmFsdWUpO1xuICB9XG4gIHRocm93IG5ldyBJbnZhbGlkQWJpRW5jb2RpbmdUeXBlRXJyb3IocGFyYW0udHlwZSwge1xuICAgIGRvY3NQYXRoOiBcIi9kb2NzL2NvbnRyYWN0L2VuY29kZUFiaVBhcmFtZXRlcnNcIlxuICB9KTtcbn1cbmZ1bmN0aW9uIGVuY29kZVBhcmFtcyhwcmVwYXJlZFBhcmFtcykge1xuICBsZXQgc3RhdGljU2l6ZSA9IDA7XG4gIGZvciAobGV0IGkgPSAwO2kgPCBwcmVwYXJlZFBhcmFtcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHsgZHluYW1pYywgZW5jb2RlZCB9ID0gcHJlcGFyZWRQYXJhbXNbaV07XG4gICAgaWYgKGR5bmFtaWMpXG4gICAgICBzdGF0aWNTaXplICs9IDMyO1xuICAgIGVsc2VcbiAgICAgIHN0YXRpY1NpemUgKz0gc2l6ZShlbmNvZGVkKTtcbiAgfVxuICBjb25zdCBzdGF0aWNQYXJhbXMgPSBbXTtcbiAgY29uc3QgZHluYW1pY1BhcmFtcyA9IFtdO1xuICBsZXQgZHluYW1pY1NpemUgPSAwO1xuICBmb3IgKGxldCBpID0gMDtpIDwgcHJlcGFyZWRQYXJhbXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB7IGR5bmFtaWMsIGVuY29kZWQgfSA9IHByZXBhcmVkUGFyYW1zW2ldO1xuICAgIGlmIChkeW5hbWljKSB7XG4gICAgICBzdGF0aWNQYXJhbXMucHVzaChudW1iZXJUb0hleChzdGF0aWNTaXplICsgZHluYW1pY1NpemUsIHsgc2l6ZTogMzIgfSkpO1xuICAgICAgZHluYW1pY1BhcmFtcy5wdXNoKGVuY29kZWQpO1xuICAgICAgZHluYW1pY1NpemUgKz0gc2l6ZShlbmNvZGVkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGljUGFyYW1zLnB1c2goZW5jb2RlZCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBjb25jYXQoWy4uLnN0YXRpY1BhcmFtcywgLi4uZHluYW1pY1BhcmFtc10pO1xufVxuZnVuY3Rpb24gZW5jb2RlQWRkcmVzcyh2YWx1ZSkge1xuICBpZiAoIWlzQWRkcmVzcyh2YWx1ZSkpXG4gICAgdGhyb3cgbmV3IEludmFsaWRBZGRyZXNzRXJyb3IoeyBhZGRyZXNzOiB2YWx1ZSB9KTtcbiAgcmV0dXJuIHsgZHluYW1pYzogZmFsc2UsIGVuY29kZWQ6IHBhZEhleCh2YWx1ZS50b0xvd2VyQ2FzZSgpKSB9O1xufVxuZnVuY3Rpb24gZW5jb2RlQXJyYXkodmFsdWUsIHsgbGVuZ3RoLCBwYXJhbSB9KSB7XG4gIGNvbnN0IGR5bmFtaWMgPSBsZW5ndGggPT09IG51bGw7XG4gIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpXG4gICAgdGhyb3cgbmV3IEludmFsaWRBcnJheUVycm9yKHZhbHVlKTtcbiAgaWYgKCFkeW5hbWljICYmIHZhbHVlLmxlbmd0aCAhPT0gbGVuZ3RoKVxuICAgIHRocm93IG5ldyBBYmlFbmNvZGluZ0FycmF5TGVuZ3RoTWlzbWF0Y2hFcnJvcih7XG4gICAgICBleHBlY3RlZExlbmd0aDogbGVuZ3RoLFxuICAgICAgZ2l2ZW5MZW5ndGg6IHZhbHVlLmxlbmd0aCxcbiAgICAgIHR5cGU6IGAke3BhcmFtLnR5cGV9WyR7bGVuZ3RofV1gXG4gICAgfSk7XG4gIGxldCBkeW5hbWljQ2hpbGQgPSBmYWxzZTtcbiAgY29uc3QgcHJlcGFyZWRQYXJhbXMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7aSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgcHJlcGFyZWRQYXJhbSA9IHByZXBhcmVQYXJhbSh7IHBhcmFtLCB2YWx1ZTogdmFsdWVbaV0gfSk7XG4gICAgaWYgKHByZXBhcmVkUGFyYW0uZHluYW1pYylcbiAgICAgIGR5bmFtaWNDaGlsZCA9IHRydWU7XG4gICAgcHJlcGFyZWRQYXJhbXMucHVzaChwcmVwYXJlZFBhcmFtKTtcbiAgfVxuICBpZiAoZHluYW1pYyB8fCBkeW5hbWljQ2hpbGQpIHtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlUGFyYW1zKHByZXBhcmVkUGFyYW1zKTtcbiAgICBpZiAoZHluYW1pYykge1xuICAgICAgY29uc3QgbGVuZ3RoMiA9IG51bWJlclRvSGV4KHByZXBhcmVkUGFyYW1zLmxlbmd0aCwgeyBzaXplOiAzMiB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGR5bmFtaWM6IHRydWUsXG4gICAgICAgIGVuY29kZWQ6IHByZXBhcmVkUGFyYW1zLmxlbmd0aCA+IDAgPyBjb25jYXQoW2xlbmd0aDIsIGRhdGFdKSA6IGxlbmd0aDJcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChkeW5hbWljQ2hpbGQpXG4gICAgICByZXR1cm4geyBkeW5hbWljOiB0cnVlLCBlbmNvZGVkOiBkYXRhIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBkeW5hbWljOiBmYWxzZSxcbiAgICBlbmNvZGVkOiBjb25jYXQocHJlcGFyZWRQYXJhbXMubWFwKCh7IGVuY29kZWQgfSkgPT4gZW5jb2RlZCkpXG4gIH07XG59XG5mdW5jdGlvbiBlbmNvZGVCeXRlcyh2YWx1ZSwgeyBwYXJhbSB9KSB7XG4gIGNvbnN0IFssIHBhcmFtU2l6ZV0gPSBwYXJhbS50eXBlLnNwbGl0KFwiYnl0ZXNcIik7XG4gIGNvbnN0IGJ5dGVzU2l6ZSA9IHNpemUodmFsdWUpO1xuICBpZiAoIXBhcmFtU2l6ZSkge1xuICAgIGxldCB2YWx1ZV8gPSB2YWx1ZTtcbiAgICBpZiAoYnl0ZXNTaXplICUgMzIgIT09IDApXG4gICAgICB2YWx1ZV8gPSBwYWRIZXgodmFsdWVfLCB7XG4gICAgICAgIGRpcjogXCJyaWdodFwiLFxuICAgICAgICBzaXplOiBNYXRoLmNlaWwoKHZhbHVlLmxlbmd0aCAtIDIpIC8gMiAvIDMyKSAqIDMyXG4gICAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgZHluYW1pYzogdHJ1ZSxcbiAgICAgIGVuY29kZWQ6IGNvbmNhdChbcGFkSGV4KG51bWJlclRvSGV4KGJ5dGVzU2l6ZSwgeyBzaXplOiAzMiB9KSksIHZhbHVlX10pXG4gICAgfTtcbiAgfVxuICBpZiAoYnl0ZXNTaXplICE9PSBOdW1iZXIucGFyc2VJbnQocGFyYW1TaXplKSlcbiAgICB0aHJvdyBuZXcgQWJpRW5jb2RpbmdCeXRlc1NpemVNaXNtYXRjaEVycm9yKHtcbiAgICAgIGV4cGVjdGVkU2l6ZTogTnVtYmVyLnBhcnNlSW50KHBhcmFtU2l6ZSksXG4gICAgICB2YWx1ZVxuICAgIH0pO1xuICByZXR1cm4geyBkeW5hbWljOiBmYWxzZSwgZW5jb2RlZDogcGFkSGV4KHZhbHVlLCB7IGRpcjogXCJyaWdodFwiIH0pIH07XG59XG5mdW5jdGlvbiBlbmNvZGVCb29sKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwiYm9vbGVhblwiKVxuICAgIHRocm93IG5ldyBCYXNlRXJyb3IoYEludmFsaWQgYm9vbGVhbiB2YWx1ZTogXCIke3ZhbHVlfVwiICh0eXBlOiAke3R5cGVvZiB2YWx1ZX0pLiBFeHBlY3RlZDogXFxgdHJ1ZVxcYCBvciBcXGBmYWxzZVxcYC5gKTtcbiAgcmV0dXJuIHsgZHluYW1pYzogZmFsc2UsIGVuY29kZWQ6IHBhZEhleChib29sVG9IZXgodmFsdWUpKSB9O1xufVxuZnVuY3Rpb24gZW5jb2RlTnVtYmVyKHZhbHVlLCB7IHNpZ25lZCwgc2l6ZTogc2l6ZTIgPSAyNTYgfSkge1xuICBpZiAodHlwZW9mIHNpemUyID09PSBcIm51bWJlclwiKSB7XG4gICAgY29uc3QgbWF4ID0gMm4gKiogKEJpZ0ludChzaXplMikgLSAoc2lnbmVkID8gMW4gOiAwbikpIC0gMW47XG4gICAgY29uc3QgbWluID0gc2lnbmVkID8gLW1heCAtIDFuIDogMG47XG4gICAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKVxuICAgICAgdGhyb3cgbmV3IEludGVnZXJPdXRPZlJhbmdlRXJyb3Ioe1xuICAgICAgICBtYXg6IG1heC50b1N0cmluZygpLFxuICAgICAgICBtaW46IG1pbi50b1N0cmluZygpLFxuICAgICAgICBzaWduZWQsXG4gICAgICAgIHNpemU6IHNpemUyIC8gOCxcbiAgICAgICAgdmFsdWU6IHZhbHVlLnRvU3RyaW5nKClcbiAgICAgIH0pO1xuICB9XG4gIHJldHVybiB7XG4gICAgZHluYW1pYzogZmFsc2UsXG4gICAgZW5jb2RlZDogbnVtYmVyVG9IZXgodmFsdWUsIHtcbiAgICAgIHNpemU6IDMyLFxuICAgICAgc2lnbmVkXG4gICAgfSlcbiAgfTtcbn1cbmZ1bmN0aW9uIGVuY29kZVN0cmluZyh2YWx1ZSkge1xuICBjb25zdCBoZXhWYWx1ZSA9IHN0cmluZ1RvSGV4KHZhbHVlKTtcbiAgY29uc3QgcGFydHNMZW5ndGggPSBNYXRoLmNlaWwoc2l6ZShoZXhWYWx1ZSkgLyAzMik7XG4gIGNvbnN0IHBhcnRzID0gW107XG4gIGZvciAobGV0IGkgPSAwO2kgPCBwYXJ0c0xlbmd0aDsgaSsrKSB7XG4gICAgcGFydHMucHVzaChwYWRIZXgoc2xpY2UoaGV4VmFsdWUsIGkgKiAzMiwgKGkgKyAxKSAqIDMyKSwge1xuICAgICAgZGlyOiBcInJpZ2h0XCJcbiAgICB9KSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBkeW5hbWljOiB0cnVlLFxuICAgIGVuY29kZWQ6IGNvbmNhdChbXG4gICAgICBwYWRIZXgobnVtYmVyVG9IZXgoc2l6ZShoZXhWYWx1ZSksIHsgc2l6ZTogMzIgfSkpLFxuICAgICAgLi4ucGFydHNcbiAgICBdKVxuICB9O1xufVxuZnVuY3Rpb24gZW5jb2RlVHVwbGUodmFsdWUsIHsgcGFyYW0gfSkge1xuICBsZXQgZHluYW1pYyA9IGZhbHNlO1xuICBjb25zdCBwcmVwYXJlZFBhcmFtcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDtpIDwgcGFyYW0uY29tcG9uZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHBhcmFtXyA9IHBhcmFtLmNvbXBvbmVudHNbaV07XG4gICAgY29uc3QgaW5kZXggPSBBcnJheS5pc0FycmF5KHZhbHVlKSA/IGkgOiBwYXJhbV8ubmFtZTtcbiAgICBjb25zdCBwcmVwYXJlZFBhcmFtID0gcHJlcGFyZVBhcmFtKHtcbiAgICAgIHBhcmFtOiBwYXJhbV8sXG4gICAgICB2YWx1ZTogdmFsdWVbaW5kZXhdXG4gICAgfSk7XG4gICAgcHJlcGFyZWRQYXJhbXMucHVzaChwcmVwYXJlZFBhcmFtKTtcbiAgICBpZiAocHJlcGFyZWRQYXJhbS5keW5hbWljKVxuICAgICAgZHluYW1pYyA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBkeW5hbWljLFxuICAgIGVuY29kZWQ6IGR5bmFtaWMgPyBlbmNvZGVQYXJhbXMocHJlcGFyZWRQYXJhbXMpIDogY29uY2F0KHByZXBhcmVkUGFyYW1zLm1hcCgoeyBlbmNvZGVkIH0pID0+IGVuY29kZWQpKVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0QXJyYXlDb21wb25lbnRzKHR5cGUpIHtcbiAgY29uc3QgbWF0Y2hlcyA9IHR5cGUubWF0Y2goL14oLiopXFxbKFxcZCspP1xcXSQvKTtcbiAgcmV0dXJuIG1hdGNoZXMgPyBbbWF0Y2hlc1syXSA/IE51bWJlcihtYXRjaGVzWzJdKSA6IG51bGwsIG1hdGNoZXNbMV1dIDogdW5kZWZpbmVkO1xufVxudmFyIGluaXRfZW5jb2RlQWJpUGFyYW1ldGVycyA9IF9fZXNtKCgpID0+IHtcbiAgaW5pdF9hYmkoKTtcbiAgaW5pdF9hZGRyZXNzKCk7XG4gIGluaXRfYmFzZSgpO1xuICBpbml0X2VuY29kaW5nKCk7XG4gIGluaXRfaXNBZGRyZXNzKCk7XG4gIGluaXRfcGFkKCk7XG4gIGluaXRfc2l6ZSgpO1xuICBpbml0X3NsaWNlKCk7XG4gIGluaXRfdG9IZXgoKTtcbiAgaW5pdF9yZWdleDIoKTtcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL2hhc2gvdG9GdW5jdGlvblNlbGVjdG9yLmpzXG52YXIgdG9GdW5jdGlvblNlbGVjdG9yID0gKGZuKSA9PiBzbGljZSh0b1NpZ25hdHVyZUhhc2goZm4pLCAwLCA0KTtcbnZhciBpbml0X3RvRnVuY3Rpb25TZWxlY3RvciA9IF9fZXNtKCgpID0+IHtcbiAgaW5pdF9zbGljZSgpO1xuICBpbml0X3RvU2lnbmF0dXJlSGFzaCgpO1xufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy92aWVtL19lc20vdXRpbHMvYWJpL2dldEFiaUl0ZW0uanNcbmZ1bmN0aW9uIGdldEFiaUl0ZW0ocGFyYW1ldGVycykge1xuICBjb25zdCB7IGFiaSwgYXJncyA9IFtdLCBuYW1lIH0gPSBwYXJhbWV0ZXJzO1xuICBjb25zdCBpc1NlbGVjdG9yID0gaXNIZXgobmFtZSwgeyBzdHJpY3Q6IGZhbHNlIH0pO1xuICBjb25zdCBhYmlJdGVtcyA9IGFiaS5maWx0ZXIoKGFiaUl0ZW0pID0+IHtcbiAgICBpZiAoaXNTZWxlY3Rvcikge1xuICAgICAgaWYgKGFiaUl0ZW0udHlwZSA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICByZXR1cm4gdG9GdW5jdGlvblNlbGVjdG9yKGFiaUl0ZW0pID09PSBuYW1lO1xuICAgICAgaWYgKGFiaUl0ZW0udHlwZSA9PT0gXCJldmVudFwiKVxuICAgICAgICByZXR1cm4gdG9FdmVudFNlbGVjdG9yKGFiaUl0ZW0pID09PSBuYW1lO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gXCJuYW1lXCIgaW4gYWJpSXRlbSAmJiBhYmlJdGVtLm5hbWUgPT09IG5hbWU7XG4gIH0pO1xuICBpZiAoYWJpSXRlbXMubGVuZ3RoID09PSAwKVxuICAgIHJldHVybjtcbiAgaWYgKGFiaUl0ZW1zLmxlbmd0aCA9PT0gMSlcbiAgICByZXR1cm4gYWJpSXRlbXNbMF07XG4gIGxldCBtYXRjaGVkQWJpSXRlbSA9IHVuZGVmaW5lZDtcbiAgZm9yIChjb25zdCBhYmlJdGVtIG9mIGFiaUl0ZW1zKSB7XG4gICAgaWYgKCEoXCJpbnB1dHNcIiBpbiBhYmlJdGVtKSlcbiAgICAgIGNvbnRpbnVlO1xuICAgIGlmICghYXJncyB8fCBhcmdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaWYgKCFhYmlJdGVtLmlucHV0cyB8fCBhYmlJdGVtLmlucHV0cy5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiBhYmlJdGVtO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmICghYWJpSXRlbS5pbnB1dHMpXG4gICAgICBjb250aW51ZTtcbiAgICBpZiAoYWJpSXRlbS5pbnB1dHMubGVuZ3RoID09PSAwKVxuICAgICAgY29udGludWU7XG4gICAgaWYgKGFiaUl0ZW0uaW5wdXRzLmxlbmd0aCAhPT0gYXJncy5sZW5ndGgpXG4gICAgICBjb250aW51ZTtcbiAgICBjb25zdCBtYXRjaGVkID0gYXJncy5ldmVyeSgoYXJnLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgYWJpUGFyYW1ldGVyID0gXCJpbnB1dHNcIiBpbiBhYmlJdGVtICYmIGFiaUl0ZW0uaW5wdXRzW2luZGV4XTtcbiAgICAgIGlmICghYWJpUGFyYW1ldGVyKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICByZXR1cm4gaXNBcmdPZlR5cGUoYXJnLCBhYmlQYXJhbWV0ZXIpO1xuICAgIH0pO1xuICAgIGlmIChtYXRjaGVkKSB7XG4gICAgICBpZiAobWF0Y2hlZEFiaUl0ZW0gJiYgXCJpbnB1dHNcIiBpbiBtYXRjaGVkQWJpSXRlbSAmJiBtYXRjaGVkQWJpSXRlbS5pbnB1dHMpIHtcbiAgICAgICAgY29uc3QgYW1iaWd1b3VzVHlwZXMgPSBnZXRBbWJpZ3VvdXNUeXBlcyhhYmlJdGVtLmlucHV0cywgbWF0Y2hlZEFiaUl0ZW0uaW5wdXRzLCBhcmdzKTtcbiAgICAgICAgaWYgKGFtYmlndW91c1R5cGVzKVxuICAgICAgICAgIHRocm93IG5ldyBBYmlJdGVtQW1iaWd1aXR5RXJyb3Ioe1xuICAgICAgICAgICAgYWJpSXRlbSxcbiAgICAgICAgICAgIHR5cGU6IGFtYmlndW91c1R5cGVzWzBdXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgYWJpSXRlbTogbWF0Y2hlZEFiaUl0ZW0sXG4gICAgICAgICAgICB0eXBlOiBhbWJpZ3VvdXNUeXBlc1sxXVxuICAgICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgbWF0Y2hlZEFiaUl0ZW0gPSBhYmlJdGVtO1xuICAgIH1cbiAgfVxuICBpZiAobWF0Y2hlZEFiaUl0ZW0pXG4gICAgcmV0dXJuIG1hdGNoZWRBYmlJdGVtO1xuICByZXR1cm4gYWJpSXRlbXNbMF07XG59XG5mdW5jdGlvbiBpc0FyZ09mVHlwZShhcmcsIGFiaVBhcmFtZXRlcikge1xuICBjb25zdCBhcmdUeXBlID0gdHlwZW9mIGFyZztcbiAgY29uc3QgYWJpUGFyYW1ldGVyVHlwZSA9IGFiaVBhcmFtZXRlci50eXBlO1xuICBzd2l0Y2ggKGFiaVBhcmFtZXRlclR5cGUpIHtcbiAgICBjYXNlIFwiYWRkcmVzc1wiOlxuICAgICAgcmV0dXJuIGlzQWRkcmVzcyhhcmcsIHsgc3RyaWN0OiBmYWxzZSB9KTtcbiAgICBjYXNlIFwiYm9vbFwiOlxuICAgICAgcmV0dXJuIGFyZ1R5cGUgPT09IFwiYm9vbGVhblwiO1xuICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgcmV0dXJuIGFyZ1R5cGUgPT09IFwic3RyaW5nXCI7XG4gICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgcmV0dXJuIGFyZ1R5cGUgPT09IFwic3RyaW5nXCI7XG4gICAgZGVmYXVsdDoge1xuICAgICAgaWYgKGFiaVBhcmFtZXRlclR5cGUgPT09IFwidHVwbGVcIiAmJiBcImNvbXBvbmVudHNcIiBpbiBhYmlQYXJhbWV0ZXIpXG4gICAgICAgIHJldHVybiBPYmplY3QudmFsdWVzKGFiaVBhcmFtZXRlci5jb21wb25lbnRzKS5ldmVyeSgoY29tcG9uZW50LCBpbmRleCkgPT4ge1xuICAgICAgICAgIHJldHVybiBpc0FyZ09mVHlwZShPYmplY3QudmFsdWVzKGFyZylbaW5kZXhdLCBjb21wb25lbnQpO1xuICAgICAgICB9KTtcbiAgICAgIGlmICgvXnU/aW50KDh8MTZ8MjR8MzJ8NDB8NDh8NTZ8NjR8NzJ8ODB8ODh8OTZ8MTA0fDExMnwxMjB8MTI4fDEzNnwxNDR8MTUyfDE2MHwxNjh8MTc2fDE4NHwxOTJ8MjAwfDIwOHwyMTZ8MjI0fDIzMnwyNDB8MjQ4fDI1Nik/JC8udGVzdChhYmlQYXJhbWV0ZXJUeXBlKSlcbiAgICAgICAgcmV0dXJuIGFyZ1R5cGUgPT09IFwibnVtYmVyXCIgfHwgYXJnVHlwZSA9PT0gXCJiaWdpbnRcIjtcbiAgICAgIGlmICgvXmJ5dGVzKFsxLTldfDFbMC05XXwyWzAtOV18M1swLTJdKT8kLy50ZXN0KGFiaVBhcmFtZXRlclR5cGUpKVxuICAgICAgICByZXR1cm4gYXJnVHlwZSA9PT0gXCJzdHJpbmdcIiB8fCBhcmcgaW5zdGFuY2VvZiBVaW50OEFycmF5O1xuICAgICAgaWYgKC9bYS16XStbMS05XXswLDN9KFxcW1swLTldezAsfVxcXSkrJC8udGVzdChhYmlQYXJhbWV0ZXJUeXBlKSkge1xuICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShhcmcpICYmIGFyZy5ldmVyeSgoeCkgPT4gaXNBcmdPZlR5cGUoeCwge1xuICAgICAgICAgIC4uLmFiaVBhcmFtZXRlcixcbiAgICAgICAgICB0eXBlOiBhYmlQYXJhbWV0ZXJUeXBlLnJlcGxhY2UoLyhcXFtbMC05XXswLH1cXF0pJC8sIFwiXCIpXG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEFtYmlndW91c1R5cGVzKHNvdXJjZVBhcmFtZXRlcnMsIHRhcmdldFBhcmFtZXRlcnMsIGFyZ3MpIHtcbiAgZm9yIChjb25zdCBwYXJhbWV0ZXJJbmRleCBpbiBzb3VyY2VQYXJhbWV0ZXJzKSB7XG4gICAgY29uc3Qgc291cmNlUGFyYW1ldGVyID0gc291cmNlUGFyYW1ldGVyc1twYXJhbWV0ZXJJbmRleF07XG4gICAgY29uc3QgdGFyZ2V0UGFyYW1ldGVyID0gdGFyZ2V0UGFyYW1ldGVyc1twYXJhbWV0ZXJJbmRleF07XG4gICAgaWYgKHNvdXJjZVBhcmFtZXRlci50eXBlID09PSBcInR1cGxlXCIgJiYgdGFyZ2V0UGFyYW1ldGVyLnR5cGUgPT09IFwidHVwbGVcIiAmJiBcImNvbXBvbmVudHNcIiBpbiBzb3VyY2VQYXJhbWV0ZXIgJiYgXCJjb21wb25lbnRzXCIgaW4gdGFyZ2V0UGFyYW1ldGVyKVxuICAgICAgcmV0dXJuIGdldEFtYmlndW91c1R5cGVzKHNvdXJjZVBhcmFtZXRlci5jb21wb25lbnRzLCB0YXJnZXRQYXJhbWV0ZXIuY29tcG9uZW50cywgYXJnc1twYXJhbWV0ZXJJbmRleF0pO1xuICAgIGNvbnN0IHR5cGVzID0gW3NvdXJjZVBhcmFtZXRlci50eXBlLCB0YXJnZXRQYXJhbWV0ZXIudHlwZV07XG4gICAgY29uc3QgYW1iaWd1b3VzID0gKCgpID0+IHtcbiAgICAgIGlmICh0eXBlcy5pbmNsdWRlcyhcImFkZHJlc3NcIikgJiYgdHlwZXMuaW5jbHVkZXMoXCJieXRlczIwXCIpKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmICh0eXBlcy5pbmNsdWRlcyhcImFkZHJlc3NcIikgJiYgdHlwZXMuaW5jbHVkZXMoXCJzdHJpbmdcIikpXG4gICAgICAgIHJldHVybiBpc0FkZHJlc3MoYXJnc1twYXJhbWV0ZXJJbmRleF0sIHsgc3RyaWN0OiBmYWxzZSB9KTtcbiAgICAgIGlmICh0eXBlcy5pbmNsdWRlcyhcImFkZHJlc3NcIikgJiYgdHlwZXMuaW5jbHVkZXMoXCJieXRlc1wiKSlcbiAgICAgICAgcmV0dXJuIGlzQWRkcmVzcyhhcmdzW3BhcmFtZXRlckluZGV4XSwgeyBzdHJpY3Q6IGZhbHNlIH0pO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0pKCk7XG4gICAgaWYgKGFtYmlndW91cylcbiAgICAgIHJldHVybiB0eXBlcztcbiAgfVxuICByZXR1cm47XG59XG52YXIgaW5pdF9nZXRBYmlJdGVtID0gX19lc20oKCkgPT4ge1xuICBpbml0X2FiaSgpO1xuICBpbml0X2lzQWRkcmVzcygpO1xuICBpbml0X3RvRXZlbnRTZWxlY3RvcigpO1xuICBpbml0X3RvRnVuY3Rpb25TZWxlY3RvcigpO1xufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy92aWVtL19lc20vdXRpbHMvYWJpL3ByZXBhcmVFbmNvZGVGdW5jdGlvbkRhdGEuanNcbmZ1bmN0aW9uIHByZXBhcmVFbmNvZGVGdW5jdGlvbkRhdGEocGFyYW1ldGVycykge1xuICBjb25zdCB7IGFiaSwgYXJncywgZnVuY3Rpb25OYW1lIH0gPSBwYXJhbWV0ZXJzO1xuICBsZXQgYWJpSXRlbSA9IGFiaVswXTtcbiAgaWYgKGZ1bmN0aW9uTmFtZSkge1xuICAgIGNvbnN0IGl0ZW0gPSBnZXRBYmlJdGVtKHtcbiAgICAgIGFiaSxcbiAgICAgIGFyZ3MsXG4gICAgICBuYW1lOiBmdW5jdGlvbk5hbWVcbiAgICB9KTtcbiAgICBpZiAoIWl0ZW0pXG4gICAgICB0aHJvdyBuZXcgQWJpRnVuY3Rpb25Ob3RGb3VuZEVycm9yKGZ1bmN0aW9uTmFtZSwgeyBkb2NzUGF0aCB9KTtcbiAgICBhYmlJdGVtID0gaXRlbTtcbiAgfVxuICBpZiAoYWJpSXRlbS50eXBlICE9PSBcImZ1bmN0aW9uXCIpXG4gICAgdGhyb3cgbmV3IEFiaUZ1bmN0aW9uTm90Rm91bmRFcnJvcih1bmRlZmluZWQsIHsgZG9jc1BhdGggfSk7XG4gIHJldHVybiB7XG4gICAgYWJpOiBbYWJpSXRlbV0sXG4gICAgZnVuY3Rpb25OYW1lOiB0b0Z1bmN0aW9uU2VsZWN0b3IoZm9ybWF0QWJpSXRlbTIoYWJpSXRlbSkpXG4gIH07XG59XG52YXIgZG9jc1BhdGggPSBcIi9kb2NzL2NvbnRyYWN0L2VuY29kZUZ1bmN0aW9uRGF0YVwiO1xudmFyIGluaXRfcHJlcGFyZUVuY29kZUZ1bmN0aW9uRGF0YSA9IF9fZXNtKCgpID0+IHtcbiAgaW5pdF9hYmkoKTtcbiAgaW5pdF90b0Z1bmN0aW9uU2VsZWN0b3IoKTtcbiAgaW5pdF9mb3JtYXRBYmlJdGVtMigpO1xuICBpbml0X2dldEFiaUl0ZW0oKTtcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL2FiaS9lbmNvZGVGdW5jdGlvbkRhdGEuanNcbmZ1bmN0aW9uIGVuY29kZUZ1bmN0aW9uRGF0YShwYXJhbWV0ZXJzKSB7XG4gIGNvbnN0IHsgYXJncyB9ID0gcGFyYW1ldGVycztcbiAgY29uc3QgeyBhYmksIGZ1bmN0aW9uTmFtZSB9ID0gKCgpID0+IHtcbiAgICBpZiAocGFyYW1ldGVycy5hYmkubGVuZ3RoID09PSAxICYmIHBhcmFtZXRlcnMuZnVuY3Rpb25OYW1lPy5zdGFydHNXaXRoKFwiMHhcIikpXG4gICAgICByZXR1cm4gcGFyYW1ldGVycztcbiAgICByZXR1cm4gcHJlcGFyZUVuY29kZUZ1bmN0aW9uRGF0YShwYXJhbWV0ZXJzKTtcbiAgfSkoKTtcbiAgY29uc3QgYWJpSXRlbSA9IGFiaVswXTtcbiAgY29uc3Qgc2lnbmF0dXJlID0gZnVuY3Rpb25OYW1lO1xuICBjb25zdCBkYXRhID0gXCJpbnB1dHNcIiBpbiBhYmlJdGVtICYmIGFiaUl0ZW0uaW5wdXRzID8gZW5jb2RlQWJpUGFyYW1ldGVycyhhYmlJdGVtLmlucHV0cywgYXJncyA/PyBbXSkgOiB1bmRlZmluZWQ7XG4gIHJldHVybiBjb25jYXRIZXgoW3NpZ25hdHVyZSwgZGF0YSA/PyBcIjB4XCJdKTtcbn1cbnZhciBpbml0X2VuY29kZUZ1bmN0aW9uRGF0YSA9IF9fZXNtKCgpID0+IHtcbiAgaW5pdF9lbmNvZGVBYmlQYXJhbWV0ZXJzKCk7XG4gIGluaXRfcHJlcGFyZUVuY29kZUZ1bmN0aW9uRGF0YSgpO1xufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy92aWVtL19lc20vZXJyb3JzL2N1cnNvci5qc1xudmFyIE5lZ2F0aXZlT2Zmc2V0RXJyb3IsIFBvc2l0aW9uT3V0T2ZCb3VuZHNFcnJvciwgUmVjdXJzaXZlUmVhZExpbWl0RXhjZWVkZWRFcnJvcjtcbnZhciBpbml0X2N1cnNvciA9IF9fZXNtKCgpID0+IHtcbiAgaW5pdF9iYXNlKCk7XG4gIE5lZ2F0aXZlT2Zmc2V0RXJyb3IgPSBjbGFzcyBOZWdhdGl2ZU9mZnNldEVycm9yIGV4dGVuZHMgQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IG9mZnNldCB9KSB7XG4gICAgICBzdXBlcihgT2Zmc2V0IFxcYCR7b2Zmc2V0fVxcYCBjYW5ub3QgYmUgbmVnYXRpdmUuYCwge1xuICAgICAgICBuYW1lOiBcIk5lZ2F0aXZlT2Zmc2V0RXJyb3JcIlxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICBQb3NpdGlvbk91dE9mQm91bmRzRXJyb3IgPSBjbGFzcyBQb3NpdGlvbk91dE9mQm91bmRzRXJyb3IgZXh0ZW5kcyBCYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgbGVuZ3RoLCBwb3NpdGlvbiB9KSB7XG4gICAgICBzdXBlcihgUG9zaXRpb24gXFxgJHtwb3NpdGlvbn1cXGAgaXMgb3V0IG9mIGJvdW5kcyAoXFxgMCA8IHBvc2l0aW9uIDwgJHtsZW5ndGh9XFxgKS5gLCB7IG5hbWU6IFwiUG9zaXRpb25PdXRPZkJvdW5kc0Vycm9yXCIgfSk7XG4gICAgfVxuICB9O1xuICBSZWN1cnNpdmVSZWFkTGltaXRFeGNlZWRlZEVycm9yID0gY2xhc3MgUmVjdXJzaXZlUmVhZExpbWl0RXhjZWVkZWRFcnJvciBleHRlbmRzIEJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBjb3VudCwgbGltaXQgfSkge1xuICAgICAgc3VwZXIoYFJlY3Vyc2l2ZSByZWFkIGxpbWl0IG9mIFxcYCR7bGltaXR9XFxgIGV4Y2VlZGVkIChyZWN1cnNpdmUgcmVhZCBjb3VudDogXFxgJHtjb3VudH1cXGApLmAsIHsgbmFtZTogXCJSZWN1cnNpdmVSZWFkTGltaXRFeGNlZWRlZEVycm9yXCIgfSk7XG4gICAgfVxuICB9O1xufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy92aWVtL19lc20vdXRpbHMvY3Vyc29yLmpzXG5mdW5jdGlvbiBjcmVhdGVDdXJzb3IoYnl0ZXMsIHsgcmVjdXJzaXZlUmVhZExpbWl0ID0gODE5MiB9ID0ge30pIHtcbiAgY29uc3QgY3Vyc29yID0gT2JqZWN0LmNyZWF0ZShzdGF0aWNDdXJzb3IpO1xuICBjdXJzb3IuYnl0ZXMgPSBieXRlcztcbiAgY3Vyc29yLmRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KGJ5dGVzLmJ1ZmZlciwgYnl0ZXMuYnl0ZU9mZnNldCwgYnl0ZXMuYnl0ZUxlbmd0aCk7XG4gIGN1cnNvci5wb3NpdGlvblJlYWRDb3VudCA9IG5ldyBNYXA7XG4gIGN1cnNvci5yZWN1cnNpdmVSZWFkTGltaXQgPSByZWN1cnNpdmVSZWFkTGltaXQ7XG4gIHJldHVybiBjdXJzb3I7XG59XG52YXIgc3RhdGljQ3Vyc29yO1xudmFyIGluaXRfY3Vyc29yMiA9IF9fZXNtKCgpID0+IHtcbiAgaW5pdF9jdXJzb3IoKTtcbiAgc3RhdGljQ3Vyc29yID0ge1xuICAgIGJ5dGVzOiBuZXcgVWludDhBcnJheSxcbiAgICBkYXRhVmlldzogbmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigwKSksXG4gICAgcG9zaXRpb246IDAsXG4gICAgcG9zaXRpb25SZWFkQ291bnQ6IG5ldyBNYXAsXG4gICAgcmVjdXJzaXZlUmVhZENvdW50OiAwLFxuICAgIHJlY3Vyc2l2ZVJlYWRMaW1pdDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLFxuICAgIGFzc2VydFJlYWRMaW1pdCgpIHtcbiAgICAgIGlmICh0aGlzLnJlY3Vyc2l2ZVJlYWRDb3VudCA+PSB0aGlzLnJlY3Vyc2l2ZVJlYWRMaW1pdClcbiAgICAgICAgdGhyb3cgbmV3IFJlY3Vyc2l2ZVJlYWRMaW1pdEV4Y2VlZGVkRXJyb3Ioe1xuICAgICAgICAgIGNvdW50OiB0aGlzLnJlY3Vyc2l2ZVJlYWRDb3VudCArIDEsXG4gICAgICAgICAgbGltaXQ6IHRoaXMucmVjdXJzaXZlUmVhZExpbWl0XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgYXNzZXJ0UG9zaXRpb24ocG9zaXRpb24pIHtcbiAgICAgIGlmIChwb3NpdGlvbiA8IDAgfHwgcG9zaXRpb24gPiB0aGlzLmJ5dGVzLmxlbmd0aCAtIDEpXG4gICAgICAgIHRocm93IG5ldyBQb3NpdGlvbk91dE9mQm91bmRzRXJyb3Ioe1xuICAgICAgICAgIGxlbmd0aDogdGhpcy5ieXRlcy5sZW5ndGgsXG4gICAgICAgICAgcG9zaXRpb25cbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBkZWNyZW1lbnRQb3NpdGlvbihvZmZzZXQpIHtcbiAgICAgIGlmIChvZmZzZXQgPCAwKVxuICAgICAgICB0aHJvdyBuZXcgTmVnYXRpdmVPZmZzZXRFcnJvcih7IG9mZnNldCB9KTtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbiAtIG9mZnNldDtcbiAgICAgIHRoaXMuYXNzZXJ0UG9zaXRpb24ocG9zaXRpb24pO1xuICAgICAgdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgIH0sXG4gICAgZ2V0UmVhZENvdW50KHBvc2l0aW9uKSB7XG4gICAgICByZXR1cm4gdGhpcy5wb3NpdGlvblJlYWRDb3VudC5nZXQocG9zaXRpb24gfHwgdGhpcy5wb3NpdGlvbikgfHwgMDtcbiAgICB9LFxuICAgIGluY3JlbWVudFBvc2l0aW9uKG9mZnNldCkge1xuICAgICAgaWYgKG9mZnNldCA8IDApXG4gICAgICAgIHRocm93IG5ldyBOZWdhdGl2ZU9mZnNldEVycm9yKHsgb2Zmc2V0IH0pO1xuICAgICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uICsgb2Zmc2V0O1xuICAgICAgdGhpcy5hc3NlcnRQb3NpdGlvbihwb3NpdGlvbik7XG4gICAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgfSxcbiAgICBpbnNwZWN0Qnl0ZShwb3NpdGlvbl8pIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gcG9zaXRpb25fID8/IHRoaXMucG9zaXRpb247XG4gICAgICB0aGlzLmFzc2VydFBvc2l0aW9uKHBvc2l0aW9uKTtcbiAgICAgIHJldHVybiB0aGlzLmJ5dGVzW3Bvc2l0aW9uXTtcbiAgICB9LFxuICAgIGluc3BlY3RCeXRlcyhsZW5ndGgsIHBvc2l0aW9uXykge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBwb3NpdGlvbl8gPz8gdGhpcy5wb3NpdGlvbjtcbiAgICAgIHRoaXMuYXNzZXJ0UG9zaXRpb24ocG9zaXRpb24gKyBsZW5ndGggLSAxKTtcbiAgICAgIHJldHVybiB0aGlzLmJ5dGVzLnN1YmFycmF5KHBvc2l0aW9uLCBwb3NpdGlvbiArIGxlbmd0aCk7XG4gICAgfSxcbiAgICBpbnNwZWN0VWludDgocG9zaXRpb25fKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IHBvc2l0aW9uXyA/PyB0aGlzLnBvc2l0aW9uO1xuICAgICAgdGhpcy5hc3NlcnRQb3NpdGlvbihwb3NpdGlvbik7XG4gICAgICByZXR1cm4gdGhpcy5ieXRlc1twb3NpdGlvbl07XG4gICAgfSxcbiAgICBpbnNwZWN0VWludDE2KHBvc2l0aW9uXykge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBwb3NpdGlvbl8gPz8gdGhpcy5wb3NpdGlvbjtcbiAgICAgIHRoaXMuYXNzZXJ0UG9zaXRpb24ocG9zaXRpb24gKyAxKTtcbiAgICAgIHJldHVybiB0aGlzLmRhdGFWaWV3LmdldFVpbnQxNihwb3NpdGlvbik7XG4gICAgfSxcbiAgICBpbnNwZWN0VWludDI0KHBvc2l0aW9uXykge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBwb3NpdGlvbl8gPz8gdGhpcy5wb3NpdGlvbjtcbiAgICAgIHRoaXMuYXNzZXJ0UG9zaXRpb24ocG9zaXRpb24gKyAyKTtcbiAgICAgIHJldHVybiAodGhpcy5kYXRhVmlldy5nZXRVaW50MTYocG9zaXRpb24pIDw8IDgpICsgdGhpcy5kYXRhVmlldy5nZXRVaW50OChwb3NpdGlvbiArIDIpO1xuICAgIH0sXG4gICAgaW5zcGVjdFVpbnQzMihwb3NpdGlvbl8pIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gcG9zaXRpb25fID8/IHRoaXMucG9zaXRpb247XG4gICAgICB0aGlzLmFzc2VydFBvc2l0aW9uKHBvc2l0aW9uICsgMyk7XG4gICAgICByZXR1cm4gdGhpcy5kYXRhVmlldy5nZXRVaW50MzIocG9zaXRpb24pO1xuICAgIH0sXG4gICAgcHVzaEJ5dGUoYnl0ZSkge1xuICAgICAgdGhpcy5hc3NlcnRQb3NpdGlvbih0aGlzLnBvc2l0aW9uKTtcbiAgICAgIHRoaXMuYnl0ZXNbdGhpcy5wb3NpdGlvbl0gPSBieXRlO1xuICAgICAgdGhpcy5wb3NpdGlvbisrO1xuICAgIH0sXG4gICAgcHVzaEJ5dGVzKGJ5dGVzKSB7XG4gICAgICB0aGlzLmFzc2VydFBvc2l0aW9uKHRoaXMucG9zaXRpb24gKyBieXRlcy5sZW5ndGggLSAxKTtcbiAgICAgIHRoaXMuYnl0ZXMuc2V0KGJ5dGVzLCB0aGlzLnBvc2l0aW9uKTtcbiAgICAgIHRoaXMucG9zaXRpb24gKz0gYnl0ZXMubGVuZ3RoO1xuICAgIH0sXG4gICAgcHVzaFVpbnQ4KHZhbHVlKSB7XG4gICAgICB0aGlzLmFzc2VydFBvc2l0aW9uKHRoaXMucG9zaXRpb24pO1xuICAgICAgdGhpcy5ieXRlc1t0aGlzLnBvc2l0aW9uXSA9IHZhbHVlO1xuICAgICAgdGhpcy5wb3NpdGlvbisrO1xuICAgIH0sXG4gICAgcHVzaFVpbnQxNih2YWx1ZSkge1xuICAgICAgdGhpcy5hc3NlcnRQb3NpdGlvbih0aGlzLnBvc2l0aW9uICsgMSk7XG4gICAgICB0aGlzLmRhdGFWaWV3LnNldFVpbnQxNih0aGlzLnBvc2l0aW9uLCB2YWx1ZSk7XG4gICAgICB0aGlzLnBvc2l0aW9uICs9IDI7XG4gICAgfSxcbiAgICBwdXNoVWludDI0KHZhbHVlKSB7XG4gICAgICB0aGlzLmFzc2VydFBvc2l0aW9uKHRoaXMucG9zaXRpb24gKyAyKTtcbiAgICAgIHRoaXMuZGF0YVZpZXcuc2V0VWludDE2KHRoaXMucG9zaXRpb24sIHZhbHVlID4+IDgpO1xuICAgICAgdGhpcy5kYXRhVmlldy5zZXRVaW50OCh0aGlzLnBvc2l0aW9uICsgMiwgdmFsdWUgJiB+NDI5NDk2NzA0MCk7XG4gICAgICB0aGlzLnBvc2l0aW9uICs9IDM7XG4gICAgfSxcbiAgICBwdXNoVWludDMyKHZhbHVlKSB7XG4gICAgICB0aGlzLmFzc2VydFBvc2l0aW9uKHRoaXMucG9zaXRpb24gKyAzKTtcbiAgICAgIHRoaXMuZGF0YVZpZXcuc2V0VWludDMyKHRoaXMucG9zaXRpb24sIHZhbHVlKTtcbiAgICAgIHRoaXMucG9zaXRpb24gKz0gNDtcbiAgICB9LFxuICAgIHJlYWRCeXRlKCkge1xuICAgICAgdGhpcy5hc3NlcnRSZWFkTGltaXQoKTtcbiAgICAgIHRoaXMuX3RvdWNoKCk7XG4gICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuaW5zcGVjdEJ5dGUoKTtcbiAgICAgIHRoaXMucG9zaXRpb24rKztcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIHJlYWRCeXRlcyhsZW5ndGgsIHNpemUyKSB7XG4gICAgICB0aGlzLmFzc2VydFJlYWRMaW1pdCgpO1xuICAgICAgdGhpcy5fdG91Y2goKTtcbiAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5pbnNwZWN0Qnl0ZXMobGVuZ3RoKTtcbiAgICAgIHRoaXMucG9zaXRpb24gKz0gc2l6ZTIgPz8gbGVuZ3RoO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgcmVhZFVpbnQ4KCkge1xuICAgICAgdGhpcy5hc3NlcnRSZWFkTGltaXQoKTtcbiAgICAgIHRoaXMuX3RvdWNoKCk7XG4gICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuaW5zcGVjdFVpbnQ4KCk7XG4gICAgICB0aGlzLnBvc2l0aW9uICs9IDE7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgICByZWFkVWludDE2KCkge1xuICAgICAgdGhpcy5hc3NlcnRSZWFkTGltaXQoKTtcbiAgICAgIHRoaXMuX3RvdWNoKCk7XG4gICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuaW5zcGVjdFVpbnQxNigpO1xuICAgICAgdGhpcy5wb3NpdGlvbiArPSAyO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgcmVhZFVpbnQyNCgpIHtcbiAgICAgIHRoaXMuYXNzZXJ0UmVhZExpbWl0KCk7XG4gICAgICB0aGlzLl90b3VjaCgpO1xuICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmluc3BlY3RVaW50MjQoKTtcbiAgICAgIHRoaXMucG9zaXRpb24gKz0gMztcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIHJlYWRVaW50MzIoKSB7XG4gICAgICB0aGlzLmFzc2VydFJlYWRMaW1pdCgpO1xuICAgICAgdGhpcy5fdG91Y2goKTtcbiAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5pbnNwZWN0VWludDMyKCk7XG4gICAgICB0aGlzLnBvc2l0aW9uICs9IDQ7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgICBnZXQgcmVtYWluaW5nKCkge1xuICAgICAgcmV0dXJuIHRoaXMuYnl0ZXMubGVuZ3RoIC0gdGhpcy5wb3NpdGlvbjtcbiAgICB9LFxuICAgIHNldFBvc2l0aW9uKHBvc2l0aW9uKSB7XG4gICAgICBjb25zdCBvbGRQb3NpdGlvbiA9IHRoaXMucG9zaXRpb247XG4gICAgICB0aGlzLmFzc2VydFBvc2l0aW9uKHBvc2l0aW9uKTtcbiAgICAgIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICAgIHJldHVybiAoKSA9PiB0aGlzLnBvc2l0aW9uID0gb2xkUG9zaXRpb247XG4gICAgfSxcbiAgICBfdG91Y2goKSB7XG4gICAgICBpZiAodGhpcy5yZWN1cnNpdmVSZWFkTGltaXQgPT09IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgY291bnQgPSB0aGlzLmdldFJlYWRDb3VudCgpO1xuICAgICAgdGhpcy5wb3NpdGlvblJlYWRDb3VudC5zZXQodGhpcy5wb3NpdGlvbiwgY291bnQgKyAxKTtcbiAgICAgIGlmIChjb3VudCA+IDApXG4gICAgICAgIHRoaXMucmVjdXJzaXZlUmVhZENvdW50Kys7XG4gICAgfVxuICB9O1xufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy92aWVtL19lc20vY29uc3RhbnRzL3VuaXQuanNcbnZhciBnd2VpVW5pdHM7XG52YXIgaW5pdF91bml0ID0gX19lc20oKCkgPT4ge1xuICBnd2VpVW5pdHMgPSB7XG4gICAgZXRoZXI6IC05LFxuICAgIHdlaTogOVxuICB9O1xufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy92aWVtL19lc20vdXRpbHMvdW5pdC9mb3JtYXRVbml0cy5qc1xuZnVuY3Rpb24gZm9ybWF0VW5pdHModmFsdWUsIGRlY2ltYWxzKSB7XG4gIGxldCBkaXNwbGF5ID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgY29uc3QgbmVnYXRpdmUgPSBkaXNwbGF5LnN0YXJ0c1dpdGgoXCItXCIpO1xuICBpZiAobmVnYXRpdmUpXG4gICAgZGlzcGxheSA9IGRpc3BsYXkuc2xpY2UoMSk7XG4gIGRpc3BsYXkgPSBkaXNwbGF5LnBhZFN0YXJ0KGRlY2ltYWxzLCBcIjBcIik7XG4gIGxldCBbaW50ZWdlcjIsIGZyYWN0aW9uXSA9IFtcbiAgICBkaXNwbGF5LnNsaWNlKDAsIGRpc3BsYXkubGVuZ3RoIC0gZGVjaW1hbHMpLFxuICAgIGRpc3BsYXkuc2xpY2UoZGlzcGxheS5sZW5ndGggLSBkZWNpbWFscylcbiAgXTtcbiAgZnJhY3Rpb24gPSBmcmFjdGlvbi5yZXBsYWNlKC8oMCspJC8sIFwiXCIpO1xuICByZXR1cm4gYCR7bmVnYXRpdmUgPyBcIi1cIiA6IFwiXCJ9JHtpbnRlZ2VyMiB8fCBcIjBcIn0ke2ZyYWN0aW9uID8gYC4ke2ZyYWN0aW9ufWAgOiBcIlwifWA7XG59XG5cbi8vIG5vZGVfbW9kdWxlcy92aWVtL19lc20vdXRpbHMvdW5pdC9mb3JtYXRHd2VpLmpzXG5mdW5jdGlvbiBmb3JtYXRHd2VpKHdlaSwgdW5pdCA9IFwid2VpXCIpIHtcbiAgcmV0dXJuIGZvcm1hdFVuaXRzKHdlaSwgZ3dlaVVuaXRzW3VuaXRdKTtcbn1cbnZhciBpbml0X2Zvcm1hdEd3ZWkgPSBfX2VzbSgoKSA9PiB7XG4gIGluaXRfdW5pdCgpO1xufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy92aWVtL19lc20vZXJyb3JzL3RyYW5zYWN0aW9uLmpzXG5mdW5jdGlvbiBwcmV0dHlQcmludChhcmdzKSB7XG4gIGNvbnN0IGVudHJpZXMgPSBPYmplY3QuZW50cmllcyhhcmdzKS5tYXAoKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBmYWxzZSlcbiAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiBba2V5LCB2YWx1ZV07XG4gIH0pLmZpbHRlcihCb29sZWFuKTtcbiAgY29uc3QgbWF4TGVuZ3RoID0gZW50cmllcy5yZWR1Y2UoKGFjYywgW2tleV0pID0+IE1hdGgubWF4KGFjYywga2V5Lmxlbmd0aCksIDApO1xuICByZXR1cm4gZW50cmllcy5tYXAoKFtrZXksIHZhbHVlXSkgPT4gYCAgJHtgJHtrZXl9OmAucGFkRW5kKG1heExlbmd0aCArIDEpfSAgJHt2YWx1ZX1gKS5qb2luKGBcbmApO1xufVxudmFyIEludmFsaWRMZWdhY3lWRXJyb3IsIEludmFsaWRTZXJpYWxpemFibGVUcmFuc2FjdGlvbkVycm9yLCBJbnZhbGlkU3RvcmFnZUtleVNpemVFcnJvcjtcbnZhciBpbml0X3RyYW5zYWN0aW9uID0gX19lc20oKCkgPT4ge1xuICBpbml0X2Jhc2UoKTtcbiAgSW52YWxpZExlZ2FjeVZFcnJvciA9IGNsYXNzIEludmFsaWRMZWdhY3lWRXJyb3IgZXh0ZW5kcyBCYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgdiB9KSB7XG4gICAgICBzdXBlcihgSW52YWxpZCBcXGB2XFxgIHZhbHVlIFwiJHt2fVwiLiBFeHBlY3RlZCAyNyBvciAyOC5gLCB7XG4gICAgICAgIG5hbWU6IFwiSW52YWxpZExlZ2FjeVZFcnJvclwiXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIEludmFsaWRTZXJpYWxpemFibGVUcmFuc2FjdGlvbkVycm9yID0gY2xhc3MgSW52YWxpZFNlcmlhbGl6YWJsZVRyYW5zYWN0aW9uRXJyb3IgZXh0ZW5kcyBCYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgdHJhbnNhY3Rpb24gfSkge1xuICAgICAgc3VwZXIoXCJDYW5ub3QgaW5mZXIgYSB0cmFuc2FjdGlvbiB0eXBlIGZyb20gcHJvdmlkZWQgdHJhbnNhY3Rpb24uXCIsIHtcbiAgICAgICAgbWV0YU1lc3NhZ2VzOiBbXG4gICAgICAgICAgXCJQcm92aWRlZCBUcmFuc2FjdGlvbjpcIixcbiAgICAgICAgICBcIntcIixcbiAgICAgICAgICBwcmV0dHlQcmludCh0cmFuc2FjdGlvbiksXG4gICAgICAgICAgXCJ9XCIsXG4gICAgICAgICAgXCJcIixcbiAgICAgICAgICBcIlRvIGluZmVyIHRoZSB0eXBlLCBlaXRoZXIgcHJvdmlkZTpcIixcbiAgICAgICAgICBcIi0gYSBgdHlwZWAgdG8gdGhlIFRyYW5zYWN0aW9uLCBvclwiLFxuICAgICAgICAgIFwiLSBhbiBFSVAtMTU1OSBUcmFuc2FjdGlvbiB3aXRoIGBtYXhGZWVQZXJHYXNgLCBvclwiLFxuICAgICAgICAgIFwiLSBhbiBFSVAtMjkzMCBUcmFuc2FjdGlvbiB3aXRoIGBnYXNQcmljZWAgJiBgYWNjZXNzTGlzdGAsIG9yXCIsXG4gICAgICAgICAgXCItIGFuIEVJUC00ODQ0IFRyYW5zYWN0aW9uIHdpdGggYGJsb2JzYCwgYGJsb2JWZXJzaW9uZWRIYXNoZXNgLCBgc2lkZWNhcnNgLCBvclwiLFxuICAgICAgICAgIFwiLSBhbiBFSVAtNzcwMiBUcmFuc2FjdGlvbiB3aXRoIGBhdXRob3JpemF0aW9uTGlzdGAsIG9yXCIsXG4gICAgICAgICAgXCItIGEgTGVnYWN5IFRyYW5zYWN0aW9uIHdpdGggYGdhc1ByaWNlYFwiXG4gICAgICAgIF0sXG4gICAgICAgIG5hbWU6IFwiSW52YWxpZFNlcmlhbGl6YWJsZVRyYW5zYWN0aW9uRXJyb3JcIlxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICBJbnZhbGlkU3RvcmFnZUtleVNpemVFcnJvciA9IGNsYXNzIEludmFsaWRTdG9yYWdlS2V5U2l6ZUVycm9yIGV4dGVuZHMgQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IHN0b3JhZ2VLZXkgfSkge1xuICAgICAgc3VwZXIoYFNpemUgZm9yIHN0b3JhZ2Uga2V5IFwiJHtzdG9yYWdlS2V5fVwiIGlzIGludmFsaWQuIEV4cGVjdGVkIDMyIGJ5dGVzLiBHb3QgJHtNYXRoLmZsb29yKChzdG9yYWdlS2V5Lmxlbmd0aCAtIDIpIC8gMil9IGJ5dGVzLmAsIHsgbmFtZTogXCJJbnZhbGlkU3RvcmFnZUtleVNpemVFcnJvclwiIH0pO1xuICAgIH1cbiAgfTtcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvdmllbS9fZXNtL2Vycm9ycy9ub2RlLmpzXG52YXIgRXhlY3V0aW9uUmV2ZXJ0ZWRFcnJvciwgRmVlQ2FwVG9vSGlnaEVycm9yLCBGZWVDYXBUb29Mb3dFcnJvciwgTm9uY2VUb29IaWdoRXJyb3IsIE5vbmNlVG9vTG93RXJyb3IsIE5vbmNlTWF4VmFsdWVFcnJvciwgSW5zdWZmaWNpZW50RnVuZHNFcnJvciwgSW50cmluc2ljR2FzVG9vSGlnaEVycm9yLCBJbnRyaW5zaWNHYXNUb29Mb3dFcnJvciwgVHJhbnNhY3Rpb25UeXBlTm90U3VwcG9ydGVkRXJyb3IsIFRpcEFib3ZlRmVlQ2FwRXJyb3I7XG52YXIgaW5pdF9ub2RlID0gX19lc20oKCkgPT4ge1xuICBpbml0X2Zvcm1hdEd3ZWkoKTtcbiAgaW5pdF9iYXNlKCk7XG4gIEV4ZWN1dGlvblJldmVydGVkRXJyb3IgPSBjbGFzcyBFeGVjdXRpb25SZXZlcnRlZEVycm9yIGV4dGVuZHMgQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGNhdXNlLCBtZXNzYWdlIH0gPSB7fSkge1xuICAgICAgY29uc3QgcmVhc29uID0gbWVzc2FnZT8ucmVwbGFjZShcImV4ZWN1dGlvbiByZXZlcnRlZDogXCIsIFwiXCIpPy5yZXBsYWNlKFwiZXhlY3V0aW9uIHJldmVydGVkXCIsIFwiXCIpO1xuICAgICAgc3VwZXIoYEV4ZWN1dGlvbiByZXZlcnRlZCAke3JlYXNvbiA/IGB3aXRoIHJlYXNvbjogJHtyZWFzb259YCA6IFwiZm9yIGFuIHVua25vd24gcmVhc29uXCJ9LmAsIHtcbiAgICAgICAgY2F1c2UsXG4gICAgICAgIG5hbWU6IFwiRXhlY3V0aW9uUmV2ZXJ0ZWRFcnJvclwiXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFeGVjdXRpb25SZXZlcnRlZEVycm9yLCBcImNvZGVcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiAzXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXhlY3V0aW9uUmV2ZXJ0ZWRFcnJvciwgXCJub2RlTWVzc2FnZVwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IC9leGVjdXRpb24gcmV2ZXJ0ZWQvXG4gIH0pO1xuICBGZWVDYXBUb29IaWdoRXJyb3IgPSBjbGFzcyBGZWVDYXBUb29IaWdoRXJyb3IgZXh0ZW5kcyBCYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgY2F1c2UsIG1heEZlZVBlckdhcyB9ID0ge30pIHtcbiAgICAgIHN1cGVyKGBUaGUgZmVlIGNhcCAoXFxgbWF4RmVlUGVyR2FzXFxgJHttYXhGZWVQZXJHYXMgPyBgID0gJHtmb3JtYXRHd2VpKG1heEZlZVBlckdhcyl9IGd3ZWlgIDogXCJcIn0pIGNhbm5vdCBiZSBoaWdoZXIgdGhhbiB0aGUgbWF4aW11bSBhbGxvd2VkIHZhbHVlICgyXjI1Ni0xKS5gLCB7XG4gICAgICAgIGNhdXNlLFxuICAgICAgICBuYW1lOiBcIkZlZUNhcFRvb0hpZ2hFcnJvclwiXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGZWVDYXBUb29IaWdoRXJyb3IsIFwibm9kZU1lc3NhZ2VcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiAvbWF4IGZlZSBwZXIgZ2FzIGhpZ2hlciB0aGFuIDJcXF4yNTYtMXxmZWUgY2FwIGhpZ2hlciB0aGFuIDJcXF4yNTYtMS9cbiAgfSk7XG4gIEZlZUNhcFRvb0xvd0Vycm9yID0gY2xhc3MgRmVlQ2FwVG9vTG93RXJyb3IgZXh0ZW5kcyBCYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgY2F1c2UsIG1heEZlZVBlckdhcyB9ID0ge30pIHtcbiAgICAgIHN1cGVyKGBUaGUgZmVlIGNhcCAoXFxgbWF4RmVlUGVyR2FzXFxgJHttYXhGZWVQZXJHYXMgPyBgID0gJHtmb3JtYXRHd2VpKG1heEZlZVBlckdhcyl9YCA6IFwiXCJ9IGd3ZWkpIGNhbm5vdCBiZSBsb3dlciB0aGFuIHRoZSBibG9jayBiYXNlIGZlZS5gLCB7XG4gICAgICAgIGNhdXNlLFxuICAgICAgICBuYW1lOiBcIkZlZUNhcFRvb0xvd0Vycm9yXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZlZUNhcFRvb0xvd0Vycm9yLCBcIm5vZGVNZXNzYWdlXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogL21heCBmZWUgcGVyIGdhcyBsZXNzIHRoYW4gYmxvY2sgYmFzZSBmZWV8ZmVlIGNhcCBsZXNzIHRoYW4gYmxvY2sgYmFzZSBmZWV8dHJhbnNhY3Rpb24gaXMgb3V0ZGF0ZWQvXG4gIH0pO1xuICBOb25jZVRvb0hpZ2hFcnJvciA9IGNsYXNzIE5vbmNlVG9vSGlnaEVycm9yIGV4dGVuZHMgQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGNhdXNlLCBub25jZSB9ID0ge30pIHtcbiAgICAgIHN1cGVyKGBOb25jZSBwcm92aWRlZCBmb3IgdGhlIHRyYW5zYWN0aW9uICR7bm9uY2UgPyBgKCR7bm9uY2V9KSBgIDogXCJcIn1pcyBoaWdoZXIgdGhhbiB0aGUgbmV4dCBvbmUgZXhwZWN0ZWQuYCwgeyBjYXVzZSwgbmFtZTogXCJOb25jZVRvb0hpZ2hFcnJvclwiIH0pO1xuICAgIH1cbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5vbmNlVG9vSGlnaEVycm9yLCBcIm5vZGVNZXNzYWdlXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogL25vbmNlIHRvbyBoaWdoL1xuICB9KTtcbiAgTm9uY2VUb29Mb3dFcnJvciA9IGNsYXNzIE5vbmNlVG9vTG93RXJyb3IgZXh0ZW5kcyBCYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgY2F1c2UsIG5vbmNlIH0gPSB7fSkge1xuICAgICAgc3VwZXIoW1xuICAgICAgICBgTm9uY2UgcHJvdmlkZWQgZm9yIHRoZSB0cmFuc2FjdGlvbiAke25vbmNlID8gYCgke25vbmNlfSkgYCA6IFwiXCJ9aXMgbG93ZXIgdGhhbiB0aGUgY3VycmVudCBub25jZSBvZiB0aGUgYWNjb3VudC5gLFxuICAgICAgICBcIlRyeSBpbmNyZWFzaW5nIHRoZSBub25jZSBvciBmaW5kIHRoZSBsYXRlc3Qgbm9uY2Ugd2l0aCBgZ2V0VHJhbnNhY3Rpb25Db3VudGAuXCJcbiAgICAgIF0uam9pbihgXG5gKSwgeyBjYXVzZSwgbmFtZTogXCJOb25jZVRvb0xvd0Vycm9yXCIgfSk7XG4gICAgfVxuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTm9uY2VUb29Mb3dFcnJvciwgXCJub2RlTWVzc2FnZVwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IC9ub25jZSB0b28gbG93fHRyYW5zYWN0aW9uIGFscmVhZHkgaW1wb3J0ZWR8YWxyZWFkeSBrbm93bi9cbiAgfSk7XG4gIE5vbmNlTWF4VmFsdWVFcnJvciA9IGNsYXNzIE5vbmNlTWF4VmFsdWVFcnJvciBleHRlbmRzIEJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBjYXVzZSwgbm9uY2UgfSA9IHt9KSB7XG4gICAgICBzdXBlcihgTm9uY2UgcHJvdmlkZWQgZm9yIHRoZSB0cmFuc2FjdGlvbiAke25vbmNlID8gYCgke25vbmNlfSkgYCA6IFwiXCJ9ZXhjZWVkcyB0aGUgbWF4aW11bSBhbGxvd2VkIG5vbmNlLmAsIHsgY2F1c2UsIG5hbWU6IFwiTm9uY2VNYXhWYWx1ZUVycm9yXCIgfSk7XG4gICAgfVxuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTm9uY2VNYXhWYWx1ZUVycm9yLCBcIm5vZGVNZXNzYWdlXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogL25vbmNlIGhhcyBtYXggdmFsdWUvXG4gIH0pO1xuICBJbnN1ZmZpY2llbnRGdW5kc0Vycm9yID0gY2xhc3MgSW5zdWZmaWNpZW50RnVuZHNFcnJvciBleHRlbmRzIEJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBjYXVzZSB9ID0ge30pIHtcbiAgICAgIHN1cGVyKFtcbiAgICAgICAgXCJUaGUgdG90YWwgY29zdCAoZ2FzICogZ2FzIGZlZSArIHZhbHVlKSBvZiBleGVjdXRpbmcgdGhpcyB0cmFuc2FjdGlvbiBleGNlZWRzIHRoZSBiYWxhbmNlIG9mIHRoZSBhY2NvdW50LlwiXG4gICAgICBdLmpvaW4oYFxuYCksIHtcbiAgICAgICAgY2F1c2UsXG4gICAgICAgIG1ldGFNZXNzYWdlczogW1xuICAgICAgICAgIFwiVGhpcyBlcnJvciBjb3VsZCBhcmlzZSB3aGVuIHRoZSBhY2NvdW50IGRvZXMgbm90IGhhdmUgZW5vdWdoIGZ1bmRzIHRvOlwiLFxuICAgICAgICAgIFwiIC0gcGF5IGZvciB0aGUgdG90YWwgZ2FzIGZlZSxcIixcbiAgICAgICAgICBcIiAtIHBheSBmb3IgdGhlIHZhbHVlIHRvIHNlbmQuXCIsXG4gICAgICAgICAgXCIgXCIsXG4gICAgICAgICAgXCJUaGUgY29zdCBvZiB0aGUgdHJhbnNhY3Rpb24gaXMgY2FsY3VsYXRlZCBhcyBgZ2FzICogZ2FzIGZlZSArIHZhbHVlYCwgd2hlcmU6XCIsXG4gICAgICAgICAgXCIgLSBgZ2FzYCBpcyB0aGUgYW1vdW50IG9mIGdhcyBuZWVkZWQgZm9yIHRyYW5zYWN0aW9uIHRvIGV4ZWN1dGUsXCIsXG4gICAgICAgICAgXCIgLSBgZ2FzIGZlZWAgaXMgdGhlIGdhcyBmZWUsXCIsXG4gICAgICAgICAgXCIgLSBgdmFsdWVgIGlzIHRoZSBhbW91bnQgb2YgZXRoZXIgdG8gc2VuZCB0byB0aGUgcmVjaXBpZW50LlwiXG4gICAgICAgIF0sXG4gICAgICAgIG5hbWU6IFwiSW5zdWZmaWNpZW50RnVuZHNFcnJvclwiXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShJbnN1ZmZpY2llbnRGdW5kc0Vycm9yLCBcIm5vZGVNZXNzYWdlXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogL2luc3VmZmljaWVudCBmdW5kc3xleGNlZWRzIHRyYW5zYWN0aW9uIHNlbmRlciBhY2NvdW50IGJhbGFuY2UvXG4gIH0pO1xuICBJbnRyaW5zaWNHYXNUb29IaWdoRXJyb3IgPSBjbGFzcyBJbnRyaW5zaWNHYXNUb29IaWdoRXJyb3IgZXh0ZW5kcyBCYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgY2F1c2UsIGdhcyB9ID0ge30pIHtcbiAgICAgIHN1cGVyKGBUaGUgYW1vdW50IG9mIGdhcyAke2dhcyA/IGAoJHtnYXN9KSBgIDogXCJcIn1wcm92aWRlZCBmb3IgdGhlIHRyYW5zYWN0aW9uIGV4Y2VlZHMgdGhlIGxpbWl0IGFsbG93ZWQgZm9yIHRoZSBibG9jay5gLCB7XG4gICAgICAgIGNhdXNlLFxuICAgICAgICBuYW1lOiBcIkludHJpbnNpY0dhc1Rvb0hpZ2hFcnJvclwiXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShJbnRyaW5zaWNHYXNUb29IaWdoRXJyb3IsIFwibm9kZU1lc3NhZ2VcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiAvaW50cmluc2ljIGdhcyB0b28gaGlnaHxnYXMgbGltaXQgcmVhY2hlZC9cbiAgfSk7XG4gIEludHJpbnNpY0dhc1Rvb0xvd0Vycm9yID0gY2xhc3MgSW50cmluc2ljR2FzVG9vTG93RXJyb3IgZXh0ZW5kcyBCYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgY2F1c2UsIGdhcyB9ID0ge30pIHtcbiAgICAgIHN1cGVyKGBUaGUgYW1vdW50IG9mIGdhcyAke2dhcyA/IGAoJHtnYXN9KSBgIDogXCJcIn1wcm92aWRlZCBmb3IgdGhlIHRyYW5zYWN0aW9uIGlzIHRvbyBsb3cuYCwge1xuICAgICAgICBjYXVzZSxcbiAgICAgICAgbmFtZTogXCJJbnRyaW5zaWNHYXNUb29Mb3dFcnJvclwiXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShJbnRyaW5zaWNHYXNUb29Mb3dFcnJvciwgXCJub2RlTWVzc2FnZVwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IC9pbnRyaW5zaWMgZ2FzIHRvbyBsb3cvXG4gIH0pO1xuICBUcmFuc2FjdGlvblR5cGVOb3RTdXBwb3J0ZWRFcnJvciA9IGNsYXNzIFRyYW5zYWN0aW9uVHlwZU5vdFN1cHBvcnRlZEVycm9yIGV4dGVuZHMgQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGNhdXNlIH0pIHtcbiAgICAgIHN1cGVyKFwiVGhlIHRyYW5zYWN0aW9uIHR5cGUgaXMgbm90IHN1cHBvcnRlZCBmb3IgdGhpcyBjaGFpbi5cIiwge1xuICAgICAgICBjYXVzZSxcbiAgICAgICAgbmFtZTogXCJUcmFuc2FjdGlvblR5cGVOb3RTdXBwb3J0ZWRFcnJvclwiXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUcmFuc2FjdGlvblR5cGVOb3RTdXBwb3J0ZWRFcnJvciwgXCJub2RlTWVzc2FnZVwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IC90cmFuc2FjdGlvbiB0eXBlIG5vdCB2YWxpZC9cbiAgfSk7XG4gIFRpcEFib3ZlRmVlQ2FwRXJyb3IgPSBjbGFzcyBUaXBBYm92ZUZlZUNhcEVycm9yIGV4dGVuZHMgQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGNhdXNlLCBtYXhQcmlvcml0eUZlZVBlckdhcywgbWF4RmVlUGVyR2FzIH0gPSB7fSkge1xuICAgICAgc3VwZXIoW1xuICAgICAgICBgVGhlIHByb3ZpZGVkIHRpcCAoXFxgbWF4UHJpb3JpdHlGZWVQZXJHYXNcXGAke21heFByaW9yaXR5RmVlUGVyR2FzID8gYCA9ICR7Zm9ybWF0R3dlaShtYXhQcmlvcml0eUZlZVBlckdhcyl9IGd3ZWlgIDogXCJcIn0pIGNhbm5vdCBiZSBoaWdoZXIgdGhhbiB0aGUgZmVlIGNhcCAoXFxgbWF4RmVlUGVyR2FzXFxgJHttYXhGZWVQZXJHYXMgPyBgID0gJHtmb3JtYXRHd2VpKG1heEZlZVBlckdhcyl9IGd3ZWlgIDogXCJcIn0pLmBcbiAgICAgIF0uam9pbihgXG5gKSwge1xuICAgICAgICBjYXVzZSxcbiAgICAgICAgbmFtZTogXCJUaXBBYm92ZUZlZUNhcEVycm9yXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRpcEFib3ZlRmVlQ2FwRXJyb3IsIFwibm9kZU1lc3NhZ2VcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiAvbWF4IHByaW9yaXR5IGZlZSBwZXIgZ2FzIGhpZ2hlciB0aGFuIG1heCBmZWUgcGVyIGdhc3x0aXAgaGlnaGVyIHRoYW4gZmVlIGNhcC9cbiAgfSk7XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy9mb3JtYXR0ZXJzL2Zvcm1hdHRlci5qc1xuZnVuY3Rpb24gZGVmaW5lRm9ybWF0dGVyKHR5cGUsIGZvcm1hdCkge1xuICByZXR1cm4gKHsgZXhjbHVkZSwgZm9ybWF0OiBvdmVycmlkZXMgfSkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBleGNsdWRlLFxuICAgICAgZm9ybWF0OiAoYXJncykgPT4ge1xuICAgICAgICBjb25zdCBmb3JtYXR0ZWQgPSBmb3JtYXQoYXJncyk7XG4gICAgICAgIGlmIChleGNsdWRlKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgZXhjbHVkZSkge1xuICAgICAgICAgICAgZGVsZXRlIGZvcm1hdHRlZFtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLmZvcm1hdHRlZCxcbiAgICAgICAgICAuLi5vdmVycmlkZXMoYXJncylcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICB0eXBlXG4gICAgfTtcbiAgfTtcbn1cblxuLy8gbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS9jb25zdGFudHMvbnVtYmVyLmpzXG52YXIgbWF4SW50OCwgbWF4SW50MTYsIG1heEludDI0LCBtYXhJbnQzMiwgbWF4SW50NDAsIG1heEludDQ4LCBtYXhJbnQ1NiwgbWF4SW50NjQsIG1heEludDcyLCBtYXhJbnQ4MCwgbWF4SW50ODgsIG1heEludDk2LCBtYXhJbnQxMDQsIG1heEludDExMiwgbWF4SW50MTIwLCBtYXhJbnQxMjgsIG1heEludDEzNiwgbWF4SW50MTQ0LCBtYXhJbnQxNTIsIG1heEludDE2MCwgbWF4SW50MTY4LCBtYXhJbnQxNzYsIG1heEludDE4NCwgbWF4SW50MTkyLCBtYXhJbnQyMDAsIG1heEludDIwOCwgbWF4SW50MjE2LCBtYXhJbnQyMjQsIG1heEludDIzMiwgbWF4SW50MjQwLCBtYXhJbnQyNDgsIG1heEludDI1NiwgbWluSW50OCwgbWluSW50MTYsIG1pbkludDI0LCBtaW5JbnQzMiwgbWluSW50NDAsIG1pbkludDQ4LCBtaW5JbnQ1NiwgbWluSW50NjQsIG1pbkludDcyLCBtaW5JbnQ4MCwgbWluSW50ODgsIG1pbkludDk2LCBtaW5JbnQxMDQsIG1pbkludDExMiwgbWluSW50MTIwLCBtaW5JbnQxMjgsIG1pbkludDEzNiwgbWluSW50MTQ0LCBtaW5JbnQxNTIsIG1pbkludDE2MCwgbWluSW50MTY4LCBtaW5JbnQxNzYsIG1pbkludDE4NCwgbWluSW50MTkyLCBtaW5JbnQyMDAsIG1pbkludDIwOCwgbWluSW50MjE2LCBtaW5JbnQyMjQsIG1pbkludDIzMiwgbWluSW50MjQwLCBtaW5JbnQyNDgsIG1pbkludDI1NiwgbWF4VWludDgsIG1heFVpbnQxNiwgbWF4VWludDI0LCBtYXhVaW50MzIsIG1heFVpbnQ0MCwgbWF4VWludDQ4LCBtYXhVaW50NTYsIG1heFVpbnQ2NCwgbWF4VWludDcyLCBtYXhVaW50ODAsIG1heFVpbnQ4OCwgbWF4VWludDk2LCBtYXhVaW50MTA0LCBtYXhVaW50MTEyLCBtYXhVaW50MTIwLCBtYXhVaW50MTI4LCBtYXhVaW50MTM2LCBtYXhVaW50MTQ0LCBtYXhVaW50MTUyLCBtYXhVaW50MTYwLCBtYXhVaW50MTY4LCBtYXhVaW50MTc2LCBtYXhVaW50MTg0LCBtYXhVaW50MTkyLCBtYXhVaW50MjAwLCBtYXhVaW50MjA4LCBtYXhVaW50MjE2LCBtYXhVaW50MjI0LCBtYXhVaW50MjMyLCBtYXhVaW50MjQwLCBtYXhVaW50MjQ4LCBtYXhVaW50MjU2O1xudmFyIGluaXRfbnVtYmVyID0gX19lc20oKCkgPT4ge1xuICBtYXhJbnQ4ID0gMm4gKiogKDhuIC0gMW4pIC0gMW47XG4gIG1heEludDE2ID0gMm4gKiogKDE2biAtIDFuKSAtIDFuO1xuICBtYXhJbnQyNCA9IDJuICoqICgyNG4gLSAxbikgLSAxbjtcbiAgbWF4SW50MzIgPSAybiAqKiAoMzJuIC0gMW4pIC0gMW47XG4gIG1heEludDQwID0gMm4gKiogKDQwbiAtIDFuKSAtIDFuO1xuICBtYXhJbnQ0OCA9IDJuICoqICg0OG4gLSAxbikgLSAxbjtcbiAgbWF4SW50NTYgPSAybiAqKiAoNTZuIC0gMW4pIC0gMW47XG4gIG1heEludDY0ID0gMm4gKiogKDY0biAtIDFuKSAtIDFuO1xuICBtYXhJbnQ3MiA9IDJuICoqICg3Mm4gLSAxbikgLSAxbjtcbiAgbWF4SW50ODAgPSAybiAqKiAoODBuIC0gMW4pIC0gMW47XG4gIG1heEludDg4ID0gMm4gKiogKDg4biAtIDFuKSAtIDFuO1xuICBtYXhJbnQ5NiA9IDJuICoqICg5Nm4gLSAxbikgLSAxbjtcbiAgbWF4SW50MTA0ID0gMm4gKiogKDEwNG4gLSAxbikgLSAxbjtcbiAgbWF4SW50MTEyID0gMm4gKiogKDExMm4gLSAxbikgLSAxbjtcbiAgbWF4SW50MTIwID0gMm4gKiogKDEyMG4gLSAxbikgLSAxbjtcbiAgbWF4SW50MTI4ID0gMm4gKiogKDEyOG4gLSAxbikgLSAxbjtcbiAgbWF4SW50MTM2ID0gMm4gKiogKDEzNm4gLSAxbikgLSAxbjtcbiAgbWF4SW50MTQ0ID0gMm4gKiogKDE0NG4gLSAxbikgLSAxbjtcbiAgbWF4SW50MTUyID0gMm4gKiogKDE1Mm4gLSAxbikgLSAxbjtcbiAgbWF4SW50MTYwID0gMm4gKiogKDE2MG4gLSAxbikgLSAxbjtcbiAgbWF4SW50MTY4ID0gMm4gKiogKDE2OG4gLSAxbikgLSAxbjtcbiAgbWF4SW50MTc2ID0gMm4gKiogKDE3Nm4gLSAxbikgLSAxbjtcbiAgbWF4SW50MTg0ID0gMm4gKiogKDE4NG4gLSAxbikgLSAxbjtcbiAgbWF4SW50MTkyID0gMm4gKiogKDE5Mm4gLSAxbikgLSAxbjtcbiAgbWF4SW50MjAwID0gMm4gKiogKDIwMG4gLSAxbikgLSAxbjtcbiAgbWF4SW50MjA4ID0gMm4gKiogKDIwOG4gLSAxbikgLSAxbjtcbiAgbWF4SW50MjE2ID0gMm4gKiogKDIxNm4gLSAxbikgLSAxbjtcbiAgbWF4SW50MjI0ID0gMm4gKiogKDIyNG4gLSAxbikgLSAxbjtcbiAgbWF4SW50MjMyID0gMm4gKiogKDIzMm4gLSAxbikgLSAxbjtcbiAgbWF4SW50MjQwID0gMm4gKiogKDI0MG4gLSAxbikgLSAxbjtcbiAgbWF4SW50MjQ4ID0gMm4gKiogKDI0OG4gLSAxbikgLSAxbjtcbiAgbWF4SW50MjU2ID0gMm4gKiogKDI1Nm4gLSAxbikgLSAxbjtcbiAgbWluSW50OCA9IC0oMm4gKiogKDhuIC0gMW4pKTtcbiAgbWluSW50MTYgPSAtKDJuICoqICgxNm4gLSAxbikpO1xuICBtaW5JbnQyNCA9IC0oMm4gKiogKDI0biAtIDFuKSk7XG4gIG1pbkludDMyID0gLSgybiAqKiAoMzJuIC0gMW4pKTtcbiAgbWluSW50NDAgPSAtKDJuICoqICg0MG4gLSAxbikpO1xuICBtaW5JbnQ0OCA9IC0oMm4gKiogKDQ4biAtIDFuKSk7XG4gIG1pbkludDU2ID0gLSgybiAqKiAoNTZuIC0gMW4pKTtcbiAgbWluSW50NjQgPSAtKDJuICoqICg2NG4gLSAxbikpO1xuICBtaW5JbnQ3MiA9IC0oMm4gKiogKDcybiAtIDFuKSk7XG4gIG1pbkludDgwID0gLSgybiAqKiAoODBuIC0gMW4pKTtcbiAgbWluSW50ODggPSAtKDJuICoqICg4OG4gLSAxbikpO1xuICBtaW5JbnQ5NiA9IC0oMm4gKiogKDk2biAtIDFuKSk7XG4gIG1pbkludDEwNCA9IC0oMm4gKiogKDEwNG4gLSAxbikpO1xuICBtaW5JbnQxMTIgPSAtKDJuICoqICgxMTJuIC0gMW4pKTtcbiAgbWluSW50MTIwID0gLSgybiAqKiAoMTIwbiAtIDFuKSk7XG4gIG1pbkludDEyOCA9IC0oMm4gKiogKDEyOG4gLSAxbikpO1xuICBtaW5JbnQxMzYgPSAtKDJuICoqICgxMzZuIC0gMW4pKTtcbiAgbWluSW50MTQ0ID0gLSgybiAqKiAoMTQ0biAtIDFuKSk7XG4gIG1pbkludDE1MiA9IC0oMm4gKiogKDE1Mm4gLSAxbikpO1xuICBtaW5JbnQxNjAgPSAtKDJuICoqICgxNjBuIC0gMW4pKTtcbiAgbWluSW50MTY4ID0gLSgybiAqKiAoMTY4biAtIDFuKSk7XG4gIG1pbkludDE3NiA9IC0oMm4gKiogKDE3Nm4gLSAxbikpO1xuICBtaW5JbnQxODQgPSAtKDJuICoqICgxODRuIC0gMW4pKTtcbiAgbWluSW50MTkyID0gLSgybiAqKiAoMTkybiAtIDFuKSk7XG4gIG1pbkludDIwMCA9IC0oMm4gKiogKDIwMG4gLSAxbikpO1xuICBtaW5JbnQyMDggPSAtKDJuICoqICgyMDhuIC0gMW4pKTtcbiAgbWluSW50MjE2ID0gLSgybiAqKiAoMjE2biAtIDFuKSk7XG4gIG1pbkludDIyNCA9IC0oMm4gKiogKDIyNG4gLSAxbikpO1xuICBtaW5JbnQyMzIgPSAtKDJuICoqICgyMzJuIC0gMW4pKTtcbiAgbWluSW50MjQwID0gLSgybiAqKiAoMjQwbiAtIDFuKSk7XG4gIG1pbkludDI0OCA9IC0oMm4gKiogKDI0OG4gLSAxbikpO1xuICBtaW5JbnQyNTYgPSAtKDJuICoqICgyNTZuIC0gMW4pKTtcbiAgbWF4VWludDggPSAybiAqKiA4biAtIDFuO1xuICBtYXhVaW50MTYgPSAybiAqKiAxNm4gLSAxbjtcbiAgbWF4VWludDI0ID0gMm4gKiogMjRuIC0gMW47XG4gIG1heFVpbnQzMiA9IDJuICoqIDMybiAtIDFuO1xuICBtYXhVaW50NDAgPSAybiAqKiA0MG4gLSAxbjtcbiAgbWF4VWludDQ4ID0gMm4gKiogNDhuIC0gMW47XG4gIG1heFVpbnQ1NiA9IDJuICoqIDU2biAtIDFuO1xuICBtYXhVaW50NjQgPSAybiAqKiA2NG4gLSAxbjtcbiAgbWF4VWludDcyID0gMm4gKiogNzJuIC0gMW47XG4gIG1heFVpbnQ4MCA9IDJuICoqIDgwbiAtIDFuO1xuICBtYXhVaW50ODggPSAybiAqKiA4OG4gLSAxbjtcbiAgbWF4VWludDk2ID0gMm4gKiogOTZuIC0gMW47XG4gIG1heFVpbnQxMDQgPSAybiAqKiAxMDRuIC0gMW47XG4gIG1heFVpbnQxMTIgPSAybiAqKiAxMTJuIC0gMW47XG4gIG1heFVpbnQxMjAgPSAybiAqKiAxMjBuIC0gMW47XG4gIG1heFVpbnQxMjggPSAybiAqKiAxMjhuIC0gMW47XG4gIG1heFVpbnQxMzYgPSAybiAqKiAxMzZuIC0gMW47XG4gIG1heFVpbnQxNDQgPSAybiAqKiAxNDRuIC0gMW47XG4gIG1heFVpbnQxNTIgPSAybiAqKiAxNTJuIC0gMW47XG4gIG1heFVpbnQxNjAgPSAybiAqKiAxNjBuIC0gMW47XG4gIG1heFVpbnQxNjggPSAybiAqKiAxNjhuIC0gMW47XG4gIG1heFVpbnQxNzYgPSAybiAqKiAxNzZuIC0gMW47XG4gIG1heFVpbnQxODQgPSAybiAqKiAxODRuIC0gMW47XG4gIG1heFVpbnQxOTIgPSAybiAqKiAxOTJuIC0gMW47XG4gIG1heFVpbnQyMDAgPSAybiAqKiAyMDBuIC0gMW47XG4gIG1heFVpbnQyMDggPSAybiAqKiAyMDhuIC0gMW47XG4gIG1heFVpbnQyMTYgPSAybiAqKiAyMTZuIC0gMW47XG4gIG1heFVpbnQyMjQgPSAybiAqKiAyMjRuIC0gMW47XG4gIG1heFVpbnQyMzIgPSAybiAqKiAyMzJuIC0gMW47XG4gIG1heFVpbnQyNDAgPSAybiAqKiAyNDBuIC0gMW47XG4gIG1heFVpbnQyNDggPSAybiAqKiAyNDhuIC0gMW47XG4gIG1heFVpbnQyNTYgPSAybiAqKiAyNTZuIC0gMW47XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL19tZC5qc1xuZnVuY3Rpb24gc2V0QmlnVWludDY0KHZpZXcsIGJ5dGVPZmZzZXQsIHZhbHVlLCBpc0xFMikge1xuICBpZiAodHlwZW9mIHZpZXcuc2V0QmlnVWludDY0ID09PSBcImZ1bmN0aW9uXCIpXG4gICAgcmV0dXJuIHZpZXcuc2V0QmlnVWludDY0KGJ5dGVPZmZzZXQsIHZhbHVlLCBpc0xFMik7XG4gIGNvbnN0IF8zMm4yID0gQmlnSW50KDMyKTtcbiAgY29uc3QgX3UzMl9tYXggPSBCaWdJbnQoNDI5NDk2NzI5NSk7XG4gIGNvbnN0IHdoID0gTnVtYmVyKHZhbHVlID4+IF8zMm4yICYgX3UzMl9tYXgpO1xuICBjb25zdCB3bCA9IE51bWJlcih2YWx1ZSAmIF91MzJfbWF4KTtcbiAgY29uc3QgaCA9IGlzTEUyID8gNCA6IDA7XG4gIGNvbnN0IGwgPSBpc0xFMiA/IDAgOiA0O1xuICB2aWV3LnNldFVpbnQzMihieXRlT2Zmc2V0ICsgaCwgd2gsIGlzTEUyKTtcbiAgdmlldy5zZXRVaW50MzIoYnl0ZU9mZnNldCArIGwsIHdsLCBpc0xFMik7XG59XG5mdW5jdGlvbiBDaGkoYSwgYiwgYykge1xuICByZXR1cm4gYSAmIGIgXiB+YSAmIGM7XG59XG5mdW5jdGlvbiBNYWooYSwgYiwgYykge1xuICByZXR1cm4gYSAmIGIgXiBhICYgYyBeIGIgJiBjO1xufVxudmFyIEhhc2hNRCwgU0hBMjU2X0lWO1xudmFyIGluaXRfX21kID0gX19lc20oKCkgPT4ge1xuICBpbml0X3V0aWxzKCk7XG4gIEhhc2hNRCA9IGNsYXNzIEhhc2hNRCBleHRlbmRzIEhhc2gge1xuICAgIGNvbnN0cnVjdG9yKGJsb2NrTGVuLCBvdXRwdXRMZW4sIHBhZE9mZnNldCwgaXNMRTIpIHtcbiAgICAgIHN1cGVyKCk7XG4gICAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgdGhpcy5ibG9ja0xlbiA9IGJsb2NrTGVuO1xuICAgICAgdGhpcy5vdXRwdXRMZW4gPSBvdXRwdXRMZW47XG4gICAgICB0aGlzLnBhZE9mZnNldCA9IHBhZE9mZnNldDtcbiAgICAgIHRoaXMuaXNMRSA9IGlzTEUyO1xuICAgICAgdGhpcy5idWZmZXIgPSBuZXcgVWludDhBcnJheShibG9ja0xlbik7XG4gICAgICB0aGlzLnZpZXcgPSBjcmVhdGVWaWV3KHRoaXMuYnVmZmVyKTtcbiAgICB9XG4gICAgdXBkYXRlKGRhdGEpIHtcbiAgICAgIGFleGlzdHModGhpcyk7XG4gICAgICBkYXRhID0gdG9CeXRlcyhkYXRhKTtcbiAgICAgIGFieXRlcyhkYXRhKTtcbiAgICAgIGNvbnN0IHsgdmlldywgYnVmZmVyLCBibG9ja0xlbiB9ID0gdGhpcztcbiAgICAgIGNvbnN0IGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgZm9yIChsZXQgcG9zID0gMDtwb3MgPCBsZW47ICkge1xuICAgICAgICBjb25zdCB0YWtlID0gTWF0aC5taW4oYmxvY2tMZW4gLSB0aGlzLnBvcywgbGVuIC0gcG9zKTtcbiAgICAgICAgaWYgKHRha2UgPT09IGJsb2NrTGVuKSB7XG4gICAgICAgICAgY29uc3QgZGF0YVZpZXcgPSBjcmVhdGVWaWV3KGRhdGEpO1xuICAgICAgICAgIGZvciAoO2Jsb2NrTGVuIDw9IGxlbiAtIHBvczsgcG9zICs9IGJsb2NrTGVuKVxuICAgICAgICAgICAgdGhpcy5wcm9jZXNzKGRhdGFWaWV3LCBwb3MpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGJ1ZmZlci5zZXQoZGF0YS5zdWJhcnJheShwb3MsIHBvcyArIHRha2UpLCB0aGlzLnBvcyk7XG4gICAgICAgIHRoaXMucG9zICs9IHRha2U7XG4gICAgICAgIHBvcyArPSB0YWtlO1xuICAgICAgICBpZiAodGhpcy5wb3MgPT09IGJsb2NrTGVuKSB7XG4gICAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5sZW5ndGggKz0gZGF0YS5sZW5ndGg7XG4gICAgICB0aGlzLnJvdW5kQ2xlYW4oKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkaWdlc3RJbnRvKG91dCkge1xuICAgICAgYWV4aXN0cyh0aGlzKTtcbiAgICAgIGFvdXRwdXQob3V0LCB0aGlzKTtcbiAgICAgIHRoaXMuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgY29uc3QgeyBidWZmZXIsIHZpZXcsIGJsb2NrTGVuLCBpc0xFOiBpc0xFMiB9ID0gdGhpcztcbiAgICAgIGxldCB7IHBvcyB9ID0gdGhpcztcbiAgICAgIGJ1ZmZlcltwb3MrK10gPSAxMjg7XG4gICAgICBjbGVhbih0aGlzLmJ1ZmZlci5zdWJhcnJheShwb3MpKTtcbiAgICAgIGlmICh0aGlzLnBhZE9mZnNldCA+IGJsb2NrTGVuIC0gcG9zKSB7XG4gICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgcG9zID0gMDtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSBwb3M7aSA8IGJsb2NrTGVuOyBpKyspXG4gICAgICAgIGJ1ZmZlcltpXSA9IDA7XG4gICAgICBzZXRCaWdVaW50NjQodmlldywgYmxvY2tMZW4gLSA4LCBCaWdJbnQodGhpcy5sZW5ndGggKiA4KSwgaXNMRTIpO1xuICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgY29uc3Qgb3ZpZXcgPSBjcmVhdGVWaWV3KG91dCk7XG4gICAgICBjb25zdCBsZW4gPSB0aGlzLm91dHB1dExlbjtcbiAgICAgIGlmIChsZW4gJSA0KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJfc2hhMjogb3V0cHV0TGVuIHNob3VsZCBiZSBhbGlnbmVkIHRvIDMyYml0XCIpO1xuICAgICAgY29uc3Qgb3V0TGVuID0gbGVuIC8gNDtcbiAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5nZXQoKTtcbiAgICAgIGlmIChvdXRMZW4gPiBzdGF0ZS5sZW5ndGgpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIl9zaGEyOiBvdXRwdXRMZW4gYmlnZ2VyIHRoYW4gc3RhdGVcIik7XG4gICAgICBmb3IgKGxldCBpID0gMDtpIDwgb3V0TGVuOyBpKyspXG4gICAgICAgIG92aWV3LnNldFVpbnQzMig0ICogaSwgc3RhdGVbaV0sIGlzTEUyKTtcbiAgICB9XG4gICAgZGlnZXN0KCkge1xuICAgICAgY29uc3QgeyBidWZmZXIsIG91dHB1dExlbiB9ID0gdGhpcztcbiAgICAgIHRoaXMuZGlnZXN0SW50byhidWZmZXIpO1xuICAgICAgY29uc3QgcmVzID0gYnVmZmVyLnNsaWNlKDAsIG91dHB1dExlbik7XG4gICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIF9jbG9uZUludG8odG8pIHtcbiAgICAgIHRvIHx8ICh0byA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgICAgIHRvLnNldCguLi50aGlzLmdldCgpKTtcbiAgICAgIGNvbnN0IHsgYmxvY2tMZW4sIGJ1ZmZlciwgbGVuZ3RoLCBmaW5pc2hlZCwgZGVzdHJveWVkLCBwb3MgfSA9IHRoaXM7XG4gICAgICB0by5kZXN0cm95ZWQgPSBkZXN0cm95ZWQ7XG4gICAgICB0by5maW5pc2hlZCA9IGZpbmlzaGVkO1xuICAgICAgdG8ubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgdG8ucG9zID0gcG9zO1xuICAgICAgaWYgKGxlbmd0aCAlIGJsb2NrTGVuKVxuICAgICAgICB0by5idWZmZXIuc2V0KGJ1ZmZlcik7XG4gICAgICByZXR1cm4gdG87XG4gICAgfVxuICAgIGNsb25lKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2Nsb25lSW50bygpO1xuICAgIH1cbiAgfTtcbiAgU0hBMjU2X0lWID0gLyogQF9fUFVSRV9fICovIFVpbnQzMkFycmF5LmZyb20oW1xuICAgIDE3NzkwMzM3MDMsXG4gICAgMzE0NDEzNDI3NyxcbiAgICAxMDEzOTA0MjQyLFxuICAgIDI3NzM0ODA3NjIsXG4gICAgMTM1OTg5MzExOSxcbiAgICAyNjAwODIyOTI0LFxuICAgIDUyODczNDYzNSxcbiAgICAxNTQxNDU5MjI1XG4gIF0pO1xufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9zaGEyLmpzXG52YXIgU0hBMjU2X0ssIFNIQTI1Nl9XLCBTSEEyNTYsIHNoYTI1NjtcbnZhciBpbml0X3NoYTIgPSBfX2VzbSgoKSA9PiB7XG4gIGluaXRfX21kKCk7XG4gIGluaXRfdXRpbHMoKTtcbiAgU0hBMjU2X0sgPSAvKiBAX19QVVJFX18gKi8gVWludDMyQXJyYXkuZnJvbShbXG4gICAgMTExNjM1MjQwOCxcbiAgICAxODk5NDQ3NDQxLFxuICAgIDMwNDkzMjM0NzEsXG4gICAgMzkyMTAwOTU3MyxcbiAgICA5NjE5ODcxNjMsXG4gICAgMTUwODk3MDk5MyxcbiAgICAyNDUzNjM1NzQ4LFxuICAgIDI4NzA3NjMyMjEsXG4gICAgMzYyNDM4MTA4MCxcbiAgICAzMTA1OTg0MDEsXG4gICAgNjA3MjI1Mjc4LFxuICAgIDE0MjY4ODE5ODcsXG4gICAgMTkyNTA3ODM4OCxcbiAgICAyMTYyMDc4MjA2LFxuICAgIDI2MTQ4ODgxMDMsXG4gICAgMzI0ODIyMjU4MCxcbiAgICAzODM1MzkwNDAxLFxuICAgIDQwMjIyMjQ3NzQsXG4gICAgMjY0MzQ3MDc4LFxuICAgIDYwNDgwNzYyOCxcbiAgICA3NzAyNTU5ODMsXG4gICAgMTI0OTE1MDEyMixcbiAgICAxNTU1MDgxNjkyLFxuICAgIDE5OTYwNjQ5ODYsXG4gICAgMjU1NDIyMDg4MixcbiAgICAyODIxODM0MzQ5LFxuICAgIDI5NTI5OTY4MDgsXG4gICAgMzIxMDMxMzY3MSxcbiAgICAzMzM2NTcxODkxLFxuICAgIDM1ODQ1Mjg3MTEsXG4gICAgMTEzOTI2OTkzLFxuICAgIDMzODI0MTg5NSxcbiAgICA2NjYzMDcyMDUsXG4gICAgNzczNTI5OTEyLFxuICAgIDEyOTQ3NTczNzIsXG4gICAgMTM5NjE4MjI5MSxcbiAgICAxNjk1MTgzNzAwLFxuICAgIDE5ODY2NjEwNTEsXG4gICAgMjE3NzAyNjM1MCxcbiAgICAyNDU2OTU2MDM3LFxuICAgIDI3MzA0ODU5MjEsXG4gICAgMjgyMDMwMjQxMSxcbiAgICAzMjU5NzMwODAwLFxuICAgIDMzNDU3NjQ3NzEsXG4gICAgMzUxNjA2NTgxNyxcbiAgICAzNjAwMzUyODA0LFxuICAgIDQwOTQ1NzE5MDksXG4gICAgMjc1NDIzMzQ0LFxuICAgIDQzMDIyNzczNCxcbiAgICA1MDY5NDg2MTYsXG4gICAgNjU5MDYwNTU2LFxuICAgIDg4Mzk5Nzg3NyxcbiAgICA5NTgxMzk1NzEsXG4gICAgMTMyMjgyMjIxOCxcbiAgICAxNTM3MDAyMDYzLFxuICAgIDE3NDc4NzM3NzksXG4gICAgMTk1NTU2MjIyMixcbiAgICAyMDI0MTA0ODE1LFxuICAgIDIyMjc3MzA0NTIsXG4gICAgMjM2MTg1MjQyNCxcbiAgICAyNDI4NDM2NDc0LFxuICAgIDI3NTY3MzQxODcsXG4gICAgMzIwNDAzMTQ3OSxcbiAgICAzMzI5MzI1Mjk4XG4gIF0pO1xuICBTSEEyNTZfVyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoNjQpO1xuICBTSEEyNTYgPSBjbGFzcyBTSEEyNTYgZXh0ZW5kcyBIYXNoTUQge1xuICAgIGNvbnN0cnVjdG9yKG91dHB1dExlbiA9IDMyKSB7XG4gICAgICBzdXBlcig2NCwgb3V0cHV0TGVuLCA4LCBmYWxzZSk7XG4gICAgICB0aGlzLkEgPSBTSEEyNTZfSVZbMF0gfCAwO1xuICAgICAgdGhpcy5CID0gU0hBMjU2X0lWWzFdIHwgMDtcbiAgICAgIHRoaXMuQyA9IFNIQTI1Nl9JVlsyXSB8IDA7XG4gICAgICB0aGlzLkQgPSBTSEEyNTZfSVZbM10gfCAwO1xuICAgICAgdGhpcy5FID0gU0hBMjU2X0lWWzRdIHwgMDtcbiAgICAgIHRoaXMuRiA9IFNIQTI1Nl9JVls1XSB8IDA7XG4gICAgICB0aGlzLkcgPSBTSEEyNTZfSVZbNl0gfCAwO1xuICAgICAgdGhpcy5IID0gU0hBMjU2X0lWWzddIHwgMDtcbiAgICB9XG4gICAgZ2V0KCkge1xuICAgICAgY29uc3QgeyBBLCBCLCBDLCBELCBFLCBGLCBHLCBIIH0gPSB0aGlzO1xuICAgICAgcmV0dXJuIFtBLCBCLCBDLCBELCBFLCBGLCBHLCBIXTtcbiAgICB9XG4gICAgc2V0KEEsIEIsIEMsIEQsIEUsIEYsIEcsIEgpIHtcbiAgICAgIHRoaXMuQSA9IEEgfCAwO1xuICAgICAgdGhpcy5CID0gQiB8IDA7XG4gICAgICB0aGlzLkMgPSBDIHwgMDtcbiAgICAgIHRoaXMuRCA9IEQgfCAwO1xuICAgICAgdGhpcy5FID0gRSB8IDA7XG4gICAgICB0aGlzLkYgPSBGIHwgMDtcbiAgICAgIHRoaXMuRyA9IEcgfCAwO1xuICAgICAgdGhpcy5IID0gSCB8IDA7XG4gICAgfVxuICAgIHByb2Nlc3Modmlldywgb2Zmc2V0KSB7XG4gICAgICBmb3IgKGxldCBpID0gMDtpIDwgMTY7IGkrKywgb2Zmc2V0ICs9IDQpXG4gICAgICAgIFNIQTI1Nl9XW2ldID0gdmlldy5nZXRVaW50MzIob2Zmc2V0LCBmYWxzZSk7XG4gICAgICBmb3IgKGxldCBpID0gMTY7aSA8IDY0OyBpKyspIHtcbiAgICAgICAgY29uc3QgVzE1ID0gU0hBMjU2X1dbaSAtIDE1XTtcbiAgICAgICAgY29uc3QgVzIgPSBTSEEyNTZfV1tpIC0gMl07XG4gICAgICAgIGNvbnN0IHMwID0gcm90cihXMTUsIDcpIF4gcm90cihXMTUsIDE4KSBeIFcxNSA+Pj4gMztcbiAgICAgICAgY29uc3QgczEgPSByb3RyKFcyLCAxNykgXiByb3RyKFcyLCAxOSkgXiBXMiA+Pj4gMTA7XG4gICAgICAgIFNIQTI1Nl9XW2ldID0gczEgKyBTSEEyNTZfV1tpIC0gN10gKyBzMCArIFNIQTI1Nl9XW2kgLSAxNl0gfCAwO1xuICAgICAgfVxuICAgICAgbGV0IHsgQSwgQiwgQywgRCwgRSwgRiwgRywgSCB9ID0gdGhpcztcbiAgICAgIGZvciAobGV0IGkgPSAwO2kgPCA2NDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHNpZ21hMSA9IHJvdHIoRSwgNikgXiByb3RyKEUsIDExKSBeIHJvdHIoRSwgMjUpO1xuICAgICAgICBjb25zdCBUMSA9IEggKyBzaWdtYTEgKyBDaGkoRSwgRiwgRykgKyBTSEEyNTZfS1tpXSArIFNIQTI1Nl9XW2ldIHwgMDtcbiAgICAgICAgY29uc3Qgc2lnbWEwID0gcm90cihBLCAyKSBeIHJvdHIoQSwgMTMpIF4gcm90cihBLCAyMik7XG4gICAgICAgIGNvbnN0IFQyID0gc2lnbWEwICsgTWFqKEEsIEIsIEMpIHwgMDtcbiAgICAgICAgSCA9IEc7XG4gICAgICAgIEcgPSBGO1xuICAgICAgICBGID0gRTtcbiAgICAgICAgRSA9IEQgKyBUMSB8IDA7XG4gICAgICAgIEQgPSBDO1xuICAgICAgICBDID0gQjtcbiAgICAgICAgQiA9IEE7XG4gICAgICAgIEEgPSBUMSArIFQyIHwgMDtcbiAgICAgIH1cbiAgICAgIEEgPSBBICsgdGhpcy5BIHwgMDtcbiAgICAgIEIgPSBCICsgdGhpcy5CIHwgMDtcbiAgICAgIEMgPSBDICsgdGhpcy5DIHwgMDtcbiAgICAgIEQgPSBEICsgdGhpcy5EIHwgMDtcbiAgICAgIEUgPSBFICsgdGhpcy5FIHwgMDtcbiAgICAgIEYgPSBGICsgdGhpcy5GIHwgMDtcbiAgICAgIEcgPSBHICsgdGhpcy5HIHwgMDtcbiAgICAgIEggPSBIICsgdGhpcy5IIHwgMDtcbiAgICAgIHRoaXMuc2V0KEEsIEIsIEMsIEQsIEUsIEYsIEcsIEgpO1xuICAgIH1cbiAgICByb3VuZENsZWFuKCkge1xuICAgICAgY2xlYW4oU0hBMjU2X1cpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgdGhpcy5zZXQoMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCk7XG4gICAgICBjbGVhbih0aGlzLmJ1ZmZlcik7XG4gICAgfVxuICB9O1xuICBzaGEyNTYgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlSGFzaGVyKCgpID0+IG5ldyBTSEEyNTYpO1xufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy92aWVtL19lc20vZXJyb3JzL2NoYWluLmpzXG52YXIgSW52YWxpZENoYWluSWRFcnJvcjtcbnZhciBpbml0X2NoYWluID0gX19lc20oKCkgPT4ge1xuICBpbml0X2Jhc2UoKTtcbiAgSW52YWxpZENoYWluSWRFcnJvciA9IGNsYXNzIEludmFsaWRDaGFpbklkRXJyb3IgZXh0ZW5kcyBCYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgY2hhaW5JZCB9KSB7XG4gICAgICBzdXBlcih0eXBlb2YgY2hhaW5JZCA9PT0gXCJudW1iZXJcIiA/IGBDaGFpbiBJRCBcIiR7Y2hhaW5JZH1cIiBpcyBpbnZhbGlkLmAgOiBcIkNoYWluIElEIGlzIGludmFsaWQuXCIsIHsgbmFtZTogXCJJbnZhbGlkQ2hhaW5JZEVycm9yXCIgfSk7XG4gICAgfVxuICB9O1xufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9AbWV0YW1hc2svc3VwZXJzdHJ1Y3QvZGlzdC9lcnJvci5tanNcbmNsYXNzIFN0cnVjdEVycm9yIGV4dGVuZHMgVHlwZUVycm9yIHtcbiAgY29uc3RydWN0b3IoZmFpbHVyZSwgZmFpbHVyZXMpIHtcbiAgICBsZXQgY2FjaGVkO1xuICAgIGNvbnN0IHsgbWVzc2FnZSwgZXhwbGFuYXRpb24sIC4uLnJlc3QgfSA9IGZhaWx1cmU7XG4gICAgY29uc3QgeyBwYXRoIH0gPSBmYWlsdXJlO1xuICAgIGNvbnN0IGNhdXNlID0gcGF0aC5sZW5ndGggPT09IDAgPyBtZXNzYWdlIDogYEF0IHBhdGg6ICR7cGF0aC5qb2luKFwiLlwiKX0gLS0gJHttZXNzYWdlfWA7XG4gICAgc3VwZXIoZXhwbGFuYXRpb24gPz8gY2F1c2UpO1xuICAgIGlmIChleHBsYW5hdGlvbiAhPT0gbnVsbCAmJiBleHBsYW5hdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmNhdXNlID0gY2F1c2U7XG4gICAgfVxuICAgIE9iamVjdC5hc3NpZ24odGhpcywgcmVzdCk7XG4gICAgdGhpcy5uYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgIHRoaXMuZmFpbHVyZXMgPSAoKSA9PiB7XG4gICAgICByZXR1cm4gY2FjaGVkID8/IChjYWNoZWQgPSBbZmFpbHVyZSwgLi4uZmFpbHVyZXMoKV0pO1xuICAgIH07XG4gIH1cbn1cblxuLy8gbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zdXBlcnN0cnVjdC9kaXN0L3V0aWxzLm1qc1xuZnVuY3Rpb24gaXNJdGVyYWJsZSh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3QodmFsdWUpICYmIHR5cGVvZiB2YWx1ZVtTeW1ib2wuaXRlcmF0b3JdID09PSBcImZ1bmN0aW9uXCI7XG59XG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHZhbHVlICE9PSBudWxsO1xufVxuZnVuY3Rpb24gcHJpbnQodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzeW1ib2xcIikge1xuICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICB9XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgPyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkgOiBgJHt2YWx1ZX1gO1xufVxuZnVuY3Rpb24gc2hpZnRJdGVyYXRvcihpbnB1dCkge1xuICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBpbnB1dC5uZXh0KCk7XG4gIHJldHVybiBkb25lID8gdW5kZWZpbmVkIDogdmFsdWU7XG59XG5mdW5jdGlvbiB0b0ZhaWx1cmUocmVzdWx0LCBjb250ZXh0LCBzdHJ1Y3QsIHZhbHVlKSB7XG4gIGlmIChyZXN1bHQgPT09IHRydWUpIHtcbiAgICByZXR1cm47XG4gIH0gZWxzZSBpZiAocmVzdWx0ID09PSBmYWxzZSkge1xuICAgIHJlc3VsdCA9IHt9O1xuICB9IGVsc2UgaWYgKHR5cGVvZiByZXN1bHQgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXN1bHQgPSB7IG1lc3NhZ2U6IHJlc3VsdCB9O1xuICB9XG4gIGNvbnN0IHsgcGF0aCwgYnJhbmNoIH0gPSBjb250ZXh0O1xuICBjb25zdCB7IHR5cGUgfSA9IHN0cnVjdDtcbiAgY29uc3QgeyByZWZpbmVtZW50LCBtZXNzYWdlID0gYEV4cGVjdGVkIGEgdmFsdWUgb2YgdHlwZSBcXGAke3R5cGV9XFxgJHtyZWZpbmVtZW50ID8gYCB3aXRoIHJlZmluZW1lbnQgXFxgJHtyZWZpbmVtZW50fVxcYGAgOiBcIlwifSwgYnV0IHJlY2VpdmVkOiBcXGAke3ByaW50KHZhbHVlKX1cXGBgIH0gPSByZXN1bHQ7XG4gIHJldHVybiB7XG4gICAgdmFsdWUsXG4gICAgdHlwZSxcbiAgICByZWZpbmVtZW50LFxuICAgIGtleTogcGF0aFtwYXRoLmxlbmd0aCAtIDFdLFxuICAgIHBhdGgsXG4gICAgYnJhbmNoLFxuICAgIC4uLnJlc3VsdCxcbiAgICBtZXNzYWdlXG4gIH07XG59XG5mdW5jdGlvbiogdG9GYWlsdXJlcyhyZXN1bHQsIGNvbnRleHQsIHN0cnVjdCwgdmFsdWUpIHtcbiAgaWYgKCFpc0l0ZXJhYmxlKHJlc3VsdCkpIHtcbiAgICByZXN1bHQgPSBbcmVzdWx0XTtcbiAgfVxuICBmb3IgKGNvbnN0IHZhbGlkYXRpb25SZXN1bHQgb2YgcmVzdWx0KSB7XG4gICAgY29uc3QgZmFpbHVyZSA9IHRvRmFpbHVyZSh2YWxpZGF0aW9uUmVzdWx0LCBjb250ZXh0LCBzdHJ1Y3QsIHZhbHVlKTtcbiAgICBpZiAoZmFpbHVyZSkge1xuICAgICAgeWllbGQgZmFpbHVyZTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uKiBydW4odmFsdWUsIHN0cnVjdCwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHsgcGF0aCA9IFtdLCBicmFuY2ggPSBbdmFsdWVdLCBjb2VyY2UgPSBmYWxzZSwgbWFzayA9IGZhbHNlIH0gPSBvcHRpb25zO1xuICBjb25zdCBjb250ZXh0ID0geyBwYXRoLCBicmFuY2ggfTtcbiAgaWYgKGNvZXJjZSkge1xuICAgIHZhbHVlID0gc3RydWN0LmNvZXJjZXIodmFsdWUsIGNvbnRleHQpO1xuICAgIGlmIChtYXNrICYmIHN0cnVjdC50eXBlICE9PSBcInR5cGVcIiAmJiBpc09iamVjdChzdHJ1Y3Quc2NoZW1hKSAmJiBpc09iamVjdCh2YWx1ZSkgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiB2YWx1ZSkge1xuICAgICAgICBpZiAoc3RydWN0LnNjaGVtYVtrZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBkZWxldGUgdmFsdWVba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBsZXQgc3RhdHVzID0gXCJ2YWxpZFwiO1xuICBmb3IgKGNvbnN0IGZhaWx1cmUgb2Ygc3RydWN0LnZhbGlkYXRvcih2YWx1ZSwgY29udGV4dCkpIHtcbiAgICBmYWlsdXJlLmV4cGxhbmF0aW9uID0gb3B0aW9ucy5tZXNzYWdlO1xuICAgIHN0YXR1cyA9IFwibm90X3ZhbGlkXCI7XG4gICAgeWllbGQgW2ZhaWx1cmUsIHVuZGVmaW5lZF07XG4gIH1cbiAgZm9yIChsZXQgW2lubmVyS2V5LCBpbm5lclZhbHVlLCBpbm5lclN0cnVjdF0gb2Ygc3RydWN0LmVudHJpZXModmFsdWUsIGNvbnRleHQpKSB7XG4gICAgY29uc3QgaXRlcmFibGUgPSBydW4oaW5uZXJWYWx1ZSwgaW5uZXJTdHJ1Y3QsIHtcbiAgICAgIHBhdGg6IGlubmVyS2V5ID09PSB1bmRlZmluZWQgPyBwYXRoIDogWy4uLnBhdGgsIGlubmVyS2V5XSxcbiAgICAgIGJyYW5jaDogaW5uZXJLZXkgPT09IHVuZGVmaW5lZCA/IGJyYW5jaCA6IFsuLi5icmFuY2gsIGlubmVyVmFsdWVdLFxuICAgICAgY29lcmNlLFxuICAgICAgbWFzayxcbiAgICAgIG1lc3NhZ2U6IG9wdGlvbnMubWVzc2FnZVxuICAgIH0pO1xuICAgIGZvciAoY29uc3QgcmVzdWx0IG9mIGl0ZXJhYmxlKSB7XG4gICAgICBpZiAocmVzdWx0WzBdKSB7XG4gICAgICAgIHN0YXR1cyA9IHJlc3VsdFswXS5yZWZpbmVtZW50ID09PSBudWxsIHx8IHJlc3VsdFswXS5yZWZpbmVtZW50ID09PSB1bmRlZmluZWQgPyBcIm5vdF92YWxpZFwiIDogXCJub3RfcmVmaW5lZFwiO1xuICAgICAgICB5aWVsZCBbcmVzdWx0WzBdLCB1bmRlZmluZWRdO1xuICAgICAgfSBlbHNlIGlmIChjb2VyY2UpIHtcbiAgICAgICAgaW5uZXJWYWx1ZSA9IHJlc3VsdFsxXTtcbiAgICAgICAgaWYgKGlubmVyS2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YWx1ZSA9IGlubmVyVmFsdWU7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgICB2YWx1ZS5zZXQoaW5uZXJLZXksIGlubmVyVmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgICAgdmFsdWUuYWRkKGlubmVyVmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgIGlmIChpbm5lclZhbHVlICE9PSB1bmRlZmluZWQgfHwgaW5uZXJLZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgIHZhbHVlW2lubmVyS2V5XSA9IGlubmVyVmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChzdGF0dXMgIT09IFwibm90X3ZhbGlkXCIpIHtcbiAgICBmb3IgKGNvbnN0IGZhaWx1cmUgb2Ygc3RydWN0LnJlZmluZXIodmFsdWUsIGNvbnRleHQpKSB7XG4gICAgICBmYWlsdXJlLmV4cGxhbmF0aW9uID0gb3B0aW9ucy5tZXNzYWdlO1xuICAgICAgc3RhdHVzID0gXCJub3RfcmVmaW5lZFwiO1xuICAgICAgeWllbGQgW2ZhaWx1cmUsIHVuZGVmaW5lZF07XG4gICAgfVxuICB9XG4gIGlmIChzdGF0dXMgPT09IFwidmFsaWRcIikge1xuICAgIHlpZWxkIFt1bmRlZmluZWQsIHZhbHVlXTtcbiAgfVxufVxuXG4vLyBub2RlX21vZHVsZXMvQG1ldGFtYXNrL3N1cGVyc3RydWN0L2Rpc3Qvc3RydWN0Lm1qc1xuY2xhc3MgU3RydWN0IHtcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBjb25zdCB7IHR5cGUsIHNjaGVtYSwgdmFsaWRhdG9yLCByZWZpbmVyLCBjb2VyY2VyID0gKHZhbHVlKSA9PiB2YWx1ZSwgZW50cmllcyA9IGZ1bmN0aW9uKiAoKSB7fSB9ID0gcHJvcHM7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLnNjaGVtYSA9IHNjaGVtYTtcbiAgICB0aGlzLmVudHJpZXMgPSBlbnRyaWVzO1xuICAgIHRoaXMuY29lcmNlciA9IGNvZXJjZXI7XG4gICAgaWYgKHZhbGlkYXRvcikge1xuICAgICAgdGhpcy52YWxpZGF0b3IgPSAodmFsdWUsIGNvbnRleHQpID0+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdmFsaWRhdG9yKHZhbHVlLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHRvRmFpbHVyZXMocmVzdWx0LCBjb250ZXh0LCB0aGlzLCB2YWx1ZSk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnZhbGlkYXRvciA9ICgpID0+IFtdO1xuICAgIH1cbiAgICBpZiAocmVmaW5lcikge1xuICAgICAgdGhpcy5yZWZpbmVyID0gKHZhbHVlLCBjb250ZXh0KSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlZmluZXIodmFsdWUsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gdG9GYWlsdXJlcyhyZXN1bHQsIGNvbnRleHQsIHRoaXMsIHZhbHVlKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVmaW5lciA9ICgpID0+IFtdO1xuICAgIH1cbiAgfVxuICBhc3NlcnQodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gYXNzZXJ0KHZhbHVlLCB0aGlzLCBtZXNzYWdlKTtcbiAgfVxuICBjcmVhdGUodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gY3JlYXRlKHZhbHVlLCB0aGlzLCBtZXNzYWdlKTtcbiAgfVxuICBpcyh2YWx1ZSkge1xuICAgIHJldHVybiBpcyh2YWx1ZSwgdGhpcyk7XG4gIH1cbiAgbWFzayh2YWx1ZSwgbWVzc2FnZSkge1xuICAgIHJldHVybiBtYXNrKHZhbHVlLCB0aGlzLCBtZXNzYWdlKTtcbiAgfVxuICB2YWxpZGF0ZSh2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIHZhbGlkYXRlKHZhbHVlLCB0aGlzLCBvcHRpb25zKTtcbiAgfVxufVxudmFyIEV4YWN0T3B0aW9uYWxCcmFuZCA9IFwiRVhBQ1RfT1BUSU9OQUxcIjtcblxuY2xhc3MgRXhhY3RPcHRpb25hbFN0cnVjdCBleHRlbmRzIFN0cnVjdCB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIoe1xuICAgICAgLi4ucHJvcHMsXG4gICAgICB0eXBlOiBgZXhhY3Qgb3B0aW9uYWwgJHtwcm9wcy50eXBlfWBcbiAgICB9KTtcbiAgICB0aGlzLmJyYW5kID0gRXhhY3RPcHRpb25hbEJyYW5kO1xuICB9XG4gIHN0YXRpYyBpc0V4YWN0T3B0aW9uYWwodmFsdWUpIHtcbiAgICByZXR1cm4gaXNPYmplY3QodmFsdWUpICYmIFwiYnJhbmRcIiBpbiB2YWx1ZSAmJiB2YWx1ZS5icmFuZCA9PT0gRXhhY3RPcHRpb25hbEJyYW5kO1xuICB9XG59XG5mdW5jdGlvbiBhc3NlcnQodmFsdWUsIHN0cnVjdCwgbWVzc2FnZSkge1xuICBjb25zdCByZXN1bHQgPSB2YWxpZGF0ZSh2YWx1ZSwgc3RydWN0LCB7IG1lc3NhZ2UgfSk7XG4gIGlmIChyZXN1bHRbMF0pIHtcbiAgICB0aHJvdyByZXN1bHRbMF07XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZSh2YWx1ZSwgc3RydWN0LCBtZXNzYWdlKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHZhbGlkYXRlKHZhbHVlLCBzdHJ1Y3QsIHsgY29lcmNlOiB0cnVlLCBtZXNzYWdlIH0pO1xuICBpZiAocmVzdWx0WzBdKSB7XG4gICAgdGhyb3cgcmVzdWx0WzBdO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiByZXN1bHRbMV07XG4gIH1cbn1cbmZ1bmN0aW9uIG1hc2sodmFsdWUsIHN0cnVjdCwgbWVzc2FnZSkge1xuICBjb25zdCByZXN1bHQgPSB2YWxpZGF0ZSh2YWx1ZSwgc3RydWN0LCB7IGNvZXJjZTogdHJ1ZSwgbWFzazogdHJ1ZSwgbWVzc2FnZSB9KTtcbiAgaWYgKHJlc3VsdFswXSkge1xuICAgIHRocm93IHJlc3VsdFswXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcmVzdWx0WzFdO1xuICB9XG59XG5mdW5jdGlvbiBpcyh2YWx1ZSwgc3RydWN0KSB7XG4gIGNvbnN0IHJlc3VsdCA9IHZhbGlkYXRlKHZhbHVlLCBzdHJ1Y3QpO1xuICByZXR1cm4gIXJlc3VsdFswXTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlKHZhbHVlLCBzdHJ1Y3QsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB0dXBsZXMgPSBydW4odmFsdWUsIHN0cnVjdCwgb3B0aW9ucyk7XG4gIGNvbnN0IHR1cGxlID0gc2hpZnRJdGVyYXRvcih0dXBsZXMpO1xuICBpZiAodHVwbGVbMF0pIHtcbiAgICBjb25zdCBlcnJvciA9IG5ldyBTdHJ1Y3RFcnJvcih0dXBsZVswXSwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGZvciAoY29uc3QgaW5uZXJUdXBsZSBvZiB0dXBsZXMpIHtcbiAgICAgICAgaWYgKGlubmVyVHVwbGVbMF0pIHtcbiAgICAgICAgICB5aWVsZCBpbm5lclR1cGxlWzBdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIFtlcnJvciwgdW5kZWZpbmVkXTtcbiAgfVxuICBjb25zdCB2YWxpZGF0ZWRWYWx1ZSA9IHR1cGxlWzFdO1xuICByZXR1cm4gW3VuZGVmaW5lZCwgdmFsaWRhdGVkVmFsdWVdO1xufVxuXG4vLyBub2RlX21vZHVsZXMvQG1ldGFtYXNrL3N1cGVyc3RydWN0L2Rpc3Qvc3RydWN0cy91dGlsaXRpZXMubWpzXG5mdW5jdGlvbiBkZWZpbmUobmFtZSwgdmFsaWRhdG9yKSB7XG4gIHJldHVybiBuZXcgU3RydWN0KHsgdHlwZTogbmFtZSwgc2NoZW1hOiBudWxsLCB2YWxpZGF0b3IgfSk7XG59XG5cbi8vIG5vZGVfbW9kdWxlcy9AbWV0YW1hc2svc3VwZXJzdHJ1Y3QvZGlzdC9zdHJ1Y3RzL3R5cGVzLm1qc1xuZnVuY3Rpb24gYW55KCkge1xuICByZXR1cm4gZGVmaW5lKFwiYW55XCIsICgpID0+IHRydWUpO1xufVxuZnVuY3Rpb24gYXJyYXkoRWxlbWVudCkge1xuICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIHNjaGVtYTogRWxlbWVudCxcbiAgICAqZW50cmllcyh2YWx1ZSkge1xuICAgICAgaWYgKEVsZW1lbnQgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgZm9yIChjb25zdCBbaW5kZXgsIGFycmF5VmFsdWVdIG9mIHZhbHVlLmVudHJpZXMoKSkge1xuICAgICAgICAgIHlpZWxkIFtpbmRleCwgYXJyYXlWYWx1ZSwgRWxlbWVudF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGNvZXJjZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlLnNsaWNlKCkgOiB2YWx1ZTtcbiAgICB9LFxuICAgIHZhbGlkYXRvcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IGBFeHBlY3RlZCBhbiBhcnJheSB2YWx1ZSwgYnV0IHJlY2VpdmVkOiAke3ByaW50KHZhbHVlKX1gO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBpbnRlZ2VyKCkge1xuICByZXR1cm4gZGVmaW5lKFwiaW50ZWdlclwiLCAodmFsdWUpID0+IHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiICYmICFpc05hTih2YWx1ZSkgJiYgTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSkgfHwgYEV4cGVjdGVkIGFuIGludGVnZXIsIGJ1dCByZWNlaXZlZDogJHtwcmludCh2YWx1ZSl9YDtcbiAgfSk7XG59XG5mdW5jdGlvbiBsaXRlcmFsKGNvbnN0YW50KSB7XG4gIGNvbnN0IGRlc2NyaXB0aW9uID0gcHJpbnQoY29uc3RhbnQpO1xuICBjb25zdCB2YWx1ZVR5cGUgPSB0eXBlb2YgY29uc3RhbnQ7XG4gIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICB0eXBlOiBcImxpdGVyYWxcIixcbiAgICBzY2hlbWE6IHZhbHVlVHlwZSA9PT0gXCJzdHJpbmdcIiB8fCB2YWx1ZVR5cGUgPT09IFwibnVtYmVyXCIgfHwgdmFsdWVUeXBlID09PSBcImJvb2xlYW5cIiA/IGNvbnN0YW50IDogbnVsbCxcbiAgICB2YWxpZGF0b3IodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gY29uc3RhbnQgfHwgYEV4cGVjdGVkIHRoZSBsaXRlcmFsIFxcYCR7ZGVzY3JpcHRpb259XFxgLCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWA7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIG5ldmVyKCkge1xuICByZXR1cm4gZGVmaW5lKFwibmV2ZXJcIiwgKCkgPT4gZmFsc2UpO1xufVxuZnVuY3Rpb24gbnVsbGFibGUoc3RydWN0KSB7XG4gIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICAuLi5zdHJ1Y3QsXG4gICAgdmFsaWRhdG9yOiAodmFsdWUsIGN0eCkgPT4gdmFsdWUgPT09IG51bGwgfHwgc3RydWN0LnZhbGlkYXRvcih2YWx1ZSwgY3R4KSxcbiAgICByZWZpbmVyOiAodmFsdWUsIGN0eCkgPT4gdmFsdWUgPT09IG51bGwgfHwgc3RydWN0LnJlZmluZXIodmFsdWUsIGN0eClcbiAgfSk7XG59XG5mdW5jdGlvbiBudW1iZXIoKSB7XG4gIHJldHVybiBkZWZpbmUoXCJudW1iZXJcIiwgKHZhbHVlKSA9PiB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiAmJiAhaXNOYU4odmFsdWUpIHx8IGBFeHBlY3RlZCBhIG51bWJlciwgYnV0IHJlY2VpdmVkOiAke3ByaW50KHZhbHVlKX1gO1xuICB9KTtcbn1cbmZ1bmN0aW9uIG9iamVjdChzY2hlbWEpIHtcbiAgY29uc3Qga25vd25zID0gc2NoZW1hID8gT2JqZWN0LmtleXMoc2NoZW1hKSA6IFtdO1xuICBjb25zdCBOZXZlciA9IG5ldmVyKCk7XG4gIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgIHNjaGVtYTogc2NoZW1hID8/IG51bGwsXG4gICAgKmVudHJpZXModmFsdWUpIHtcbiAgICAgIGlmIChzY2hlbWEgJiYgaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgIGNvbnN0IHVua25vd25zID0gbmV3IFNldChPYmplY3Qua2V5cyh2YWx1ZSkpO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBrbm93bnMpIHtcbiAgICAgICAgICB1bmtub3ducy5kZWxldGUoa2V5KTtcbiAgICAgICAgICBjb25zdCBwcm9wZXJ0eVNjaGVtYSA9IHNjaGVtYVtrZXldO1xuICAgICAgICAgIGlmIChFeGFjdE9wdGlvbmFsU3RydWN0LmlzRXhhY3RPcHRpb25hbChwcm9wZXJ0eVNjaGVtYSkgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHlpZWxkIFtrZXksIHZhbHVlW2tleV0sIHNjaGVtYVtrZXldXTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiB1bmtub3ducykge1xuICAgICAgICAgIHlpZWxkIFtrZXksIHZhbHVlW2tleV0sIE5ldmVyXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgdmFsaWRhdG9yKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3QodmFsdWUpIHx8IGBFeHBlY3RlZCBhbiBvYmplY3QsIGJ1dCByZWNlaXZlZDogJHtwcmludCh2YWx1ZSl9YDtcbiAgICB9LFxuICAgIGNvZXJjZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdCh2YWx1ZSkgPyB7IC4uLnZhbHVlIH0gOiB2YWx1ZTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gb3B0aW9uYWwoc3RydWN0KSB7XG4gIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICAuLi5zdHJ1Y3QsXG4gICAgdmFsaWRhdG9yOiAodmFsdWUsIGN0eCkgPT4gdmFsdWUgPT09IHVuZGVmaW5lZCB8fCBzdHJ1Y3QudmFsaWRhdG9yKHZhbHVlLCBjdHgpLFxuICAgIHJlZmluZXI6ICh2YWx1ZSwgY3R4KSA9PiB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHN0cnVjdC5yZWZpbmVyKHZhbHVlLCBjdHgpXG4gIH0pO1xufVxuZnVuY3Rpb24gcmVjb3JkKEtleSwgVmFsdWUpIHtcbiAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgIHR5cGU6IFwicmVjb3JkXCIsXG4gICAgc2NoZW1hOiBudWxsLFxuICAgICplbnRyaWVzKHZhbHVlKSB7XG4gICAgICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgIGZvciAoY29uc3Qgb2JqZWN0S2V5IGluIHZhbHVlKSB7XG4gICAgICAgICAgY29uc3Qgb2JqZWN0VmFsdWUgPSB2YWx1ZVtvYmplY3RLZXldO1xuICAgICAgICAgIHlpZWxkIFtvYmplY3RLZXksIG9iamVjdEtleSwgS2V5XTtcbiAgICAgICAgICB5aWVsZCBbb2JqZWN0S2V5LCBvYmplY3RWYWx1ZSwgVmFsdWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICB2YWxpZGF0b3IodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdCh2YWx1ZSkgfHwgYEV4cGVjdGVkIGFuIG9iamVjdCwgYnV0IHJlY2VpdmVkOiAke3ByaW50KHZhbHVlKX1gO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBzdHJpbmcoKSB7XG4gIHJldHVybiBkZWZpbmUoXCJzdHJpbmdcIiwgKHZhbHVlKSA9PiB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiB8fCBgRXhwZWN0ZWQgYSBzdHJpbmcsIGJ1dCByZWNlaXZlZDogJHtwcmludCh2YWx1ZSl9YDtcbiAgfSk7XG59XG5mdW5jdGlvbiB1bmlvbihTdHJ1Y3RzKSB7XG4gIGNvbnN0IGRlc2NyaXB0aW9uID0gU3RydWN0cy5tYXAoKHN0cnVjdCkgPT4gc3RydWN0LnR5cGUpLmpvaW4oXCIgfCBcIik7XG4gIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICB0eXBlOiBcInVuaW9uXCIsXG4gICAgc2NoZW1hOiBudWxsLFxuICAgIGNvZXJjZXIodmFsdWUpIHtcbiAgICAgIGZvciAoY29uc3QgSW5uZXJTdHJ1Y3Qgb2YgU3RydWN0cykge1xuICAgICAgICBjb25zdCBbZXJyb3IsIGNvZXJjZWRdID0gSW5uZXJTdHJ1Y3QudmFsaWRhdGUodmFsdWUsIHsgY29lcmNlOiB0cnVlIH0pO1xuICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGNvZXJjZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIHZhbGlkYXRvcih2YWx1ZSwgY3R4KSB7XG4gICAgICBjb25zdCBmYWlsdXJlcyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBJbm5lclN0cnVjdCBvZiBTdHJ1Y3RzKSB7XG4gICAgICAgIGNvbnN0IFsuLi50dXBsZXNdID0gcnVuKHZhbHVlLCBJbm5lclN0cnVjdCwgY3R4KTtcbiAgICAgICAgY29uc3QgW2ZpcnN0XSA9IHR1cGxlcztcbiAgICAgICAgaWYgKCFmaXJzdD8uWzBdKSB7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgW2ZhaWx1cmVdIG9mIHR1cGxlcykge1xuICAgICAgICAgIGlmIChmYWlsdXJlKSB7XG4gICAgICAgICAgICBmYWlsdXJlcy5wdXNoKGZhaWx1cmUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgYEV4cGVjdGVkIHRoZSB2YWx1ZSB0byBzYXRpc2Z5IGEgdW5pb24gb2YgXFxgJHtkZXNjcmlwdGlvbn1cXGAsIGJ1dCByZWNlaXZlZDogJHtwcmludCh2YWx1ZSl9YCxcbiAgICAgICAgLi4uZmFpbHVyZXNcbiAgICAgIF07XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIHVua25vd24oKSB7XG4gIHJldHVybiBkZWZpbmUoXCJ1bmtub3duXCIsICgpID0+IHRydWUpO1xufVxuXG4vLyBub2RlX21vZHVsZXMvQG1ldGFtYXNrL3N1cGVyc3RydWN0L2Rpc3Qvc3RydWN0cy9jb2VyY2lvbnMubWpzXG5mdW5jdGlvbiBjb2VyY2Uoc3RydWN0LCBjb25kaXRpb24sIGNvZXJjZXIpIHtcbiAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgIC4uLnN0cnVjdCxcbiAgICBjb2VyY2VyOiAodmFsdWUsIGN0eCkgPT4ge1xuICAgICAgcmV0dXJuIGlzKHZhbHVlLCBjb25kaXRpb24pID8gc3RydWN0LmNvZXJjZXIoY29lcmNlcih2YWx1ZSwgY3R4KSwgY3R4KSA6IHN0cnVjdC5jb2VyY2VyKHZhbHVlLCBjdHgpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8vIG5vZGVfbW9kdWxlcy9AbWV0YW1hc2svc3VwZXJzdHJ1Y3QvZGlzdC9zdHJ1Y3RzL3JlZmluZW1lbnRzLm1qc1xuZnVuY3Rpb24gcmVmaW5lKHN0cnVjdCwgbmFtZSwgcmVmaW5lcikge1xuICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgLi4uc3RydWN0LFxuICAgICpyZWZpbmVyKHZhbHVlLCBjdHgpIHtcbiAgICAgIHlpZWxkKiBzdHJ1Y3QucmVmaW5lcih2YWx1ZSwgY3R4KTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHJlZmluZXIodmFsdWUsIGN0eCk7XG4gICAgICBjb25zdCBmYWlsdXJlcyA9IHRvRmFpbHVyZXMocmVzdWx0LCBjdHgsIHN0cnVjdCwgdmFsdWUpO1xuICAgICAgZm9yIChjb25zdCBmYWlsdXJlIG9mIGZhaWx1cmVzKSB7XG4gICAgICAgIHlpZWxkIHsgLi4uZmFpbHVyZSwgcmVmaW5lbWVudDogbmFtZSB9O1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5cbi8vIG5vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9taXNjLm1qc1xuZnVuY3Rpb24gaXNPYmplY3QyKHZhbHVlKSB7XG4gIHJldHVybiBCb29sZWFuKHZhbHVlKSAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpO1xufVxudmFyIGhhc1Byb3BlcnR5ID0gKG9iamVjdFRvQ2hlY2ssIG5hbWUpID0+IE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdFRvQ2hlY2ssIG5hbWUpO1xudmFyIEpzb25TaXplO1xuKGZ1bmN0aW9uKEpzb25TaXplMikge1xuICBKc29uU2l6ZTJbSnNvblNpemUyW1wiTnVsbFwiXSA9IDRdID0gXCJOdWxsXCI7XG4gIEpzb25TaXplMltKc29uU2l6ZTJbXCJDb21tYVwiXSA9IDFdID0gXCJDb21tYVwiO1xuICBKc29uU2l6ZTJbSnNvblNpemUyW1wiV3JhcHBlclwiXSA9IDFdID0gXCJXcmFwcGVyXCI7XG4gIEpzb25TaXplMltKc29uU2l6ZTJbXCJUcnVlXCJdID0gNF0gPSBcIlRydWVcIjtcbiAgSnNvblNpemUyW0pzb25TaXplMltcIkZhbHNlXCJdID0gNV0gPSBcIkZhbHNlXCI7XG4gIEpzb25TaXplMltKc29uU2l6ZTJbXCJRdW90ZVwiXSA9IDFdID0gXCJRdW90ZVwiO1xuICBKc29uU2l6ZTJbSnNvblNpemUyW1wiQ29sb25cIl0gPSAxXSA9IFwiQ29sb25cIjtcbiAgSnNvblNpemUyW0pzb25TaXplMltcIkRhdGVcIl0gPSAyNF0gPSBcIkRhdGVcIjtcbn0pKEpzb25TaXplID0gSnNvblNpemUgfHwgKEpzb25TaXplID0ge30pKTtcbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB0cnkge1xuICAgIGxldCBwcm90byA9IHZhbHVlO1xuICAgIHdoaWxlIChPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pICE9PSBudWxsKSB7XG4gICAgICBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90byk7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpID09PSBwcm90bztcbiAgfSBjYXRjaCAoXykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vLyBub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvanNvbi5tanNcbnZhciBvYmplY3QyID0gKHNjaGVtYSkgPT4gb2JqZWN0KHNjaGVtYSk7XG5mdW5jdGlvbiBoYXNPcHRpb25hbCh7IHBhdGgsIGJyYW5jaCB9KSB7XG4gIGNvbnN0IGZpZWxkID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuICByZXR1cm4gaGFzUHJvcGVydHkoYnJhbmNoW2JyYW5jaC5sZW5ndGggLSAyXSwgZmllbGQpO1xufVxuZnVuY3Rpb24gZXhhY3RPcHRpb25hbChzdHJ1Y3QpIHtcbiAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgIC4uLnN0cnVjdCxcbiAgICB0eXBlOiBgb3B0aW9uYWwgJHtzdHJ1Y3QudHlwZX1gLFxuICAgIHZhbGlkYXRvcjogKHZhbHVlLCBjb250ZXh0KSA9PiAhaGFzT3B0aW9uYWwoY29udGV4dCkgfHwgc3RydWN0LnZhbGlkYXRvcih2YWx1ZSwgY29udGV4dCksXG4gICAgcmVmaW5lcjogKHZhbHVlLCBjb250ZXh0KSA9PiAhaGFzT3B0aW9uYWwoY29udGV4dCkgfHwgc3RydWN0LnJlZmluZXIodmFsdWUsIGNvbnRleHQpXG4gIH0pO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVKc29uKGpzb24pIHtcbiAgaWYgKGpzb24gPT09IG51bGwgfHwgdHlwZW9mIGpzb24gPT09IFwiYm9vbGVhblwiIHx8IHR5cGVvZiBqc29uID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHR5cGVvZiBqc29uID09PSBcIm51bWJlclwiICYmIE51bWJlci5pc0Zpbml0ZShqc29uKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICh0eXBlb2YganNvbiA9PT0gXCJvYmplY3RcIikge1xuICAgIGxldCBldmVyeSA9IHRydWU7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoanNvbikpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwO2kgPCBqc29uLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghdmFsaWRhdGVKc29uKGpzb25baV0pKSB7XG4gICAgICAgICAgZXZlcnkgPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGV2ZXJ5O1xuICAgIH1cbiAgICBjb25zdCBlbnRyaWVzID0gT2JqZWN0LmVudHJpZXMoanNvbik7XG4gICAgZm9yIChsZXQgaSA9IDA7aSA8IGVudHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0eXBlb2YgZW50cmllc1tpXVswXSAhPT0gXCJzdHJpbmdcIiB8fCAhdmFsaWRhdGVKc29uKGVudHJpZXNbaV1bMV0pKSB7XG4gICAgICAgIGV2ZXJ5ID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXZlcnk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxudmFyIFVuc2FmZUpzb25TdHJ1Y3QgPSBkZWZpbmUoXCJKU09OXCIsIChqc29uKSA9PiB2YWxpZGF0ZUpzb24oanNvbikpO1xudmFyIEpzb25TdHJ1Y3QgPSBjb2VyY2UoVW5zYWZlSnNvblN0cnVjdCwgcmVmaW5lKGFueSgpLCBcIkpTT05cIiwgKHZhbHVlKSA9PiBpcyh2YWx1ZSwgVW5zYWZlSnNvblN0cnVjdCkpLCAodmFsdWUpID0+IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodmFsdWUsIChwcm9wS2V5LCBwcm9wVmFsdWUpID0+IHtcbiAgaWYgKHByb3BLZXkgPT09IFwiX19wcm90b19fXCIgfHwgcHJvcEtleSA9PT0gXCJjb25zdHJ1Y3RvclwiKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHJldHVybiBwcm9wVmFsdWU7XG59KSkpO1xuZnVuY3Rpb24gaXNWYWxpZEpzb24odmFsdWUpIHtcbiAgdHJ5IHtcbiAgICBnZXRTYWZlSnNvbih2YWx1ZSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0U2FmZUpzb24odmFsdWUpIHtcbiAgcmV0dXJuIGNyZWF0ZSh2YWx1ZSwgSnNvblN0cnVjdCk7XG59XG52YXIganNvbnJwYzIgPSBcIjIuMFwiO1xudmFyIEpzb25ScGNWZXJzaW9uU3RydWN0ID0gbGl0ZXJhbChqc29ucnBjMik7XG52YXIgSnNvblJwY0lkU3RydWN0ID0gbnVsbGFibGUodW5pb24oW251bWJlcigpLCBzdHJpbmcoKV0pKTtcbnZhciBKc29uUnBjRXJyb3JTdHJ1Y3QgPSBvYmplY3QyKHtcbiAgY29kZTogaW50ZWdlcigpLFxuICBtZXNzYWdlOiBzdHJpbmcoKSxcbiAgZGF0YTogZXhhY3RPcHRpb25hbChKc29uU3RydWN0KSxcbiAgc3RhY2s6IGV4YWN0T3B0aW9uYWwoc3RyaW5nKCkpXG59KTtcbnZhciBKc29uUnBjUGFyYW1zU3RydWN0ID0gdW5pb24oW3JlY29yZChzdHJpbmcoKSwgSnNvblN0cnVjdCksIGFycmF5KEpzb25TdHJ1Y3QpXSk7XG52YXIgSnNvblJwY1JlcXVlc3RTdHJ1Y3QgPSBvYmplY3QyKHtcbiAgaWQ6IEpzb25ScGNJZFN0cnVjdCxcbiAganNvbnJwYzogSnNvblJwY1ZlcnNpb25TdHJ1Y3QsXG4gIG1ldGhvZDogc3RyaW5nKCksXG4gIHBhcmFtczogZXhhY3RPcHRpb25hbChKc29uUnBjUGFyYW1zU3RydWN0KVxufSk7XG52YXIgSnNvblJwY05vdGlmaWNhdGlvblN0cnVjdCA9IG9iamVjdDIoe1xuICBqc29ucnBjOiBKc29uUnBjVmVyc2lvblN0cnVjdCxcbiAgbWV0aG9kOiBzdHJpbmcoKSxcbiAgcGFyYW1zOiBleGFjdE9wdGlvbmFsKEpzb25ScGNQYXJhbXNTdHJ1Y3QpXG59KTtcbnZhciBQZW5kaW5nSnNvblJwY1Jlc3BvbnNlU3RydWN0ID0gb2JqZWN0KHtcbiAgaWQ6IEpzb25ScGNJZFN0cnVjdCxcbiAganNvbnJwYzogSnNvblJwY1ZlcnNpb25TdHJ1Y3QsXG4gIHJlc3VsdDogb3B0aW9uYWwodW5rbm93bigpKSxcbiAgZXJyb3I6IG9wdGlvbmFsKEpzb25ScGNFcnJvclN0cnVjdClcbn0pO1xudmFyIEpzb25ScGNTdWNjZXNzU3RydWN0ID0gb2JqZWN0Mih7XG4gIGlkOiBKc29uUnBjSWRTdHJ1Y3QsXG4gIGpzb25ycGM6IEpzb25ScGNWZXJzaW9uU3RydWN0LFxuICByZXN1bHQ6IEpzb25TdHJ1Y3Rcbn0pO1xudmFyIEpzb25ScGNGYWlsdXJlU3RydWN0ID0gb2JqZWN0Mih7XG4gIGlkOiBKc29uUnBjSWRTdHJ1Y3QsXG4gIGpzb25ycGM6IEpzb25ScGNWZXJzaW9uU3RydWN0LFxuICBlcnJvcjogSnNvblJwY0Vycm9yU3RydWN0XG59KTtcbnZhciBKc29uUnBjUmVzcG9uc2VTdHJ1Y3QgPSB1bmlvbihbXG4gIEpzb25ScGNTdWNjZXNzU3RydWN0LFxuICBKc29uUnBjRmFpbHVyZVN0cnVjdFxuXSk7XG5mdW5jdGlvbiBpc0pzb25ScGNFcnJvcih2YWx1ZSkge1xuICByZXR1cm4gaXModmFsdWUsIEpzb25ScGNFcnJvclN0cnVjdCk7XG59XG5cbi8vIG5vZGVfbW9kdWxlcy9AbWV0YW1hc2svcnBjLWVycm9ycy9kaXN0L2NsYXNzZXMubWpzXG52YXIgaW1wb3J0X2Zhc3Rfc2FmZV9zdHJpbmdpZnkgPSBfX3RvRVNNKHJlcXVpcmVfZmFzdF9zYWZlX3N0cmluZ2lmeSgpLCAxKTtcblxuLy8gbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ycGMtZXJyb3JzL2Rpc3QvZXJyb3ItY29uc3RhbnRzLm1qc1xudmFyIGVycm9yQ29kZXMgPSB7XG4gIHJwYzoge1xuICAgIGludmFsaWRJbnB1dDogLTMyMDAwLFxuICAgIHJlc291cmNlTm90Rm91bmQ6IC0zMjAwMSxcbiAgICByZXNvdXJjZVVuYXZhaWxhYmxlOiAtMzIwMDIsXG4gICAgdHJhbnNhY3Rpb25SZWplY3RlZDogLTMyMDAzLFxuICAgIG1ldGhvZE5vdFN1cHBvcnRlZDogLTMyMDA0LFxuICAgIGxpbWl0RXhjZWVkZWQ6IC0zMjAwNSxcbiAgICBwYXJzZTogLTMyNzAwLFxuICAgIGludmFsaWRSZXF1ZXN0OiAtMzI2MDAsXG4gICAgbWV0aG9kTm90Rm91bmQ6IC0zMjYwMSxcbiAgICBpbnZhbGlkUGFyYW1zOiAtMzI2MDIsXG4gICAgaW50ZXJuYWw6IC0zMjYwM1xuICB9LFxuICBwcm92aWRlcjoge1xuICAgIHVzZXJSZWplY3RlZFJlcXVlc3Q6IDQwMDEsXG4gICAgdW5hdXRob3JpemVkOiA0MTAwLFxuICAgIHVuc3VwcG9ydGVkTWV0aG9kOiA0MjAwLFxuICAgIGRpc2Nvbm5lY3RlZDogNDkwMCxcbiAgICBjaGFpbkRpc2Nvbm5lY3RlZDogNDkwMVxuICB9XG59O1xudmFyIGVycm9yVmFsdWVzID0ge1xuICBcIi0zMjcwMFwiOiB7XG4gICAgc3RhbmRhcmQ6IFwiSlNPTiBSUEMgMi4wXCIsXG4gICAgbWVzc2FnZTogXCJJbnZhbGlkIEpTT04gd2FzIHJlY2VpdmVkIGJ5IHRoZSBzZXJ2ZXIuIEFuIGVycm9yIG9jY3VycmVkIG9uIHRoZSBzZXJ2ZXIgd2hpbGUgcGFyc2luZyB0aGUgSlNPTiB0ZXh0LlwiXG4gIH0sXG4gIFwiLTMyNjAwXCI6IHtcbiAgICBzdGFuZGFyZDogXCJKU09OIFJQQyAyLjBcIixcbiAgICBtZXNzYWdlOiBcIlRoZSBKU09OIHNlbnQgaXMgbm90IGEgdmFsaWQgUmVxdWVzdCBvYmplY3QuXCJcbiAgfSxcbiAgXCItMzI2MDFcIjoge1xuICAgIHN0YW5kYXJkOiBcIkpTT04gUlBDIDIuMFwiLFxuICAgIG1lc3NhZ2U6IFwiVGhlIG1ldGhvZCBkb2VzIG5vdCBleGlzdCAvIGlzIG5vdCBhdmFpbGFibGUuXCJcbiAgfSxcbiAgXCItMzI2MDJcIjoge1xuICAgIHN0YW5kYXJkOiBcIkpTT04gUlBDIDIuMFwiLFxuICAgIG1lc3NhZ2U6IFwiSW52YWxpZCBtZXRob2QgcGFyYW1ldGVyKHMpLlwiXG4gIH0sXG4gIFwiLTMyNjAzXCI6IHtcbiAgICBzdGFuZGFyZDogXCJKU09OIFJQQyAyLjBcIixcbiAgICBtZXNzYWdlOiBcIkludGVybmFsIEpTT04tUlBDIGVycm9yLlwiXG4gIH0sXG4gIFwiLTMyMDAwXCI6IHtcbiAgICBzdGFuZGFyZDogXCJFSVAtMTQ3NFwiLFxuICAgIG1lc3NhZ2U6IFwiSW52YWxpZCBpbnB1dC5cIlxuICB9LFxuICBcIi0zMjAwMVwiOiB7XG4gICAgc3RhbmRhcmQ6IFwiRUlQLTE0NzRcIixcbiAgICBtZXNzYWdlOiBcIlJlc291cmNlIG5vdCBmb3VuZC5cIlxuICB9LFxuICBcIi0zMjAwMlwiOiB7XG4gICAgc3RhbmRhcmQ6IFwiRUlQLTE0NzRcIixcbiAgICBtZXNzYWdlOiBcIlJlc291cmNlIHVuYXZhaWxhYmxlLlwiXG4gIH0sXG4gIFwiLTMyMDAzXCI6IHtcbiAgICBzdGFuZGFyZDogXCJFSVAtMTQ3NFwiLFxuICAgIG1lc3NhZ2U6IFwiVHJhbnNhY3Rpb24gcmVqZWN0ZWQuXCJcbiAgfSxcbiAgXCItMzIwMDRcIjoge1xuICAgIHN0YW5kYXJkOiBcIkVJUC0xNDc0XCIsXG4gICAgbWVzc2FnZTogXCJNZXRob2Qgbm90IHN1cHBvcnRlZC5cIlxuICB9LFxuICBcIi0zMjAwNVwiOiB7XG4gICAgc3RhbmRhcmQ6IFwiRUlQLTE0NzRcIixcbiAgICBtZXNzYWdlOiBcIlJlcXVlc3QgbGltaXQgZXhjZWVkZWQuXCJcbiAgfSxcbiAgXCI0MDAxXCI6IHtcbiAgICBzdGFuZGFyZDogXCJFSVAtMTE5M1wiLFxuICAgIG1lc3NhZ2U6IFwiVXNlciByZWplY3RlZCB0aGUgcmVxdWVzdC5cIlxuICB9LFxuICBcIjQxMDBcIjoge1xuICAgIHN0YW5kYXJkOiBcIkVJUC0xMTkzXCIsXG4gICAgbWVzc2FnZTogXCJUaGUgcmVxdWVzdGVkIGFjY291bnQgYW5kL29yIG1ldGhvZCBoYXMgbm90IGJlZW4gYXV0aG9yaXplZCBieSB0aGUgdXNlci5cIlxuICB9LFxuICBcIjQyMDBcIjoge1xuICAgIHN0YW5kYXJkOiBcIkVJUC0xMTkzXCIsXG4gICAgbWVzc2FnZTogXCJUaGUgcmVxdWVzdGVkIG1ldGhvZCBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgRXRoZXJldW0gcHJvdmlkZXIuXCJcbiAgfSxcbiAgXCI0OTAwXCI6IHtcbiAgICBzdGFuZGFyZDogXCJFSVAtMTE5M1wiLFxuICAgIG1lc3NhZ2U6IFwiVGhlIHByb3ZpZGVyIGlzIGRpc2Nvbm5lY3RlZCBmcm9tIGFsbCBjaGFpbnMuXCJcbiAgfSxcbiAgXCI0OTAxXCI6IHtcbiAgICBzdGFuZGFyZDogXCJFSVAtMTE5M1wiLFxuICAgIG1lc3NhZ2U6IFwiVGhlIHByb3ZpZGVyIGlzIGRpc2Nvbm5lY3RlZCBmcm9tIHRoZSBzcGVjaWZpZWQgY2hhaW4uXCJcbiAgfVxufTtcblxuLy8gbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ycGMtZXJyb3JzL2Rpc3QvdXRpbHMubWpzXG52YXIgRkFMTEJBQ0tfRVJST1JfQ09ERSA9IGVycm9yQ29kZXMucnBjLmludGVybmFsO1xudmFyIEZBTExCQUNLX01FU1NBR0UgPSBcIlVuc3BlY2lmaWVkIGVycm9yIG1lc3NhZ2UuIFRoaXMgaXMgYSBidWcsIHBsZWFzZSByZXBvcnQgaXQuXCI7XG52YXIgRkFMTEJBQ0tfRVJST1IgPSB7XG4gIGNvZGU6IEZBTExCQUNLX0VSUk9SX0NPREUsXG4gIG1lc3NhZ2U6IGdldE1lc3NhZ2VGcm9tQ29kZShGQUxMQkFDS19FUlJPUl9DT0RFKVxufTtcbnZhciBKU09OX1JQQ19TRVJWRVJfRVJST1JfTUVTU0FHRSA9IFwiVW5zcGVjaWZpZWQgc2VydmVyIGVycm9yLlwiO1xuZnVuY3Rpb24gZ2V0TWVzc2FnZUZyb21Db2RlKGNvZGUsIGZhbGxiYWNrTWVzc2FnZSA9IEZBTExCQUNLX01FU1NBR0UpIHtcbiAgaWYgKGlzVmFsaWRDb2RlKGNvZGUpKSB7XG4gICAgY29uc3QgY29kZVN0cmluZyA9IGNvZGUudG9TdHJpbmcoKTtcbiAgICBpZiAoaGFzUHJvcGVydHkoZXJyb3JWYWx1ZXMsIGNvZGVTdHJpbmcpKSB7XG4gICAgICByZXR1cm4gZXJyb3JWYWx1ZXNbY29kZVN0cmluZ10ubWVzc2FnZTtcbiAgICB9XG4gICAgaWYgKGlzSnNvblJwY1NlcnZlckVycm9yKGNvZGUpKSB7XG4gICAgICByZXR1cm4gSlNPTl9SUENfU0VSVkVSX0VSUk9SX01FU1NBR0U7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxsYmFja01lc3NhZ2U7XG59XG5mdW5jdGlvbiBpc1ZhbGlkQ29kZShjb2RlKSB7XG4gIHJldHVybiBOdW1iZXIuaXNJbnRlZ2VyKGNvZGUpO1xufVxuZnVuY3Rpb24gc2VyaWFsaXplRXJyb3IoZXJyb3IsIHsgZmFsbGJhY2tFcnJvciA9IEZBTExCQUNLX0VSUk9SLCBzaG91bGRJbmNsdWRlU3RhY2sgPSB0cnVlLCBzaG91bGRQcmVzZXJ2ZU1lc3NhZ2UgPSB0cnVlIH0gPSB7fSkge1xuICBpZiAoIWlzSnNvblJwY0Vycm9yKGZhbGxiYWNrRXJyb3IpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGZhbGxiYWNrIGVycm9yIHdpdGggaW50ZWdlciBudW1iZXIgY29kZSBhbmQgc3RyaW5nIG1lc3NhZ2UuXCIpO1xuICB9XG4gIGNvbnN0IHNlcmlhbGl6ZWQgPSBidWlsZEVycm9yKGVycm9yLCBmYWxsYmFja0Vycm9yLCBzaG91bGRQcmVzZXJ2ZU1lc3NhZ2UpO1xuICBpZiAoIXNob3VsZEluY2x1ZGVTdGFjaykge1xuICAgIGRlbGV0ZSBzZXJpYWxpemVkLnN0YWNrO1xuICB9XG4gIHJldHVybiBzZXJpYWxpemVkO1xufVxuZnVuY3Rpb24gYnVpbGRFcnJvcihlcnJvciwgZmFsbGJhY2tFcnJvciwgc2hvdWxkUHJlc2VydmVNZXNzYWdlKSB7XG4gIGlmIChlcnJvciAmJiB0eXBlb2YgZXJyb3IgPT09IFwib2JqZWN0XCIgJiYgXCJzZXJpYWxpemVcIiBpbiBlcnJvciAmJiB0eXBlb2YgZXJyb3Iuc2VyaWFsaXplID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4gZXJyb3Iuc2VyaWFsaXplKCk7XG4gIH1cbiAgaWYgKGlzSnNvblJwY0Vycm9yKGVycm9yKSkge1xuICAgIHJldHVybiBlcnJvcjtcbiAgfVxuICBjb25zdCBvcmlnaW5hbE1lc3NhZ2UgPSBnZXRPcmlnaW5hbE1lc3NhZ2UoZXJyb3IpO1xuICBjb25zdCBjYXVzZSA9IHNlcmlhbGl6ZUNhdXNlKGVycm9yKTtcbiAgY29uc3QgZmFsbGJhY2tXaXRoQ2F1c2UgPSB7XG4gICAgLi4uZmFsbGJhY2tFcnJvcixcbiAgICAuLi5zaG91bGRQcmVzZXJ2ZU1lc3NhZ2UgJiYgb3JpZ2luYWxNZXNzYWdlICYmIHsgbWVzc2FnZTogb3JpZ2luYWxNZXNzYWdlIH0sXG4gICAgZGF0YTogeyBjYXVzZSB9XG4gIH07XG4gIHJldHVybiBmYWxsYmFja1dpdGhDYXVzZTtcbn1cbmZ1bmN0aW9uIGdldE9yaWdpbmFsTWVzc2FnZShlcnJvcikge1xuICBpZiAoaXNPYmplY3QyKGVycm9yKSAmJiBoYXNQcm9wZXJ0eShlcnJvciwgXCJtZXNzYWdlXCIpICYmIHR5cGVvZiBlcnJvci5tZXNzYWdlID09PSBcInN0cmluZ1wiICYmIGVycm9yLm1lc3NhZ2UubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBlcnJvci5tZXNzYWdlO1xuICB9XG4gIHJldHVybjtcbn1cbmZ1bmN0aW9uIGlzSnNvblJwY1NlcnZlckVycm9yKGNvZGUpIHtcbiAgcmV0dXJuIGNvZGUgPj0gLTMyMDk5ICYmIGNvZGUgPD0gLTMyMDAwO1xufVxuZnVuY3Rpb24gc2VyaWFsaXplQ2F1c2UoZXJyb3IpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZXJyb3IpKSB7XG4gICAgcmV0dXJuIGVycm9yLm1hcCgoZW50cnkpID0+IHtcbiAgICAgIGlmIChpc1ZhbGlkSnNvbihlbnRyeSkpIHtcbiAgICAgICAgcmV0dXJuIGVudHJ5O1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdDIoZW50cnkpKSB7XG4gICAgICAgIHJldHVybiBzZXJpYWxpemVPYmplY3QoZW50cnkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QyKGVycm9yKSkge1xuICAgIHJldHVybiBzZXJpYWxpemVPYmplY3QoZXJyb3IpO1xuICB9XG4gIGlmIChpc1ZhbGlkSnNvbihlcnJvcikpIHtcbiAgICByZXR1cm4gZXJyb3I7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVPYmplY3Qob2JqZWN0Mykge1xuICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqZWN0MykucmVkdWNlKChhY2MsIGtleSkgPT4ge1xuICAgIGNvbnN0IHZhbHVlID0gb2JqZWN0M1trZXldO1xuICAgIGlmIChpc1ZhbGlkSnNvbih2YWx1ZSkpIHtcbiAgICAgIGFjY1trZXldID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcbn1cbmZ1bmN0aW9uIGRhdGFIYXNDYXVzZShkYXRhKSB7XG4gIHJldHVybiBpc09iamVjdDIoZGF0YSkgJiYgaGFzUHJvcGVydHkoZGF0YSwgXCJjYXVzZVwiKSAmJiBpc09iamVjdDIoZGF0YS5jYXVzZSk7XG59XG5cbi8vIG5vZGVfbW9kdWxlcy9AbWV0YW1hc2svcnBjLWVycm9ycy9kaXN0L2NsYXNzZXMubWpzXG5mdW5jdGlvbiAkaW1wb3J0RGVmYXVsdChtb2R1bGUpIHtcbiAgaWYgKG1vZHVsZT8uX19lc01vZHVsZSkge1xuICAgIHJldHVybiBtb2R1bGUuZGVmYXVsdDtcbiAgfVxuICByZXR1cm4gbW9kdWxlO1xufVxudmFyIHNhZmVTdHJpbmdpZnkgPSAkaW1wb3J0RGVmYXVsdChpbXBvcnRfZmFzdF9zYWZlX3N0cmluZ2lmeS5kZWZhdWx0KTtcblxuY2xhc3MgSnNvblJwY0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcihjb2RlLCBtZXNzYWdlLCBkYXRhKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGNvZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiY29kZVwiIG11c3QgYmUgYW4gaW50ZWdlci4nKTtcbiAgICB9XG4gICAgaWYgKCFtZXNzYWdlIHx8IHR5cGVvZiBtZXNzYWdlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wibWVzc2FnZVwiIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nLicpO1xuICAgIH1cbiAgICBpZiAoZGF0YUhhc0NhdXNlKGRhdGEpKSB7XG4gICAgICBzdXBlcihtZXNzYWdlLCB7IGNhdXNlOiBkYXRhLmNhdXNlIH0pO1xuICAgICAgaWYgKCFoYXNQcm9wZXJ0eSh0aGlzLCBcImNhdXNlXCIpKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgeyBjYXVzZTogZGF0YS5jYXVzZSB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgfVxuICAgIGlmIChkYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgfVxuICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gIH1cbiAgc2VyaWFsaXplKCkge1xuICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSB7XG4gICAgICBjb2RlOiB0aGlzLmNvZGUsXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2VcbiAgICB9O1xuICAgIGlmICh0aGlzLmRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgc2VyaWFsaXplZC5kYXRhID0gdGhpcy5kYXRhO1xuICAgICAgaWYgKGlzUGxhaW5PYmplY3QodGhpcy5kYXRhKSkge1xuICAgICAgICBzZXJpYWxpemVkLmRhdGEuY2F1c2UgPSBzZXJpYWxpemVDYXVzZSh0aGlzLmRhdGEuY2F1c2UpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5zdGFjaykge1xuICAgICAgc2VyaWFsaXplZC5zdGFjayA9IHRoaXMuc3RhY2s7XG4gICAgfVxuICAgIHJldHVybiBzZXJpYWxpemVkO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBzYWZlU3RyaW5naWZ5KHRoaXMuc2VyaWFsaXplKCksIHN0cmluZ2lmeVJlcGxhY2VyLCAyKTtcbiAgfVxufVxuXG5jbGFzcyBFdGhlcmV1bVByb3ZpZGVyRXJyb3IgZXh0ZW5kcyBKc29uUnBjRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcihjb2RlLCBtZXNzYWdlLCBkYXRhKSB7XG4gICAgaWYgKCFpc1ZhbGlkRXRoUHJvdmlkZXJDb2RlKGNvZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiY29kZVwiIG11c3QgYmUgYW4gaW50ZWdlciBzdWNoIHRoYXQ6IDEwMDAgPD0gY29kZSA8PSA0OTk5Jyk7XG4gICAgfVxuICAgIHN1cGVyKGNvZGUsIG1lc3NhZ2UsIGRhdGEpO1xuICB9XG59XG5mdW5jdGlvbiBpc1ZhbGlkRXRoUHJvdmlkZXJDb2RlKGNvZGUpIHtcbiAgcmV0dXJuIE51bWJlci5pc0ludGVnZXIoY29kZSkgJiYgY29kZSA+PSAxMDAwICYmIGNvZGUgPD0gNDk5OTtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeVJlcGxhY2VyKF8sIHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PT0gXCJbQ2lyY3VsYXJdXCIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuLy8gbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ycGMtZXJyb3JzL2Rpc3QvZXJyb3JzLm1qc1xudmFyIHJwY0Vycm9ycyA9IHtcbiAgcGFyc2U6IChhcmcpID0+IGdldEpzb25ScGNFcnJvcihlcnJvckNvZGVzLnJwYy5wYXJzZSwgYXJnKSxcbiAgaW52YWxpZFJlcXVlc3Q6IChhcmcpID0+IGdldEpzb25ScGNFcnJvcihlcnJvckNvZGVzLnJwYy5pbnZhbGlkUmVxdWVzdCwgYXJnKSxcbiAgaW52YWxpZFBhcmFtczogKGFyZykgPT4gZ2V0SnNvblJwY0Vycm9yKGVycm9yQ29kZXMucnBjLmludmFsaWRQYXJhbXMsIGFyZyksXG4gIG1ldGhvZE5vdEZvdW5kOiAoYXJnKSA9PiBnZXRKc29uUnBjRXJyb3IoZXJyb3JDb2Rlcy5ycGMubWV0aG9kTm90Rm91bmQsIGFyZyksXG4gIGludGVybmFsOiAoYXJnKSA9PiBnZXRKc29uUnBjRXJyb3IoZXJyb3JDb2Rlcy5ycGMuaW50ZXJuYWwsIGFyZyksXG4gIHNlcnZlcjogKG9wdHMpID0+IHtcbiAgICBpZiAoIW9wdHMgfHwgdHlwZW9mIG9wdHMgIT09IFwib2JqZWN0XCIgfHwgQXJyYXkuaXNBcnJheShvcHRzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXRoZXJldW0gUlBDIFNlcnZlciBlcnJvcnMgbXVzdCBwcm92aWRlIHNpbmdsZSBvYmplY3QgYXJndW1lbnQuXCIpO1xuICAgIH1cbiAgICBjb25zdCB7IGNvZGUgfSA9IG9wdHM7XG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGNvZGUpIHx8IGNvZGUgPiAtMzIwMDUgfHwgY29kZSA8IC0zMjA5OSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcImNvZGVcIiBtdXN0IGJlIGFuIGludGVnZXIgc3VjaCB0aGF0OiAtMzIwOTkgPD0gY29kZSA8PSAtMzIwMDUnKTtcbiAgICB9XG4gICAgcmV0dXJuIGdldEpzb25ScGNFcnJvcihjb2RlLCBvcHRzKTtcbiAgfSxcbiAgaW52YWxpZElucHV0OiAoYXJnKSA9PiBnZXRKc29uUnBjRXJyb3IoZXJyb3JDb2Rlcy5ycGMuaW52YWxpZElucHV0LCBhcmcpLFxuICByZXNvdXJjZU5vdEZvdW5kOiAoYXJnKSA9PiBnZXRKc29uUnBjRXJyb3IoZXJyb3JDb2Rlcy5ycGMucmVzb3VyY2VOb3RGb3VuZCwgYXJnKSxcbiAgcmVzb3VyY2VVbmF2YWlsYWJsZTogKGFyZykgPT4gZ2V0SnNvblJwY0Vycm9yKGVycm9yQ29kZXMucnBjLnJlc291cmNlVW5hdmFpbGFibGUsIGFyZyksXG4gIHRyYW5zYWN0aW9uUmVqZWN0ZWQ6IChhcmcpID0+IGdldEpzb25ScGNFcnJvcihlcnJvckNvZGVzLnJwYy50cmFuc2FjdGlvblJlamVjdGVkLCBhcmcpLFxuICBtZXRob2ROb3RTdXBwb3J0ZWQ6IChhcmcpID0+IGdldEpzb25ScGNFcnJvcihlcnJvckNvZGVzLnJwYy5tZXRob2ROb3RTdXBwb3J0ZWQsIGFyZyksXG4gIGxpbWl0RXhjZWVkZWQ6IChhcmcpID0+IGdldEpzb25ScGNFcnJvcihlcnJvckNvZGVzLnJwYy5saW1pdEV4Y2VlZGVkLCBhcmcpXG59O1xudmFyIHByb3ZpZGVyRXJyb3JzID0ge1xuICB1c2VyUmVqZWN0ZWRSZXF1ZXN0OiAoYXJnKSA9PiB7XG4gICAgcmV0dXJuIGdldEV0aFByb3ZpZGVyRXJyb3IoZXJyb3JDb2Rlcy5wcm92aWRlci51c2VyUmVqZWN0ZWRSZXF1ZXN0LCBhcmcpO1xuICB9LFxuICB1bmF1dGhvcml6ZWQ6IChhcmcpID0+IHtcbiAgICByZXR1cm4gZ2V0RXRoUHJvdmlkZXJFcnJvcihlcnJvckNvZGVzLnByb3ZpZGVyLnVuYXV0aG9yaXplZCwgYXJnKTtcbiAgfSxcbiAgdW5zdXBwb3J0ZWRNZXRob2Q6IChhcmcpID0+IHtcbiAgICByZXR1cm4gZ2V0RXRoUHJvdmlkZXJFcnJvcihlcnJvckNvZGVzLnByb3ZpZGVyLnVuc3VwcG9ydGVkTWV0aG9kLCBhcmcpO1xuICB9LFxuICBkaXNjb25uZWN0ZWQ6IChhcmcpID0+IHtcbiAgICByZXR1cm4gZ2V0RXRoUHJvdmlkZXJFcnJvcihlcnJvckNvZGVzLnByb3ZpZGVyLmRpc2Nvbm5lY3RlZCwgYXJnKTtcbiAgfSxcbiAgY2hhaW5EaXNjb25uZWN0ZWQ6IChhcmcpID0+IHtcbiAgICByZXR1cm4gZ2V0RXRoUHJvdmlkZXJFcnJvcihlcnJvckNvZGVzLnByb3ZpZGVyLmNoYWluRGlzY29ubmVjdGVkLCBhcmcpO1xuICB9LFxuICBjdXN0b206IChvcHRzKSA9PiB7XG4gICAgaWYgKCFvcHRzIHx8IHR5cGVvZiBvcHRzICE9PSBcIm9iamVjdFwiIHx8IEFycmF5LmlzQXJyYXkob3B0cykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkV0aGVyZXVtIFByb3ZpZGVyIGN1c3RvbSBlcnJvcnMgbXVzdCBwcm92aWRlIHNpbmdsZSBvYmplY3QgYXJndW1lbnQuXCIpO1xuICAgIH1cbiAgICBjb25zdCB7IGNvZGUsIG1lc3NhZ2UsIGRhdGEgfSA9IG9wdHM7XG4gICAgaWYgKCFtZXNzYWdlIHx8IHR5cGVvZiBtZXNzYWdlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wibWVzc2FnZVwiIG11c3QgYmUgYSBub25lbXB0eSBzdHJpbmcnKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBFdGhlcmV1bVByb3ZpZGVyRXJyb3IoY29kZSwgbWVzc2FnZSwgZGF0YSk7XG4gIH1cbn07XG5mdW5jdGlvbiBnZXRKc29uUnBjRXJyb3IoY29kZSwgYXJnKSB7XG4gIGNvbnN0IFttZXNzYWdlLCBkYXRhXSA9IHBhcnNlT3B0cyhhcmcpO1xuICByZXR1cm4gbmV3IEpzb25ScGNFcnJvcihjb2RlLCBtZXNzYWdlID8/IGdldE1lc3NhZ2VGcm9tQ29kZShjb2RlKSwgZGF0YSk7XG59XG5mdW5jdGlvbiBnZXRFdGhQcm92aWRlckVycm9yKGNvZGUsIGFyZykge1xuICBjb25zdCBbbWVzc2FnZSwgZGF0YV0gPSBwYXJzZU9wdHMoYXJnKTtcbiAgcmV0dXJuIG5ldyBFdGhlcmV1bVByb3ZpZGVyRXJyb3IoY29kZSwgbWVzc2FnZSA/PyBnZXRNZXNzYWdlRnJvbUNvZGUoY29kZSksIGRhdGEpO1xufVxuZnVuY3Rpb24gcGFyc2VPcHRzKGFyZykge1xuICBpZiAoYXJnKSB7XG4gICAgaWYgKHR5cGVvZiBhcmcgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBbYXJnXTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmcgPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkoYXJnKSkge1xuICAgICAgY29uc3QgeyBtZXNzYWdlLCBkYXRhIH0gPSBhcmc7XG4gICAgICBpZiAobWVzc2FnZSAmJiB0eXBlb2YgbWVzc2FnZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHNwZWNpZnkgc3RyaW5nIG1lc3NhZ2UuXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFttZXNzYWdlID8/IHVuZGVmaW5lZCwgZGF0YV07XG4gICAgfVxuICB9XG4gIHJldHVybiBbXTtcbn1cbi8vIG5vZGVfbW9kdWxlcy9ldmVudGVtaXR0ZXIzL2luZGV4Lm1qc1xudmFyIGltcG9ydF9fID0gX190b0VTTShyZXF1aXJlX2V2ZW50ZW1pdHRlcjMoKSwgMSk7XG5cbi8vIHNyYy90eXBlcy50c1xudmFyIEdlbWluaVNka0V2ZW50O1xuKChHZW1pbmlTZGtFdmVudDIpID0+IHtcbiAgR2VtaW5pU2RrRXZlbnQyW1wiUE9QVVBfTE9BREVEXCJdID0gXCJQT1BVUF9MT0FERURcIjtcbiAgR2VtaW5pU2RrRXZlbnQyW1wiUE9QVVBfVU5MT0FERURcIl0gPSBcIlBPUFVQX1VOTE9BREVEXCI7XG4gIEdlbWluaVNka0V2ZW50MltcIlBPUFVQX0FQUF9DT05URVhUXCJdID0gXCJQT1BVUF9BUFBfQ09OVEVYVFwiO1xuICBHZW1pbmlTZGtFdmVudDJbXCJTREtfQ09OTkVDVFwiXSA9IFwiU0RLX0NPTk5FQ1RcIjtcbiAgR2VtaW5pU2RrRXZlbnQyW1wiU0RLX0RJU0NPTk5FQ1RcIl0gPSBcIlNES19ESVNDT05ORUNUXCI7XG4gIEdlbWluaVNka0V2ZW50MltcIlNES19TRU5EX1RSQU5TQUNUSU9OXCJdID0gXCJTREtfU0VORF9UUkFOU0FDVElPTlwiO1xuICBHZW1pbmlTZGtFdmVudDJbXCJTREtfU0lHTl9EQVRBXCJdID0gXCJTREtfU0lHTl9EQVRBXCI7XG4gIEdlbWluaVNka0V2ZW50MltcIlNES19TSUdOX1RZUEVEX0RBVEFcIl0gPSBcIlNES19TSUdOX1RZUEVEX0RBVEFcIjtcbiAgR2VtaW5pU2RrRXZlbnQyW1wiU0RLX1NXSVRDSF9DSEFJTlwiXSA9IFwiU0RLX1NXSVRDSF9DSEFJTlwiO1xuICBHZW1pbmlTZGtFdmVudDJbXCJTREtfT1BFTl9TRVRUSU5HU1wiXSA9IFwiU0RLX09QRU5fU0VUVElOR1NcIjtcbn0pKEdlbWluaVNka0V2ZW50IHx8PSB7fSk7XG5jbGFzcyBQcm92aWRlckV2ZW50RW1pdHRlciBleHRlbmRzIGltcG9ydF9fLmRlZmF1bHQge1xufVxuXG4vLyBzcmMvdXRpbHMvYmFzZTY0LnRzXG5mdW5jdGlvbiBlbmNvZGVCYXNlNjQoYXJyYXkyKSB7XG4gIGxldCBiYXNlNjQ7XG4gIGlmICh0eXBlb2YgQnVmZmVyICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgYmFzZTY0ID0gQnVmZmVyLmZyb20oYXJyYXkyKS50b1N0cmluZyhcImJhc2U2NFwiKTtcbiAgfSBlbHNlIHtcbiAgICBiYXNlNjQgPSBidG9hKEFycmF5LmZyb20oYXJyYXkyKS5tYXAoKGIpID0+IFN0cmluZy5mcm9tQ2hhckNvZGUoYikpLmpvaW4oXCJcIikpO1xuICB9XG4gIHJldHVybiBiYXNlNjQucmVwbGFjZSgvXFwrL2csIFwiLVwiKS5yZXBsYWNlKC9cXC8vZywgXCJfXCIpLnJlcGxhY2UoLz0rJC8sIFwiXCIpO1xufVxuZnVuY3Rpb24gZGVjb2RlQmFzZTY0KGJhc2U2NHVybCkge1xuICBsZXQgYmFzZTY0ID0gYmFzZTY0dXJsLnJlcGxhY2UoLy0vZywgXCIrXCIpLnJlcGxhY2UoL18vZywgXCIvXCIpO1xuICB3aGlsZSAoYmFzZTY0Lmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBiYXNlNjQgKz0gXCI9XCI7XG4gIH1cbiAgaWYgKHR5cGVvZiBCdWZmZXIgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoQnVmZmVyLmZyb20oYmFzZTY0LCBcImJhc2U2NFwiKSk7XG4gIH1cbiAgY29uc3QgYmluYXJ5U3RyaW5nID0gYXRvYihiYXNlNjQpO1xuICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGJpbmFyeVN0cmluZy5sZW5ndGgpO1xuICBmb3IgKGxldCBpID0gMDtpIDwgYmluYXJ5U3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgYnl0ZXNbaV0gPSBiaW5hcnlTdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgfVxuICByZXR1cm4gYnl0ZXM7XG59XG5mdW5jdGlvbiBidWZmZXJUb0Jhc2U2NFVSTFN0cmluZyhidWZmZXIpIHtcbiAgY29uc3QgYnl0ZXMgPSBidWZmZXIgaW5zdGFuY2VvZiBVaW50OEFycmF5ID8gYnVmZmVyIDogbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgcmV0dXJuIGVuY29kZUJhc2U2NChieXRlcyk7XG59XG5mdW5jdGlvbiB1dGY4U3RyaW5nVG9CdWZmZXIodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBUZXh0RW5jb2RlciAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUodmFsdWUpO1xuICB9XG4gIGlmICh0eXBlb2YgQnVmZmVyICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KEJ1ZmZlci5mcm9tKHZhbHVlLCBcInV0ZjhcIikpO1xuICB9XG4gIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkodmFsdWUubGVuZ3RoKTtcbiAgZm9yIChsZXQgaSA9IDA7aSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgYnl0ZXNbaV0gPSB2YWx1ZS5jaGFyQ29kZUF0KGkpO1xuICB9XG4gIHJldHVybiBieXRlcztcbn1cbmZ1bmN0aW9uIGJhc2U2NFRvSGV4KGJhc2U2NCkge1xuICBjb25zdCBieXRlcyA9IGRlY29kZUJhc2U2NChiYXNlNjQpO1xuICByZXR1cm4gQXJyYXkuZnJvbShieXRlcykubWFwKChiKSA9PiBiLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCBcIjBcIikpLmpvaW4oXCJcIik7XG59XG4vLyBub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL2VuY29kaW5nL3RvUmxwLmpzXG5pbml0X2Jhc2UoKTtcbmluaXRfY3Vyc29yMigpO1xuaW5pdF90b0J5dGVzKCk7XG5pbml0X3RvSGV4KCk7XG5mdW5jdGlvbiB0b1JscChieXRlcywgdG8gPSBcImhleFwiKSB7XG4gIGNvbnN0IGVuY29kYWJsZSA9IGdldEVuY29kYWJsZShieXRlcyk7XG4gIGNvbnN0IGN1cnNvciA9IGNyZWF0ZUN1cnNvcihuZXcgVWludDhBcnJheShlbmNvZGFibGUubGVuZ3RoKSk7XG4gIGVuY29kYWJsZS5lbmNvZGUoY3Vyc29yKTtcbiAgaWYgKHRvID09PSBcImhleFwiKVxuICAgIHJldHVybiBieXRlc1RvSGV4KGN1cnNvci5ieXRlcyk7XG4gIHJldHVybiBjdXJzb3IuYnl0ZXM7XG59XG5mdW5jdGlvbiBnZXRFbmNvZGFibGUoYnl0ZXMpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYnl0ZXMpKVxuICAgIHJldHVybiBnZXRFbmNvZGFibGVMaXN0KGJ5dGVzLm1hcCgoeCkgPT4gZ2V0RW5jb2RhYmxlKHgpKSk7XG4gIHJldHVybiBnZXRFbmNvZGFibGVCeXRlcyhieXRlcyk7XG59XG5mdW5jdGlvbiBnZXRFbmNvZGFibGVMaXN0KGxpc3QpIHtcbiAgY29uc3QgYm9keUxlbmd0aCA9IGxpc3QucmVkdWNlKChhY2MsIHgpID0+IGFjYyArIHgubGVuZ3RoLCAwKTtcbiAgY29uc3Qgc2l6ZU9mQm9keUxlbmd0aCA9IGdldFNpemVPZkxlbmd0aChib2R5TGVuZ3RoKTtcbiAgY29uc3QgbGVuZ3RoID0gKCgpID0+IHtcbiAgICBpZiAoYm9keUxlbmd0aCA8PSA1NSlcbiAgICAgIHJldHVybiAxICsgYm9keUxlbmd0aDtcbiAgICByZXR1cm4gMSArIHNpemVPZkJvZHlMZW5ndGggKyBib2R5TGVuZ3RoO1xuICB9KSgpO1xuICByZXR1cm4ge1xuICAgIGxlbmd0aCxcbiAgICBlbmNvZGUoY3Vyc29yKSB7XG4gICAgICBpZiAoYm9keUxlbmd0aCA8PSA1NSkge1xuICAgICAgICBjdXJzb3IucHVzaEJ5dGUoMTkyICsgYm9keUxlbmd0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJzb3IucHVzaEJ5dGUoMTkyICsgNTUgKyBzaXplT2ZCb2R5TGVuZ3RoKTtcbiAgICAgICAgaWYgKHNpemVPZkJvZHlMZW5ndGggPT09IDEpXG4gICAgICAgICAgY3Vyc29yLnB1c2hVaW50OChib2R5TGVuZ3RoKTtcbiAgICAgICAgZWxzZSBpZiAoc2l6ZU9mQm9keUxlbmd0aCA9PT0gMilcbiAgICAgICAgICBjdXJzb3IucHVzaFVpbnQxNihib2R5TGVuZ3RoKTtcbiAgICAgICAgZWxzZSBpZiAoc2l6ZU9mQm9keUxlbmd0aCA9PT0gMylcbiAgICAgICAgICBjdXJzb3IucHVzaFVpbnQyNChib2R5TGVuZ3RoKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGN1cnNvci5wdXNoVWludDMyKGJvZHlMZW5ndGgpO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCB7IGVuY29kZSB9IG9mIGxpc3QpIHtcbiAgICAgICAgZW5jb2RlKGN1cnNvcik7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0RW5jb2RhYmxlQnl0ZXMoYnl0ZXNPckhleCkge1xuICBjb25zdCBieXRlcyA9IHR5cGVvZiBieXRlc09ySGV4ID09PSBcInN0cmluZ1wiID8gaGV4VG9CeXRlcyhieXRlc09ySGV4KSA6IGJ5dGVzT3JIZXg7XG4gIGNvbnN0IHNpemVPZkJ5dGVzTGVuZ3RoID0gZ2V0U2l6ZU9mTGVuZ3RoKGJ5dGVzLmxlbmd0aCk7XG4gIGNvbnN0IGxlbmd0aCA9ICgoKSA9PiB7XG4gICAgaWYgKGJ5dGVzLmxlbmd0aCA9PT0gMSAmJiBieXRlc1swXSA8IDEyOClcbiAgICAgIHJldHVybiAxO1xuICAgIGlmIChieXRlcy5sZW5ndGggPD0gNTUpXG4gICAgICByZXR1cm4gMSArIGJ5dGVzLmxlbmd0aDtcbiAgICByZXR1cm4gMSArIHNpemVPZkJ5dGVzTGVuZ3RoICsgYnl0ZXMubGVuZ3RoO1xuICB9KSgpO1xuICByZXR1cm4ge1xuICAgIGxlbmd0aCxcbiAgICBlbmNvZGUoY3Vyc29yKSB7XG4gICAgICBpZiAoYnl0ZXMubGVuZ3RoID09PSAxICYmIGJ5dGVzWzBdIDwgMTI4KSB7XG4gICAgICAgIGN1cnNvci5wdXNoQnl0ZXMoYnl0ZXMpO1xuICAgICAgfSBlbHNlIGlmIChieXRlcy5sZW5ndGggPD0gNTUpIHtcbiAgICAgICAgY3Vyc29yLnB1c2hCeXRlKDEyOCArIGJ5dGVzLmxlbmd0aCk7XG4gICAgICAgIGN1cnNvci5wdXNoQnl0ZXMoYnl0ZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3Vyc29yLnB1c2hCeXRlKDEyOCArIDU1ICsgc2l6ZU9mQnl0ZXNMZW5ndGgpO1xuICAgICAgICBpZiAoc2l6ZU9mQnl0ZXNMZW5ndGggPT09IDEpXG4gICAgICAgICAgY3Vyc29yLnB1c2hVaW50OChieXRlcy5sZW5ndGgpO1xuICAgICAgICBlbHNlIGlmIChzaXplT2ZCeXRlc0xlbmd0aCA9PT0gMilcbiAgICAgICAgICBjdXJzb3IucHVzaFVpbnQxNihieXRlcy5sZW5ndGgpO1xuICAgICAgICBlbHNlIGlmIChzaXplT2ZCeXRlc0xlbmd0aCA9PT0gMylcbiAgICAgICAgICBjdXJzb3IucHVzaFVpbnQyNChieXRlcy5sZW5ndGgpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgY3Vyc29yLnB1c2hVaW50MzIoYnl0ZXMubGVuZ3RoKTtcbiAgICAgICAgY3Vyc29yLnB1c2hCeXRlcyhieXRlcyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0U2l6ZU9mTGVuZ3RoKGxlbmd0aCkge1xuICBpZiAobGVuZ3RoIDwgMiAqKiA4KVxuICAgIHJldHVybiAxO1xuICBpZiAobGVuZ3RoIDwgMiAqKiAxNilcbiAgICByZXR1cm4gMjtcbiAgaWYgKGxlbmd0aCA8IDIgKiogMjQpXG4gICAgcmV0dXJuIDM7XG4gIGlmIChsZW5ndGggPCAyICoqIDMyKVxuICAgIHJldHVybiA0O1xuICB0aHJvdyBuZXcgQmFzZUVycm9yKFwiTGVuZ3RoIGlzIHRvbyBsYXJnZS5cIik7XG59XG4vLyBub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL2Zvcm1hdHRlcnMvdHJhbnNhY3Rpb24uanNcbmluaXRfZnJvbUhleCgpO1xudmFyIHRyYW5zYWN0aW9uVHlwZSA9IHtcbiAgXCIweDBcIjogXCJsZWdhY3lcIixcbiAgXCIweDFcIjogXCJlaXAyOTMwXCIsXG4gIFwiMHgyXCI6IFwiZWlwMTU1OVwiLFxuICBcIjB4M1wiOiBcImVpcDQ4NDRcIixcbiAgXCIweDRcIjogXCJlaXA3NzAyXCJcbn07XG5mdW5jdGlvbiBmb3JtYXRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbikge1xuICBjb25zdCB0cmFuc2FjdGlvbl8gPSB7XG4gICAgLi4udHJhbnNhY3Rpb24sXG4gICAgYmxvY2tIYXNoOiB0cmFuc2FjdGlvbi5ibG9ja0hhc2ggPyB0cmFuc2FjdGlvbi5ibG9ja0hhc2ggOiBudWxsLFxuICAgIGJsb2NrTnVtYmVyOiB0cmFuc2FjdGlvbi5ibG9ja051bWJlciA/IEJpZ0ludCh0cmFuc2FjdGlvbi5ibG9ja051bWJlcikgOiBudWxsLFxuICAgIGNoYWluSWQ6IHRyYW5zYWN0aW9uLmNoYWluSWQgPyBoZXhUb051bWJlcih0cmFuc2FjdGlvbi5jaGFpbklkKSA6IHVuZGVmaW5lZCxcbiAgICBnYXM6IHRyYW5zYWN0aW9uLmdhcyA/IEJpZ0ludCh0cmFuc2FjdGlvbi5nYXMpIDogdW5kZWZpbmVkLFxuICAgIGdhc1ByaWNlOiB0cmFuc2FjdGlvbi5nYXNQcmljZSA/IEJpZ0ludCh0cmFuc2FjdGlvbi5nYXNQcmljZSkgOiB1bmRlZmluZWQsXG4gICAgbWF4RmVlUGVyQmxvYkdhczogdHJhbnNhY3Rpb24ubWF4RmVlUGVyQmxvYkdhcyA/IEJpZ0ludCh0cmFuc2FjdGlvbi5tYXhGZWVQZXJCbG9iR2FzKSA6IHVuZGVmaW5lZCxcbiAgICBtYXhGZWVQZXJHYXM6IHRyYW5zYWN0aW9uLm1heEZlZVBlckdhcyA/IEJpZ0ludCh0cmFuc2FjdGlvbi5tYXhGZWVQZXJHYXMpIDogdW5kZWZpbmVkLFxuICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiB0cmFuc2FjdGlvbi5tYXhQcmlvcml0eUZlZVBlckdhcyA/IEJpZ0ludCh0cmFuc2FjdGlvbi5tYXhQcmlvcml0eUZlZVBlckdhcykgOiB1bmRlZmluZWQsXG4gICAgbm9uY2U6IHRyYW5zYWN0aW9uLm5vbmNlID8gaGV4VG9OdW1iZXIodHJhbnNhY3Rpb24ubm9uY2UpIDogdW5kZWZpbmVkLFxuICAgIHRvOiB0cmFuc2FjdGlvbi50byA/IHRyYW5zYWN0aW9uLnRvIDogbnVsbCxcbiAgICB0cmFuc2FjdGlvbkluZGV4OiB0cmFuc2FjdGlvbi50cmFuc2FjdGlvbkluZGV4ID8gTnVtYmVyKHRyYW5zYWN0aW9uLnRyYW5zYWN0aW9uSW5kZXgpIDogbnVsbCxcbiAgICB0eXBlOiB0cmFuc2FjdGlvbi50eXBlID8gdHJhbnNhY3Rpb25UeXBlW3RyYW5zYWN0aW9uLnR5cGVdIDogdW5kZWZpbmVkLFxuICAgIHR5cGVIZXg6IHRyYW5zYWN0aW9uLnR5cGUgPyB0cmFuc2FjdGlvbi50eXBlIDogdW5kZWZpbmVkLFxuICAgIHZhbHVlOiB0cmFuc2FjdGlvbi52YWx1ZSA/IEJpZ0ludCh0cmFuc2FjdGlvbi52YWx1ZSkgOiB1bmRlZmluZWQsXG4gICAgdjogdHJhbnNhY3Rpb24udiA/IEJpZ0ludCh0cmFuc2FjdGlvbi52KSA6IHVuZGVmaW5lZFxuICB9O1xuICBpZiAodHJhbnNhY3Rpb24uYXV0aG9yaXphdGlvbkxpc3QpXG4gICAgdHJhbnNhY3Rpb25fLmF1dGhvcml6YXRpb25MaXN0ID0gZm9ybWF0QXV0aG9yaXphdGlvbkxpc3QodHJhbnNhY3Rpb24uYXV0aG9yaXphdGlvbkxpc3QpO1xuICB0cmFuc2FjdGlvbl8ueVBhcml0eSA9ICgoKSA9PiB7XG4gICAgaWYgKHRyYW5zYWN0aW9uLnlQYXJpdHkpXG4gICAgICByZXR1cm4gTnVtYmVyKHRyYW5zYWN0aW9uLnlQYXJpdHkpO1xuICAgIGlmICh0eXBlb2YgdHJhbnNhY3Rpb25fLnYgPT09IFwiYmlnaW50XCIpIHtcbiAgICAgIGlmICh0cmFuc2FjdGlvbl8udiA9PT0gMG4gfHwgdHJhbnNhY3Rpb25fLnYgPT09IDI3bilcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICBpZiAodHJhbnNhY3Rpb25fLnYgPT09IDFuIHx8IHRyYW5zYWN0aW9uXy52ID09PSAyOG4pXG4gICAgICAgIHJldHVybiAxO1xuICAgICAgaWYgKHRyYW5zYWN0aW9uXy52ID49IDM1bilcbiAgICAgICAgcmV0dXJuIHRyYW5zYWN0aW9uXy52ICUgMm4gPT09IDBuID8gMSA6IDA7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfSkoKTtcbiAgaWYgKHRyYW5zYWN0aW9uXy50eXBlID09PSBcImxlZ2FjeVwiKSB7XG4gICAgZGVsZXRlIHRyYW5zYWN0aW9uXy5hY2Nlc3NMaXN0O1xuICAgIGRlbGV0ZSB0cmFuc2FjdGlvbl8ubWF4RmVlUGVyQmxvYkdhcztcbiAgICBkZWxldGUgdHJhbnNhY3Rpb25fLm1heEZlZVBlckdhcztcbiAgICBkZWxldGUgdHJhbnNhY3Rpb25fLm1heFByaW9yaXR5RmVlUGVyR2FzO1xuICAgIGRlbGV0ZSB0cmFuc2FjdGlvbl8ueVBhcml0eTtcbiAgfVxuICBpZiAodHJhbnNhY3Rpb25fLnR5cGUgPT09IFwiZWlwMjkzMFwiKSB7XG4gICAgZGVsZXRlIHRyYW5zYWN0aW9uXy5tYXhGZWVQZXJCbG9iR2FzO1xuICAgIGRlbGV0ZSB0cmFuc2FjdGlvbl8ubWF4RmVlUGVyR2FzO1xuICAgIGRlbGV0ZSB0cmFuc2FjdGlvbl8ubWF4UHJpb3JpdHlGZWVQZXJHYXM7XG4gIH1cbiAgaWYgKHRyYW5zYWN0aW9uXy50eXBlID09PSBcImVpcDE1NTlcIikge1xuICAgIGRlbGV0ZSB0cmFuc2FjdGlvbl8ubWF4RmVlUGVyQmxvYkdhcztcbiAgfVxuICByZXR1cm4gdHJhbnNhY3Rpb25fO1xufVxudmFyIGRlZmluZVRyYW5zYWN0aW9uID0gLyogQF9fUFVSRV9fICovIGRlZmluZUZvcm1hdHRlcihcInRyYW5zYWN0aW9uXCIsIGZvcm1hdFRyYW5zYWN0aW9uKTtcbmZ1bmN0aW9uIGZvcm1hdEF1dGhvcml6YXRpb25MaXN0KGF1dGhvcml6YXRpb25MaXN0KSB7XG4gIHJldHVybiBhdXRob3JpemF0aW9uTGlzdC5tYXAoKGF1dGhvcml6YXRpb24pID0+ICh7XG4gICAgYWRkcmVzczogYXV0aG9yaXphdGlvbi5hZGRyZXNzLFxuICAgIGNoYWluSWQ6IE51bWJlcihhdXRob3JpemF0aW9uLmNoYWluSWQpLFxuICAgIG5vbmNlOiBOdW1iZXIoYXV0aG9yaXphdGlvbi5ub25jZSksXG4gICAgcjogYXV0aG9yaXphdGlvbi5yLFxuICAgIHM6IGF1dGhvcml6YXRpb24ucyxcbiAgICB5UGFyaXR5OiBOdW1iZXIoYXV0aG9yaXphdGlvbi55UGFyaXR5KVxuICB9KSk7XG59XG5cbi8vIG5vZGVfbW9kdWxlcy92aWVtL19lc20vdXRpbHMvZm9ybWF0dGVycy9ibG9jay5qc1xuZnVuY3Rpb24gZm9ybWF0QmxvY2soYmxvY2spIHtcbiAgY29uc3QgdHJhbnNhY3Rpb25zID0gKGJsb2NrLnRyYW5zYWN0aW9ucyA/PyBbXSkubWFwKCh0cmFuc2FjdGlvbikgPT4ge1xuICAgIGlmICh0eXBlb2YgdHJhbnNhY3Rpb24gPT09IFwic3RyaW5nXCIpXG4gICAgICByZXR1cm4gdHJhbnNhY3Rpb247XG4gICAgcmV0dXJuIGZvcm1hdFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKTtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgLi4uYmxvY2ssXG4gICAgYmFzZUZlZVBlckdhczogYmxvY2suYmFzZUZlZVBlckdhcyA/IEJpZ0ludChibG9jay5iYXNlRmVlUGVyR2FzKSA6IG51bGwsXG4gICAgYmxvYkdhc1VzZWQ6IGJsb2NrLmJsb2JHYXNVc2VkID8gQmlnSW50KGJsb2NrLmJsb2JHYXNVc2VkKSA6IHVuZGVmaW5lZCxcbiAgICBkaWZmaWN1bHR5OiBibG9jay5kaWZmaWN1bHR5ID8gQmlnSW50KGJsb2NrLmRpZmZpY3VsdHkpIDogdW5kZWZpbmVkLFxuICAgIGV4Y2Vzc0Jsb2JHYXM6IGJsb2NrLmV4Y2Vzc0Jsb2JHYXMgPyBCaWdJbnQoYmxvY2suZXhjZXNzQmxvYkdhcykgOiB1bmRlZmluZWQsXG4gICAgZ2FzTGltaXQ6IGJsb2NrLmdhc0xpbWl0ID8gQmlnSW50KGJsb2NrLmdhc0xpbWl0KSA6IHVuZGVmaW5lZCxcbiAgICBnYXNVc2VkOiBibG9jay5nYXNVc2VkID8gQmlnSW50KGJsb2NrLmdhc1VzZWQpIDogdW5kZWZpbmVkLFxuICAgIGhhc2g6IGJsb2NrLmhhc2ggPyBibG9jay5oYXNoIDogbnVsbCxcbiAgICBsb2dzQmxvb206IGJsb2NrLmxvZ3NCbG9vbSA/IGJsb2NrLmxvZ3NCbG9vbSA6IG51bGwsXG4gICAgbm9uY2U6IGJsb2NrLm5vbmNlID8gYmxvY2subm9uY2UgOiBudWxsLFxuICAgIG51bWJlcjogYmxvY2subnVtYmVyID8gQmlnSW50KGJsb2NrLm51bWJlcikgOiBudWxsLFxuICAgIHNpemU6IGJsb2NrLnNpemUgPyBCaWdJbnQoYmxvY2suc2l6ZSkgOiB1bmRlZmluZWQsXG4gICAgdGltZXN0YW1wOiBibG9jay50aW1lc3RhbXAgPyBCaWdJbnQoYmxvY2sudGltZXN0YW1wKSA6IHVuZGVmaW5lZCxcbiAgICB0cmFuc2FjdGlvbnMsXG4gICAgdG90YWxEaWZmaWN1bHR5OiBibG9jay50b3RhbERpZmZpY3VsdHkgPyBCaWdJbnQoYmxvY2sudG90YWxEaWZmaWN1bHR5KSA6IG51bGxcbiAgfTtcbn1cbnZhciBkZWZpbmVCbG9jayA9IC8qIEBfX1BVUkVfXyAqLyBkZWZpbmVGb3JtYXR0ZXIoXCJibG9ja1wiLCBmb3JtYXRCbG9jayk7XG5cbi8vIG5vZGVfbW9kdWxlcy92aWVtL19lc20vdXRpbHMvYmxvYi9ibG9ic1RvQ29tbWl0bWVudHMuanNcbmluaXRfdG9CeXRlcygpO1xuaW5pdF90b0hleCgpO1xuZnVuY3Rpb24gYmxvYnNUb0NvbW1pdG1lbnRzKHBhcmFtZXRlcnMpIHtcbiAgY29uc3QgeyBremcgfSA9IHBhcmFtZXRlcnM7XG4gIGNvbnN0IHRvID0gcGFyYW1ldGVycy50byA/PyAodHlwZW9mIHBhcmFtZXRlcnMuYmxvYnNbMF0gPT09IFwic3RyaW5nXCIgPyBcImhleFwiIDogXCJieXRlc1wiKTtcbiAgY29uc3QgYmxvYnMgPSB0eXBlb2YgcGFyYW1ldGVycy5ibG9ic1swXSA9PT0gXCJzdHJpbmdcIiA/IHBhcmFtZXRlcnMuYmxvYnMubWFwKCh4KSA9PiBoZXhUb0J5dGVzKHgpKSA6IHBhcmFtZXRlcnMuYmxvYnM7XG4gIGNvbnN0IGNvbW1pdG1lbnRzID0gW107XG4gIGZvciAoY29uc3QgYmxvYiBvZiBibG9icylcbiAgICBjb21taXRtZW50cy5wdXNoKFVpbnQ4QXJyYXkuZnJvbShremcuYmxvYlRvS3pnQ29tbWl0bWVudChibG9iKSkpO1xuICByZXR1cm4gdG8gPT09IFwiYnl0ZXNcIiA/IGNvbW1pdG1lbnRzIDogY29tbWl0bWVudHMubWFwKCh4KSA9PiBieXRlc1RvSGV4KHgpKTtcbn1cblxuLy8gbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy9ibG9iL2Jsb2JzVG9Qcm9vZnMuanNcbmluaXRfdG9CeXRlcygpO1xuaW5pdF90b0hleCgpO1xuZnVuY3Rpb24gYmxvYnNUb1Byb29mcyhwYXJhbWV0ZXJzKSB7XG4gIGNvbnN0IHsga3pnIH0gPSBwYXJhbWV0ZXJzO1xuICBjb25zdCB0byA9IHBhcmFtZXRlcnMudG8gPz8gKHR5cGVvZiBwYXJhbWV0ZXJzLmJsb2JzWzBdID09PSBcInN0cmluZ1wiID8gXCJoZXhcIiA6IFwiYnl0ZXNcIik7XG4gIGNvbnN0IGJsb2JzID0gdHlwZW9mIHBhcmFtZXRlcnMuYmxvYnNbMF0gPT09IFwic3RyaW5nXCIgPyBwYXJhbWV0ZXJzLmJsb2JzLm1hcCgoeCkgPT4gaGV4VG9CeXRlcyh4KSkgOiBwYXJhbWV0ZXJzLmJsb2JzO1xuICBjb25zdCBjb21taXRtZW50cyA9IHR5cGVvZiBwYXJhbWV0ZXJzLmNvbW1pdG1lbnRzWzBdID09PSBcInN0cmluZ1wiID8gcGFyYW1ldGVycy5jb21taXRtZW50cy5tYXAoKHgpID0+IGhleFRvQnl0ZXMoeCkpIDogcGFyYW1ldGVycy5jb21taXRtZW50cztcbiAgY29uc3QgcHJvb2ZzID0gW107XG4gIGZvciAobGV0IGkgPSAwO2kgPCBibG9icy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGJsb2IgPSBibG9ic1tpXTtcbiAgICBjb25zdCBjb21taXRtZW50ID0gY29tbWl0bWVudHNbaV07XG4gICAgcHJvb2ZzLnB1c2goVWludDhBcnJheS5mcm9tKGt6Zy5jb21wdXRlQmxvYkt6Z1Byb29mKGJsb2IsIGNvbW1pdG1lbnQpKSk7XG4gIH1cbiAgcmV0dXJuIHRvID09PSBcImJ5dGVzXCIgPyBwcm9vZnMgOiBwcm9vZnMubWFwKCh4KSA9PiBieXRlc1RvSGV4KHgpKTtcbn1cblxuLy8gbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy9ibG9iL2NvbW1pdG1lbnRUb1ZlcnNpb25lZEhhc2guanNcbmluaXRfdG9IZXgoKTtcblxuLy8gbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3NoYTI1Ni5qc1xuaW5pdF9zaGEyKCk7XG52YXIgc2hhMjU2MiA9IHNoYTI1NjtcblxuLy8gbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy9oYXNoL3NoYTI1Ni5qc1xuaW5pdF90b0J5dGVzKCk7XG5pbml0X3RvSGV4KCk7XG5mdW5jdGlvbiBzaGEyNTYzKHZhbHVlLCB0b18pIHtcbiAgY29uc3QgdG8gPSB0b18gfHwgXCJoZXhcIjtcbiAgY29uc3QgYnl0ZXMgPSBzaGEyNTYyKGlzSGV4KHZhbHVlLCB7IHN0cmljdDogZmFsc2UgfSkgPyB0b0J5dGVzMih2YWx1ZSkgOiB2YWx1ZSk7XG4gIGlmICh0byA9PT0gXCJieXRlc1wiKVxuICAgIHJldHVybiBieXRlcztcbiAgcmV0dXJuIHRvSGV4KGJ5dGVzKTtcbn1cblxuLy8gbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy9ibG9iL2NvbW1pdG1lbnRUb1ZlcnNpb25lZEhhc2guanNcbmZ1bmN0aW9uIGNvbW1pdG1lbnRUb1ZlcnNpb25lZEhhc2gocGFyYW1ldGVycykge1xuICBjb25zdCB7IGNvbW1pdG1lbnQsIHZlcnNpb246IHZlcnNpb24yID0gMSB9ID0gcGFyYW1ldGVycztcbiAgY29uc3QgdG8gPSBwYXJhbWV0ZXJzLnRvID8/ICh0eXBlb2YgY29tbWl0bWVudCA9PT0gXCJzdHJpbmdcIiA/IFwiaGV4XCIgOiBcImJ5dGVzXCIpO1xuICBjb25zdCB2ZXJzaW9uZWRIYXNoID0gc2hhMjU2Myhjb21taXRtZW50LCBcImJ5dGVzXCIpO1xuICB2ZXJzaW9uZWRIYXNoLnNldChbdmVyc2lvbjJdLCAwKTtcbiAgcmV0dXJuIHRvID09PSBcImJ5dGVzXCIgPyB2ZXJzaW9uZWRIYXNoIDogYnl0ZXNUb0hleCh2ZXJzaW9uZWRIYXNoKTtcbn1cblxuLy8gbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy9ibG9iL2NvbW1pdG1lbnRzVG9WZXJzaW9uZWRIYXNoZXMuanNcbmZ1bmN0aW9uIGNvbW1pdG1lbnRzVG9WZXJzaW9uZWRIYXNoZXMocGFyYW1ldGVycykge1xuICBjb25zdCB7IGNvbW1pdG1lbnRzLCB2ZXJzaW9uOiB2ZXJzaW9uMiB9ID0gcGFyYW1ldGVycztcbiAgY29uc3QgdG8gPSBwYXJhbWV0ZXJzLnRvID8/ICh0eXBlb2YgY29tbWl0bWVudHNbMF0gPT09IFwic3RyaW5nXCIgPyBcImhleFwiIDogXCJieXRlc1wiKTtcbiAgY29uc3QgaGFzaGVzID0gW107XG4gIGZvciAoY29uc3QgY29tbWl0bWVudCBvZiBjb21taXRtZW50cykge1xuICAgIGhhc2hlcy5wdXNoKGNvbW1pdG1lbnRUb1ZlcnNpb25lZEhhc2goe1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIHRvLFxuICAgICAgdmVyc2lvbjogdmVyc2lvbjJcbiAgICB9KSk7XG4gIH1cbiAgcmV0dXJuIGhhc2hlcztcbn1cblxuLy8gbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS9jb25zdGFudHMvYmxvYi5qc1xudmFyIGJsb2JzUGVyVHJhbnNhY3Rpb24gPSA2O1xudmFyIGJ5dGVzUGVyRmllbGRFbGVtZW50ID0gMzI7XG52YXIgZmllbGRFbGVtZW50c1BlckJsb2IgPSA0MDk2O1xudmFyIGJ5dGVzUGVyQmxvYiA9IGJ5dGVzUGVyRmllbGRFbGVtZW50ICogZmllbGRFbGVtZW50c1BlckJsb2I7XG52YXIgbWF4Qnl0ZXNQZXJUcmFuc2FjdGlvbiA9IGJ5dGVzUGVyQmxvYiAqIGJsb2JzUGVyVHJhbnNhY3Rpb24gLSAxIC0gMSAqIGZpZWxkRWxlbWVudHNQZXJCbG9iICogYmxvYnNQZXJUcmFuc2FjdGlvbjtcblxuLy8gbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS9jb25zdGFudHMva3pnLmpzXG52YXIgdmVyc2lvbmVkSGFzaFZlcnNpb25LemcgPSAxO1xuXG4vLyBub2RlX21vZHVsZXMvdmllbS9fZXNtL2Vycm9ycy9ibG9iLmpzXG5pbml0X2Jhc2UoKTtcblxuY2xhc3MgQmxvYlNpemVUb29MYXJnZUVycm9yIGV4dGVuZHMgQmFzZUVycm9yIHtcbiAgY29uc3RydWN0b3IoeyBtYXhTaXplLCBzaXplOiBzaXplMiB9KSB7XG4gICAgc3VwZXIoXCJCbG9iIHNpemUgaXMgdG9vIGxhcmdlLlwiLCB7XG4gICAgICBtZXRhTWVzc2FnZXM6IFtgTWF4OiAke21heFNpemV9IGJ5dGVzYCwgYEdpdmVuOiAke3NpemUyfSBieXRlc2BdLFxuICAgICAgbmFtZTogXCJCbG9iU2l6ZVRvb0xhcmdlRXJyb3JcIlxuICAgIH0pO1xuICB9XG59XG5cbmNsYXNzIEVtcHR5QmxvYkVycm9yIGV4dGVuZHMgQmFzZUVycm9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoXCJCbG9iIGRhdGEgbXVzdCBub3QgYmUgZW1wdHkuXCIsIHsgbmFtZTogXCJFbXB0eUJsb2JFcnJvclwiIH0pO1xuICB9XG59XG5cbmNsYXNzIEludmFsaWRWZXJzaW9uZWRIYXNoU2l6ZUVycm9yIGV4dGVuZHMgQmFzZUVycm9yIHtcbiAgY29uc3RydWN0b3IoeyBoYXNoOiBoYXNoMiwgc2l6ZTogc2l6ZTIgfSkge1xuICAgIHN1cGVyKGBWZXJzaW9uZWQgaGFzaCBcIiR7aGFzaDJ9XCIgc2l6ZSBpcyBpbnZhbGlkLmAsIHtcbiAgICAgIG1ldGFNZXNzYWdlczogW1wiRXhwZWN0ZWQ6IDMyXCIsIGBSZWNlaXZlZDogJHtzaXplMn1gXSxcbiAgICAgIG5hbWU6IFwiSW52YWxpZFZlcnNpb25lZEhhc2hTaXplRXJyb3JcIlxuICAgIH0pO1xuICB9XG59XG5cbmNsYXNzIEludmFsaWRWZXJzaW9uZWRIYXNoVmVyc2lvbkVycm9yIGV4dGVuZHMgQmFzZUVycm9yIHtcbiAgY29uc3RydWN0b3IoeyBoYXNoOiBoYXNoMiwgdmVyc2lvbjogdmVyc2lvbjIgfSkge1xuICAgIHN1cGVyKGBWZXJzaW9uZWQgaGFzaCBcIiR7aGFzaDJ9XCIgdmVyc2lvbiBpcyBpbnZhbGlkLmAsIHtcbiAgICAgIG1ldGFNZXNzYWdlczogW1xuICAgICAgICBgRXhwZWN0ZWQ6ICR7dmVyc2lvbmVkSGFzaFZlcnNpb25Lemd9YCxcbiAgICAgICAgYFJlY2VpdmVkOiAke3ZlcnNpb24yfWBcbiAgICAgIF0sXG4gICAgICBuYW1lOiBcIkludmFsaWRWZXJzaW9uZWRIYXNoVmVyc2lvbkVycm9yXCJcbiAgICB9KTtcbiAgfVxufVxuXG4vLyBub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL2Jsb2IvdG9CbG9icy5qc1xuaW5pdF9jdXJzb3IyKCk7XG5pbml0X3NpemUoKTtcbmluaXRfdG9CeXRlcygpO1xuaW5pdF90b0hleCgpO1xuZnVuY3Rpb24gdG9CbG9icyhwYXJhbWV0ZXJzKSB7XG4gIGNvbnN0IHRvID0gcGFyYW1ldGVycy50byA/PyAodHlwZW9mIHBhcmFtZXRlcnMuZGF0YSA9PT0gXCJzdHJpbmdcIiA/IFwiaGV4XCIgOiBcImJ5dGVzXCIpO1xuICBjb25zdCBkYXRhID0gdHlwZW9mIHBhcmFtZXRlcnMuZGF0YSA9PT0gXCJzdHJpbmdcIiA/IGhleFRvQnl0ZXMocGFyYW1ldGVycy5kYXRhKSA6IHBhcmFtZXRlcnMuZGF0YTtcbiAgY29uc3Qgc2l6ZV8gPSBzaXplKGRhdGEpO1xuICBpZiAoIXNpemVfKVxuICAgIHRocm93IG5ldyBFbXB0eUJsb2JFcnJvcjtcbiAgaWYgKHNpemVfID4gbWF4Qnl0ZXNQZXJUcmFuc2FjdGlvbilcbiAgICB0aHJvdyBuZXcgQmxvYlNpemVUb29MYXJnZUVycm9yKHtcbiAgICAgIG1heFNpemU6IG1heEJ5dGVzUGVyVHJhbnNhY3Rpb24sXG4gICAgICBzaXplOiBzaXplX1xuICAgIH0pO1xuICBjb25zdCBibG9icyA9IFtdO1xuICBsZXQgYWN0aXZlID0gdHJ1ZTtcbiAgbGV0IHBvc2l0aW9uID0gMDtcbiAgd2hpbGUgKGFjdGl2ZSkge1xuICAgIGNvbnN0IGJsb2IgPSBjcmVhdGVDdXJzb3IobmV3IFVpbnQ4QXJyYXkoYnl0ZXNQZXJCbG9iKSk7XG4gICAgbGV0IHNpemUyID0gMDtcbiAgICB3aGlsZSAoc2l6ZTIgPCBmaWVsZEVsZW1lbnRzUGVyQmxvYikge1xuICAgICAgY29uc3QgYnl0ZXMgPSBkYXRhLnNsaWNlKHBvc2l0aW9uLCBwb3NpdGlvbiArIChieXRlc1BlckZpZWxkRWxlbWVudCAtIDEpKTtcbiAgICAgIGJsb2IucHVzaEJ5dGUoMCk7XG4gICAgICBibG9iLnB1c2hCeXRlcyhieXRlcyk7XG4gICAgICBpZiAoYnl0ZXMubGVuZ3RoIDwgMzEpIHtcbiAgICAgICAgYmxvYi5wdXNoQnl0ZSgxMjgpO1xuICAgICAgICBhY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBzaXplMisrO1xuICAgICAgcG9zaXRpb24gKz0gMzE7XG4gICAgfVxuICAgIGJsb2JzLnB1c2goYmxvYik7XG4gIH1cbiAgcmV0dXJuIHRvID09PSBcImJ5dGVzXCIgPyBibG9icy5tYXAoKHgpID0+IHguYnl0ZXMpIDogYmxvYnMubWFwKCh4KSA9PiBieXRlc1RvSGV4KHguYnl0ZXMpKTtcbn1cblxuLy8gbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy9ibG9iL3RvQmxvYlNpZGVjYXJzLmpzXG5mdW5jdGlvbiB0b0Jsb2JTaWRlY2FycyhwYXJhbWV0ZXJzKSB7XG4gIGNvbnN0IHsgZGF0YSwga3pnLCB0byB9ID0gcGFyYW1ldGVycztcbiAgY29uc3QgYmxvYnMgPSBwYXJhbWV0ZXJzLmJsb2JzID8/IHRvQmxvYnMoeyBkYXRhLCB0byB9KTtcbiAgY29uc3QgY29tbWl0bWVudHMgPSBwYXJhbWV0ZXJzLmNvbW1pdG1lbnRzID8/IGJsb2JzVG9Db21taXRtZW50cyh7IGJsb2JzLCBremcsIHRvIH0pO1xuICBjb25zdCBwcm9vZnMgPSBwYXJhbWV0ZXJzLnByb29mcyA/PyBibG9ic1RvUHJvb2ZzKHsgYmxvYnMsIGNvbW1pdG1lbnRzLCBremcsIHRvIH0pO1xuICBjb25zdCBzaWRlY2FycyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDtpIDwgYmxvYnMubGVuZ3RoOyBpKyspXG4gICAgc2lkZWNhcnMucHVzaCh7XG4gICAgICBibG9iOiBibG9ic1tpXSxcbiAgICAgIGNvbW1pdG1lbnQ6IGNvbW1pdG1lbnRzW2ldLFxuICAgICAgcHJvb2Y6IHByb29mc1tpXVxuICAgIH0pO1xuICByZXR1cm4gc2lkZWNhcnM7XG59XG5cbi8vIG5vZGVfbW9kdWxlcy92aWVtL19lc20vdXRpbHMvdHJhbnNhY3Rpb24vZ2V0VHJhbnNhY3Rpb25UeXBlLmpzXG5pbml0X3RyYW5zYWN0aW9uKCk7XG5mdW5jdGlvbiBnZXRUcmFuc2FjdGlvblR5cGUodHJhbnNhY3Rpb24pIHtcbiAgaWYgKHRyYW5zYWN0aW9uLnR5cGUpXG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uLnR5cGU7XG4gIGlmICh0eXBlb2YgdHJhbnNhY3Rpb24uYXV0aG9yaXphdGlvbkxpc3QgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgcmV0dXJuIFwiZWlwNzcwMlwiO1xuICBpZiAodHlwZW9mIHRyYW5zYWN0aW9uLmJsb2JzICE9PSBcInVuZGVmaW5lZFwiIHx8IHR5cGVvZiB0cmFuc2FjdGlvbi5ibG9iVmVyc2lvbmVkSGFzaGVzICE9PSBcInVuZGVmaW5lZFwiIHx8IHR5cGVvZiB0cmFuc2FjdGlvbi5tYXhGZWVQZXJCbG9iR2FzICE9PSBcInVuZGVmaW5lZFwiIHx8IHR5cGVvZiB0cmFuc2FjdGlvbi5zaWRlY2FycyAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICByZXR1cm4gXCJlaXA0ODQ0XCI7XG4gIGlmICh0eXBlb2YgdHJhbnNhY3Rpb24ubWF4RmVlUGVyR2FzICE9PSBcInVuZGVmaW5lZFwiIHx8IHR5cGVvZiB0cmFuc2FjdGlvbi5tYXhQcmlvcml0eUZlZVBlckdhcyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiBcImVpcDE1NTlcIjtcbiAgfVxuICBpZiAodHlwZW9mIHRyYW5zYWN0aW9uLmdhc1ByaWNlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgaWYgKHR5cGVvZiB0cmFuc2FjdGlvbi5hY2Nlc3NMaXN0ICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgcmV0dXJuIFwiZWlwMjkzMFwiO1xuICAgIHJldHVybiBcImxlZ2FjeVwiO1xuICB9XG4gIHRocm93IG5ldyBJbnZhbGlkU2VyaWFsaXphYmxlVHJhbnNhY3Rpb25FcnJvcih7IHRyYW5zYWN0aW9uIH0pO1xufVxuXG4vLyBub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL2Zvcm1hdHRlcnMvbG9nLmpzXG5mdW5jdGlvbiBmb3JtYXRMb2cobG9nLCB7IGFyZ3MsIGV2ZW50TmFtZSB9ID0ge30pIHtcbiAgcmV0dXJuIHtcbiAgICAuLi5sb2csXG4gICAgYmxvY2tIYXNoOiBsb2cuYmxvY2tIYXNoID8gbG9nLmJsb2NrSGFzaCA6IG51bGwsXG4gICAgYmxvY2tOdW1iZXI6IGxvZy5ibG9ja051bWJlciA/IEJpZ0ludChsb2cuYmxvY2tOdW1iZXIpIDogbnVsbCxcbiAgICBsb2dJbmRleDogbG9nLmxvZ0luZGV4ID8gTnVtYmVyKGxvZy5sb2dJbmRleCkgOiBudWxsLFxuICAgIHRyYW5zYWN0aW9uSGFzaDogbG9nLnRyYW5zYWN0aW9uSGFzaCA/IGxvZy50cmFuc2FjdGlvbkhhc2ggOiBudWxsLFxuICAgIHRyYW5zYWN0aW9uSW5kZXg6IGxvZy50cmFuc2FjdGlvbkluZGV4ID8gTnVtYmVyKGxvZy50cmFuc2FjdGlvbkluZGV4KSA6IG51bGwsXG4gICAgLi4uZXZlbnROYW1lID8geyBhcmdzLCBldmVudE5hbWUgfSA6IHt9XG4gIH07XG59XG5cbi8vIG5vZGVfbW9kdWxlcy92aWVtL19lc20vdXRpbHMvZm9ybWF0dGVycy90cmFuc2FjdGlvblJlY2VpcHQuanNcbmluaXRfZnJvbUhleCgpO1xudmFyIHJlY2VpcHRTdGF0dXNlcyA9IHtcbiAgXCIweDBcIjogXCJyZXZlcnRlZFwiLFxuICBcIjB4MVwiOiBcInN1Y2Nlc3NcIlxufTtcbmZ1bmN0aW9uIGZvcm1hdFRyYW5zYWN0aW9uUmVjZWlwdCh0cmFuc2FjdGlvblJlY2VpcHQpIHtcbiAgY29uc3QgcmVjZWlwdCA9IHtcbiAgICAuLi50cmFuc2FjdGlvblJlY2VpcHQsXG4gICAgYmxvY2tOdW1iZXI6IHRyYW5zYWN0aW9uUmVjZWlwdC5ibG9ja051bWJlciA/IEJpZ0ludCh0cmFuc2FjdGlvblJlY2VpcHQuYmxvY2tOdW1iZXIpIDogbnVsbCxcbiAgICBjb250cmFjdEFkZHJlc3M6IHRyYW5zYWN0aW9uUmVjZWlwdC5jb250cmFjdEFkZHJlc3MgPyB0cmFuc2FjdGlvblJlY2VpcHQuY29udHJhY3RBZGRyZXNzIDogbnVsbCxcbiAgICBjdW11bGF0aXZlR2FzVXNlZDogdHJhbnNhY3Rpb25SZWNlaXB0LmN1bXVsYXRpdmVHYXNVc2VkID8gQmlnSW50KHRyYW5zYWN0aW9uUmVjZWlwdC5jdW11bGF0aXZlR2FzVXNlZCkgOiBudWxsLFxuICAgIGVmZmVjdGl2ZUdhc1ByaWNlOiB0cmFuc2FjdGlvblJlY2VpcHQuZWZmZWN0aXZlR2FzUHJpY2UgPyBCaWdJbnQodHJhbnNhY3Rpb25SZWNlaXB0LmVmZmVjdGl2ZUdhc1ByaWNlKSA6IG51bGwsXG4gICAgZ2FzVXNlZDogdHJhbnNhY3Rpb25SZWNlaXB0Lmdhc1VzZWQgPyBCaWdJbnQodHJhbnNhY3Rpb25SZWNlaXB0Lmdhc1VzZWQpIDogbnVsbCxcbiAgICBsb2dzOiB0cmFuc2FjdGlvblJlY2VpcHQubG9ncyA/IHRyYW5zYWN0aW9uUmVjZWlwdC5sb2dzLm1hcCgobG9nKSA9PiBmb3JtYXRMb2cobG9nKSkgOiBudWxsLFxuICAgIHRvOiB0cmFuc2FjdGlvblJlY2VpcHQudG8gPyB0cmFuc2FjdGlvblJlY2VpcHQudG8gOiBudWxsLFxuICAgIHRyYW5zYWN0aW9uSW5kZXg6IHRyYW5zYWN0aW9uUmVjZWlwdC50cmFuc2FjdGlvbkluZGV4ID8gaGV4VG9OdW1iZXIodHJhbnNhY3Rpb25SZWNlaXB0LnRyYW5zYWN0aW9uSW5kZXgpIDogbnVsbCxcbiAgICBzdGF0dXM6IHRyYW5zYWN0aW9uUmVjZWlwdC5zdGF0dXMgPyByZWNlaXB0U3RhdHVzZXNbdHJhbnNhY3Rpb25SZWNlaXB0LnN0YXR1c10gOiBudWxsLFxuICAgIHR5cGU6IHRyYW5zYWN0aW9uUmVjZWlwdC50eXBlID8gdHJhbnNhY3Rpb25UeXBlW3RyYW5zYWN0aW9uUmVjZWlwdC50eXBlXSB8fCB0cmFuc2FjdGlvblJlY2VpcHQudHlwZSA6IG51bGxcbiAgfTtcbiAgaWYgKHRyYW5zYWN0aW9uUmVjZWlwdC5ibG9iR2FzUHJpY2UpXG4gICAgcmVjZWlwdC5ibG9iR2FzUHJpY2UgPSBCaWdJbnQodHJhbnNhY3Rpb25SZWNlaXB0LmJsb2JHYXNQcmljZSk7XG4gIGlmICh0cmFuc2FjdGlvblJlY2VpcHQuYmxvYkdhc1VzZWQpXG4gICAgcmVjZWlwdC5ibG9iR2FzVXNlZCA9IEJpZ0ludCh0cmFuc2FjdGlvblJlY2VpcHQuYmxvYkdhc1VzZWQpO1xuICByZXR1cm4gcmVjZWlwdDtcbn1cbnZhciBkZWZpbmVUcmFuc2FjdGlvblJlY2VpcHQgPSAvKiBAX19QVVJFX18gKi8gZGVmaW5lRm9ybWF0dGVyKFwidHJhbnNhY3Rpb25SZWNlaXB0XCIsIGZvcm1hdFRyYW5zYWN0aW9uUmVjZWlwdCk7XG5cbi8vIG5vZGVfbW9kdWxlcy92aWVtL19lc20vdXRpbHMvY2hhaW4vZGVmaW5lQ2hhaW4uanNcbmZ1bmN0aW9uIGRlZmluZUNoYWluKGNoYWluKSB7XG4gIHJldHVybiB7XG4gICAgZm9ybWF0dGVyczogdW5kZWZpbmVkLFxuICAgIGZlZXM6IHVuZGVmaW5lZCxcbiAgICBzZXJpYWxpemVyczogdW5kZWZpbmVkLFxuICAgIC4uLmNoYWluXG4gIH07XG59XG5cbi8vIG5vZGVfbW9kdWxlcy92aWVtL19lc20vdXRpbHMvYWJpL2VuY29kZVBhY2tlZC5qc1xuaW5pdF9hYmkoKTtcbmluaXRfYWRkcmVzcygpO1xuaW5pdF9pc0FkZHJlc3MoKTtcbmluaXRfcGFkKCk7XG5pbml0X3RvSGV4KCk7XG5pbml0X3JlZ2V4MigpO1xuZnVuY3Rpb24gZW5jb2RlUGFja2VkKHR5cGVzLCB2YWx1ZXMpIHtcbiAgaWYgKHR5cGVzLmxlbmd0aCAhPT0gdmFsdWVzLmxlbmd0aClcbiAgICB0aHJvdyBuZXcgQWJpRW5jb2RpbmdMZW5ndGhNaXNtYXRjaEVycm9yKHtcbiAgICAgIGV4cGVjdGVkTGVuZ3RoOiB0eXBlcy5sZW5ndGgsXG4gICAgICBnaXZlbkxlbmd0aDogdmFsdWVzLmxlbmd0aFxuICAgIH0pO1xuICBjb25zdCBkYXRhID0gW107XG4gIGZvciAobGV0IGkgPSAwO2kgPCB0eXBlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHR5cGUgPSB0eXBlc1tpXTtcbiAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1tpXTtcbiAgICBkYXRhLnB1c2goZW5jb2RlKHR5cGUsIHZhbHVlKSk7XG4gIH1cbiAgcmV0dXJuIGNvbmNhdEhleChkYXRhKTtcbn1cbmZ1bmN0aW9uIGVuY29kZSh0eXBlLCB2YWx1ZSwgaXNBcnJheSA9IGZhbHNlKSB7XG4gIGlmICh0eXBlID09PSBcImFkZHJlc3NcIikge1xuICAgIGNvbnN0IGFkZHJlc3MgPSB2YWx1ZTtcbiAgICBpZiAoIWlzQWRkcmVzcyhhZGRyZXNzKSlcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQWRkcmVzc0Vycm9yKHsgYWRkcmVzcyB9KTtcbiAgICByZXR1cm4gcGFkKGFkZHJlc3MudG9Mb3dlckNhc2UoKSwge1xuICAgICAgc2l6ZTogaXNBcnJheSA/IDMyIDogbnVsbFxuICAgIH0pO1xuICB9XG4gIGlmICh0eXBlID09PSBcInN0cmluZ1wiKVxuICAgIHJldHVybiBzdHJpbmdUb0hleCh2YWx1ZSk7XG4gIGlmICh0eXBlID09PSBcImJ5dGVzXCIpXG4gICAgcmV0dXJuIHZhbHVlO1xuICBpZiAodHlwZSA9PT0gXCJib29sXCIpXG4gICAgcmV0dXJuIHBhZChib29sVG9IZXgodmFsdWUpLCB7IHNpemU6IGlzQXJyYXkgPyAzMiA6IDEgfSk7XG4gIGNvbnN0IGludE1hdGNoID0gdHlwZS5tYXRjaChpbnRlZ2VyUmVnZXgpO1xuICBpZiAoaW50TWF0Y2gpIHtcbiAgICBjb25zdCBbX3R5cGUsIGJhc2VUeXBlLCBiaXRzID0gXCIyNTZcIl0gPSBpbnRNYXRjaDtcbiAgICBjb25zdCBzaXplMiA9IE51bWJlci5wYXJzZUludChiaXRzKSAvIDg7XG4gICAgcmV0dXJuIG51bWJlclRvSGV4KHZhbHVlLCB7XG4gICAgICBzaXplOiBpc0FycmF5ID8gMzIgOiBzaXplMixcbiAgICAgIHNpZ25lZDogYmFzZVR5cGUgPT09IFwiaW50XCJcbiAgICB9KTtcbiAgfVxuICBjb25zdCBieXRlc01hdGNoID0gdHlwZS5tYXRjaChieXRlc1JlZ2V4KTtcbiAgaWYgKGJ5dGVzTWF0Y2gpIHtcbiAgICBjb25zdCBbX3R5cGUsIHNpemUyXSA9IGJ5dGVzTWF0Y2g7XG4gICAgaWYgKE51bWJlci5wYXJzZUludChzaXplMikgIT09ICh2YWx1ZS5sZW5ndGggLSAyKSAvIDIpXG4gICAgICB0aHJvdyBuZXcgQnl0ZXNTaXplTWlzbWF0Y2hFcnJvcih7XG4gICAgICAgIGV4cGVjdGVkU2l6ZTogTnVtYmVyLnBhcnNlSW50KHNpemUyKSxcbiAgICAgICAgZ2l2ZW5TaXplOiAodmFsdWUubGVuZ3RoIC0gMikgLyAyXG4gICAgICB9KTtcbiAgICByZXR1cm4gcGFkKHZhbHVlLCB7IGRpcjogXCJyaWdodFwiLCBzaXplOiBpc0FycmF5ID8gMzIgOiBudWxsIH0pO1xuICB9XG4gIGNvbnN0IGFycmF5TWF0Y2ggPSB0eXBlLm1hdGNoKGFycmF5UmVnZXgpO1xuICBpZiAoYXJyYXlNYXRjaCAmJiBBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIGNvbnN0IFtfdHlwZSwgY2hpbGRUeXBlXSA9IGFycmF5TWF0Y2g7XG4gICAgY29uc3QgZGF0YSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwO2kgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgZGF0YS5wdXNoKGVuY29kZShjaGlsZFR5cGUsIHZhbHVlW2ldLCB0cnVlKSk7XG4gICAgfVxuICAgIGlmIChkYXRhLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybiBcIjB4XCI7XG4gICAgcmV0dXJuIGNvbmNhdEhleChkYXRhKTtcbiAgfVxuICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRQYWNrZWRBYmlUeXBlKHR5cGUpO1xufVxuXG4vLyBub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL2F1dGhvcml6YXRpb24vc2VyaWFsaXplQXV0aG9yaXphdGlvbkxpc3QuanNcbmluaXRfdG9IZXgoKTtcblxuLy8gbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy90cmFuc2FjdGlvbi9zZXJpYWxpemVUcmFuc2FjdGlvbi5qc1xuaW5pdF90cmFuc2FjdGlvbigpO1xuaW5pdF90b0hleCgpO1xuXG4vLyBub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL3RyYW5zYWN0aW9uL2Fzc2VydFRyYW5zYWN0aW9uLmpzXG5pbml0X251bWJlcigpO1xuaW5pdF9hZGRyZXNzKCk7XG5pbml0X2Jhc2UoKTtcbmluaXRfY2hhaW4oKTtcbmluaXRfbm9kZSgpO1xuaW5pdF9pc0FkZHJlc3MoKTtcbmluaXRfc2l6ZSgpO1xuaW5pdF9zbGljZSgpO1xuaW5pdF9mcm9tSGV4KCk7XG5mdW5jdGlvbiBhc3NlcnRUcmFuc2FjdGlvbkVJUDc3MDIodHJhbnNhY3Rpb24pIHtcbiAgY29uc3QgeyBhdXRob3JpemF0aW9uTGlzdCB9ID0gdHJhbnNhY3Rpb247XG4gIGlmIChhdXRob3JpemF0aW9uTGlzdCkge1xuICAgIGZvciAoY29uc3QgYXV0aG9yaXphdGlvbiBvZiBhdXRob3JpemF0aW9uTGlzdCkge1xuICAgICAgY29uc3QgeyBjaGFpbklkIH0gPSBhdXRob3JpemF0aW9uO1xuICAgICAgY29uc3QgYWRkcmVzcyA9IGF1dGhvcml6YXRpb24uYWRkcmVzcztcbiAgICAgIGlmICghaXNBZGRyZXNzKGFkZHJlc3MpKVxuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFkZHJlc3NFcnJvcih7IGFkZHJlc3MgfSk7XG4gICAgICBpZiAoY2hhaW5JZCA8IDApXG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQ2hhaW5JZEVycm9yKHsgY2hhaW5JZCB9KTtcbiAgICB9XG4gIH1cbiAgYXNzZXJ0VHJhbnNhY3Rpb25FSVAxNTU5KHRyYW5zYWN0aW9uKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFRyYW5zYWN0aW9uRUlQNDg0NCh0cmFuc2FjdGlvbikge1xuICBjb25zdCB7IGJsb2JWZXJzaW9uZWRIYXNoZXMgfSA9IHRyYW5zYWN0aW9uO1xuICBpZiAoYmxvYlZlcnNpb25lZEhhc2hlcykge1xuICAgIGlmIChibG9iVmVyc2lvbmVkSGFzaGVzLmxlbmd0aCA9PT0gMClcbiAgICAgIHRocm93IG5ldyBFbXB0eUJsb2JFcnJvcjtcbiAgICBmb3IgKGNvbnN0IGhhc2gyIG9mIGJsb2JWZXJzaW9uZWRIYXNoZXMpIHtcbiAgICAgIGNvbnN0IHNpemVfID0gc2l6ZShoYXNoMik7XG4gICAgICBjb25zdCB2ZXJzaW9uMiA9IGhleFRvTnVtYmVyKHNsaWNlKGhhc2gyLCAwLCAxKSk7XG4gICAgICBpZiAoc2l6ZV8gIT09IDMyKVxuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFZlcnNpb25lZEhhc2hTaXplRXJyb3IoeyBoYXNoOiBoYXNoMiwgc2l6ZTogc2l6ZV8gfSk7XG4gICAgICBpZiAodmVyc2lvbjIgIT09IHZlcnNpb25lZEhhc2hWZXJzaW9uS3pnKVxuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFZlcnNpb25lZEhhc2hWZXJzaW9uRXJyb3Ioe1xuICAgICAgICAgIGhhc2g6IGhhc2gyLFxuICAgICAgICAgIHZlcnNpb246IHZlcnNpb24yXG4gICAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBhc3NlcnRUcmFuc2FjdGlvbkVJUDE1NTkodHJhbnNhY3Rpb24pO1xufVxuZnVuY3Rpb24gYXNzZXJ0VHJhbnNhY3Rpb25FSVAxNTU5KHRyYW5zYWN0aW9uKSB7XG4gIGNvbnN0IHsgY2hhaW5JZCwgbWF4UHJpb3JpdHlGZWVQZXJHYXMsIG1heEZlZVBlckdhcywgdG8gfSA9IHRyYW5zYWN0aW9uO1xuICBpZiAoY2hhaW5JZCA8PSAwKVxuICAgIHRocm93IG5ldyBJbnZhbGlkQ2hhaW5JZEVycm9yKHsgY2hhaW5JZCB9KTtcbiAgaWYgKHRvICYmICFpc0FkZHJlc3ModG8pKVxuICAgIHRocm93IG5ldyBJbnZhbGlkQWRkcmVzc0Vycm9yKHsgYWRkcmVzczogdG8gfSk7XG4gIGlmIChtYXhGZWVQZXJHYXMgJiYgbWF4RmVlUGVyR2FzID4gbWF4VWludDI1NilcbiAgICB0aHJvdyBuZXcgRmVlQ2FwVG9vSGlnaEVycm9yKHsgbWF4RmVlUGVyR2FzIH0pO1xuICBpZiAobWF4UHJpb3JpdHlGZWVQZXJHYXMgJiYgbWF4RmVlUGVyR2FzICYmIG1heFByaW9yaXR5RmVlUGVyR2FzID4gbWF4RmVlUGVyR2FzKVxuICAgIHRocm93IG5ldyBUaXBBYm92ZUZlZUNhcEVycm9yKHsgbWF4RmVlUGVyR2FzLCBtYXhQcmlvcml0eUZlZVBlckdhcyB9KTtcbn1cbmZ1bmN0aW9uIGFzc2VydFRyYW5zYWN0aW9uRUlQMjkzMCh0cmFuc2FjdGlvbikge1xuICBjb25zdCB7IGNoYWluSWQsIG1heFByaW9yaXR5RmVlUGVyR2FzLCBnYXNQcmljZSwgbWF4RmVlUGVyR2FzLCB0byB9ID0gdHJhbnNhY3Rpb247XG4gIGlmIChjaGFpbklkIDw9IDApXG4gICAgdGhyb3cgbmV3IEludmFsaWRDaGFpbklkRXJyb3IoeyBjaGFpbklkIH0pO1xuICBpZiAodG8gJiYgIWlzQWRkcmVzcyh0bykpXG4gICAgdGhyb3cgbmV3IEludmFsaWRBZGRyZXNzRXJyb3IoeyBhZGRyZXNzOiB0byB9KTtcbiAgaWYgKG1heFByaW9yaXR5RmVlUGVyR2FzIHx8IG1heEZlZVBlckdhcylcbiAgICB0aHJvdyBuZXcgQmFzZUVycm9yKFwiYG1heEZlZVBlckdhc2AvYG1heFByaW9yaXR5RmVlUGVyR2FzYCBpcyBub3QgYSB2YWxpZCBFSVAtMjkzMCBUcmFuc2FjdGlvbiBhdHRyaWJ1dGUuXCIpO1xuICBpZiAoZ2FzUHJpY2UgJiYgZ2FzUHJpY2UgPiBtYXhVaW50MjU2KVxuICAgIHRocm93IG5ldyBGZWVDYXBUb29IaWdoRXJyb3IoeyBtYXhGZWVQZXJHYXM6IGdhc1ByaWNlIH0pO1xufVxuZnVuY3Rpb24gYXNzZXJ0VHJhbnNhY3Rpb25MZWdhY3kodHJhbnNhY3Rpb24pIHtcbiAgY29uc3QgeyBjaGFpbklkLCBtYXhQcmlvcml0eUZlZVBlckdhcywgZ2FzUHJpY2UsIG1heEZlZVBlckdhcywgdG8gfSA9IHRyYW5zYWN0aW9uO1xuICBpZiAodG8gJiYgIWlzQWRkcmVzcyh0bykpXG4gICAgdGhyb3cgbmV3IEludmFsaWRBZGRyZXNzRXJyb3IoeyBhZGRyZXNzOiB0byB9KTtcbiAgaWYgKHR5cGVvZiBjaGFpbklkICE9PSBcInVuZGVmaW5lZFwiICYmIGNoYWluSWQgPD0gMClcbiAgICB0aHJvdyBuZXcgSW52YWxpZENoYWluSWRFcnJvcih7IGNoYWluSWQgfSk7XG4gIGlmIChtYXhQcmlvcml0eUZlZVBlckdhcyB8fCBtYXhGZWVQZXJHYXMpXG4gICAgdGhyb3cgbmV3IEJhc2VFcnJvcihcImBtYXhGZWVQZXJHYXNgL2BtYXhQcmlvcml0eUZlZVBlckdhc2AgaXMgbm90IGEgdmFsaWQgTGVnYWN5IFRyYW5zYWN0aW9uIGF0dHJpYnV0ZS5cIik7XG4gIGlmIChnYXNQcmljZSAmJiBnYXNQcmljZSA+IG1heFVpbnQyNTYpXG4gICAgdGhyb3cgbmV3IEZlZUNhcFRvb0hpZ2hFcnJvcih7IG1heEZlZVBlckdhczogZ2FzUHJpY2UgfSk7XG59XG5cbi8vIG5vZGVfbW9kdWxlcy92aWVtL19lc20vdXRpbHMvdHJhbnNhY3Rpb24vc2VyaWFsaXplQWNjZXNzTGlzdC5qc1xuaW5pdF9hZGRyZXNzKCk7XG5pbml0X3RyYW5zYWN0aW9uKCk7XG5pbml0X2lzQWRkcmVzcygpO1xuZnVuY3Rpb24gc2VyaWFsaXplQWNjZXNzTGlzdChhY2Nlc3NMaXN0KSB7XG4gIGlmICghYWNjZXNzTGlzdCB8fCBhY2Nlc3NMaXN0Lmxlbmd0aCA9PT0gMClcbiAgICByZXR1cm4gW107XG4gIGNvbnN0IHNlcmlhbGl6ZWRBY2Nlc3NMaXN0ID0gW107XG4gIGZvciAobGV0IGkgPSAwO2kgPCBhY2Nlc3NMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgeyBhZGRyZXNzLCBzdG9yYWdlS2V5cyB9ID0gYWNjZXNzTGlzdFtpXTtcbiAgICBmb3IgKGxldCBqID0gMDtqIDwgc3RvcmFnZUtleXMubGVuZ3RoOyBqKyspIHtcbiAgICAgIGlmIChzdG9yYWdlS2V5c1tqXS5sZW5ndGggLSAyICE9PSA2NCkge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFN0b3JhZ2VLZXlTaXplRXJyb3IoeyBzdG9yYWdlS2V5OiBzdG9yYWdlS2V5c1tqXSB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFpc0FkZHJlc3MoYWRkcmVzcywgeyBzdHJpY3Q6IGZhbHNlIH0pKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFkZHJlc3NFcnJvcih7IGFkZHJlc3MgfSk7XG4gICAgfVxuICAgIHNlcmlhbGl6ZWRBY2Nlc3NMaXN0LnB1c2goW2FkZHJlc3MsIHN0b3JhZ2VLZXlzXSk7XG4gIH1cbiAgcmV0dXJuIHNlcmlhbGl6ZWRBY2Nlc3NMaXN0O1xufVxuXG4vLyBub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL3RyYW5zYWN0aW9uL3NlcmlhbGl6ZVRyYW5zYWN0aW9uLmpzXG5mdW5jdGlvbiBzZXJpYWxpemVUcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgc2lnbmF0dXJlKSB7XG4gIGNvbnN0IHR5cGUgPSBnZXRUcmFuc2FjdGlvblR5cGUodHJhbnNhY3Rpb24pO1xuICBpZiAodHlwZSA9PT0gXCJlaXAxNTU5XCIpXG4gICAgcmV0dXJuIHNlcmlhbGl6ZVRyYW5zYWN0aW9uRUlQMTU1OSh0cmFuc2FjdGlvbiwgc2lnbmF0dXJlKTtcbiAgaWYgKHR5cGUgPT09IFwiZWlwMjkzMFwiKVxuICAgIHJldHVybiBzZXJpYWxpemVUcmFuc2FjdGlvbkVJUDI5MzAodHJhbnNhY3Rpb24sIHNpZ25hdHVyZSk7XG4gIGlmICh0eXBlID09PSBcImVpcDQ4NDRcIilcbiAgICByZXR1cm4gc2VyaWFsaXplVHJhbnNhY3Rpb25FSVA0ODQ0KHRyYW5zYWN0aW9uLCBzaWduYXR1cmUpO1xuICBpZiAodHlwZSA9PT0gXCJlaXA3NzAyXCIpXG4gICAgcmV0dXJuIHNlcmlhbGl6ZVRyYW5zYWN0aW9uRUlQNzcwMih0cmFuc2FjdGlvbiwgc2lnbmF0dXJlKTtcbiAgcmV0dXJuIHNlcmlhbGl6ZVRyYW5zYWN0aW9uTGVnYWN5KHRyYW5zYWN0aW9uLCBzaWduYXR1cmUpO1xufVxuZnVuY3Rpb24gc2VyaWFsaXplVHJhbnNhY3Rpb25FSVA3NzAyKHRyYW5zYWN0aW9uLCBzaWduYXR1cmUpIHtcbiAgY29uc3QgeyBhdXRob3JpemF0aW9uTGlzdCwgY2hhaW5JZCwgZ2FzLCBub25jZSwgdG8sIHZhbHVlLCBtYXhGZWVQZXJHYXMsIG1heFByaW9yaXR5RmVlUGVyR2FzLCBhY2Nlc3NMaXN0LCBkYXRhIH0gPSB0cmFuc2FjdGlvbjtcbiAgYXNzZXJ0VHJhbnNhY3Rpb25FSVA3NzAyKHRyYW5zYWN0aW9uKTtcbiAgY29uc3Qgc2VyaWFsaXplZEFjY2Vzc0xpc3QgPSBzZXJpYWxpemVBY2Nlc3NMaXN0KGFjY2Vzc0xpc3QpO1xuICBjb25zdCBzZXJpYWxpemVkQXV0aG9yaXphdGlvbkxpc3QgPSBzZXJpYWxpemVBdXRob3JpemF0aW9uTGlzdChhdXRob3JpemF0aW9uTGlzdCk7XG4gIHJldHVybiBjb25jYXRIZXgoW1xuICAgIFwiMHgwNFwiLFxuICAgIHRvUmxwKFtcbiAgICAgIG51bWJlclRvSGV4KGNoYWluSWQpLFxuICAgICAgbm9uY2UgPyBudW1iZXJUb0hleChub25jZSkgOiBcIjB4XCIsXG4gICAgICBtYXhQcmlvcml0eUZlZVBlckdhcyA/IG51bWJlclRvSGV4KG1heFByaW9yaXR5RmVlUGVyR2FzKSA6IFwiMHhcIixcbiAgICAgIG1heEZlZVBlckdhcyA/IG51bWJlclRvSGV4KG1heEZlZVBlckdhcykgOiBcIjB4XCIsXG4gICAgICBnYXMgPyBudW1iZXJUb0hleChnYXMpIDogXCIweFwiLFxuICAgICAgdG8gPz8gXCIweFwiLFxuICAgICAgdmFsdWUgPyBudW1iZXJUb0hleCh2YWx1ZSkgOiBcIjB4XCIsXG4gICAgICBkYXRhID8/IFwiMHhcIixcbiAgICAgIHNlcmlhbGl6ZWRBY2Nlc3NMaXN0LFxuICAgICAgc2VyaWFsaXplZEF1dGhvcml6YXRpb25MaXN0LFxuICAgICAgLi4udG9ZUGFyaXR5U2lnbmF0dXJlQXJyYXkodHJhbnNhY3Rpb24sIHNpZ25hdHVyZSlcbiAgICBdKVxuICBdKTtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZVRyYW5zYWN0aW9uRUlQNDg0NCh0cmFuc2FjdGlvbiwgc2lnbmF0dXJlKSB7XG4gIGNvbnN0IHsgY2hhaW5JZCwgZ2FzLCBub25jZSwgdG8sIHZhbHVlLCBtYXhGZWVQZXJCbG9iR2FzLCBtYXhGZWVQZXJHYXMsIG1heFByaW9yaXR5RmVlUGVyR2FzLCBhY2Nlc3NMaXN0LCBkYXRhIH0gPSB0cmFuc2FjdGlvbjtcbiAgYXNzZXJ0VHJhbnNhY3Rpb25FSVA0ODQ0KHRyYW5zYWN0aW9uKTtcbiAgbGV0IGJsb2JWZXJzaW9uZWRIYXNoZXMgPSB0cmFuc2FjdGlvbi5ibG9iVmVyc2lvbmVkSGFzaGVzO1xuICBsZXQgc2lkZWNhcnMgPSB0cmFuc2FjdGlvbi5zaWRlY2FycztcbiAgaWYgKHRyYW5zYWN0aW9uLmJsb2JzICYmICh0eXBlb2YgYmxvYlZlcnNpb25lZEhhc2hlcyA9PT0gXCJ1bmRlZmluZWRcIiB8fCB0eXBlb2Ygc2lkZWNhcnMgPT09IFwidW5kZWZpbmVkXCIpKSB7XG4gICAgY29uc3QgYmxvYnMyID0gdHlwZW9mIHRyYW5zYWN0aW9uLmJsb2JzWzBdID09PSBcInN0cmluZ1wiID8gdHJhbnNhY3Rpb24uYmxvYnMgOiB0cmFuc2FjdGlvbi5ibG9icy5tYXAoKHgpID0+IGJ5dGVzVG9IZXgoeCkpO1xuICAgIGNvbnN0IGt6ZyA9IHRyYW5zYWN0aW9uLmt6ZztcbiAgICBjb25zdCBjb21taXRtZW50czIgPSBibG9ic1RvQ29tbWl0bWVudHMoe1xuICAgICAgYmxvYnM6IGJsb2JzMixcbiAgICAgIGt6Z1xuICAgIH0pO1xuICAgIGlmICh0eXBlb2YgYmxvYlZlcnNpb25lZEhhc2hlcyA9PT0gXCJ1bmRlZmluZWRcIilcbiAgICAgIGJsb2JWZXJzaW9uZWRIYXNoZXMgPSBjb21taXRtZW50c1RvVmVyc2lvbmVkSGFzaGVzKHtcbiAgICAgICAgY29tbWl0bWVudHM6IGNvbW1pdG1lbnRzMlxuICAgICAgfSk7XG4gICAgaWYgKHR5cGVvZiBzaWRlY2FycyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgY29uc3QgcHJvb2ZzMiA9IGJsb2JzVG9Qcm9vZnMoeyBibG9iczogYmxvYnMyLCBjb21taXRtZW50czogY29tbWl0bWVudHMyLCBremcgfSk7XG4gICAgICBzaWRlY2FycyA9IHRvQmxvYlNpZGVjYXJzKHsgYmxvYnM6IGJsb2JzMiwgY29tbWl0bWVudHM6IGNvbW1pdG1lbnRzMiwgcHJvb2ZzOiBwcm9vZnMyIH0pO1xuICAgIH1cbiAgfVxuICBjb25zdCBzZXJpYWxpemVkQWNjZXNzTGlzdCA9IHNlcmlhbGl6ZUFjY2Vzc0xpc3QoYWNjZXNzTGlzdCk7XG4gIGNvbnN0IHNlcmlhbGl6ZWRUcmFuc2FjdGlvbiA9IFtcbiAgICBudW1iZXJUb0hleChjaGFpbklkKSxcbiAgICBub25jZSA/IG51bWJlclRvSGV4KG5vbmNlKSA6IFwiMHhcIixcbiAgICBtYXhQcmlvcml0eUZlZVBlckdhcyA/IG51bWJlclRvSGV4KG1heFByaW9yaXR5RmVlUGVyR2FzKSA6IFwiMHhcIixcbiAgICBtYXhGZWVQZXJHYXMgPyBudW1iZXJUb0hleChtYXhGZWVQZXJHYXMpIDogXCIweFwiLFxuICAgIGdhcyA/IG51bWJlclRvSGV4KGdhcykgOiBcIjB4XCIsXG4gICAgdG8gPz8gXCIweFwiLFxuICAgIHZhbHVlID8gbnVtYmVyVG9IZXgodmFsdWUpIDogXCIweFwiLFxuICAgIGRhdGEgPz8gXCIweFwiLFxuICAgIHNlcmlhbGl6ZWRBY2Nlc3NMaXN0LFxuICAgIG1heEZlZVBlckJsb2JHYXMgPyBudW1iZXJUb0hleChtYXhGZWVQZXJCbG9iR2FzKSA6IFwiMHhcIixcbiAgICBibG9iVmVyc2lvbmVkSGFzaGVzID8/IFtdLFxuICAgIC4uLnRvWVBhcml0eVNpZ25hdHVyZUFycmF5KHRyYW5zYWN0aW9uLCBzaWduYXR1cmUpXG4gIF07XG4gIGNvbnN0IGJsb2JzID0gW107XG4gIGNvbnN0IGNvbW1pdG1lbnRzID0gW107XG4gIGNvbnN0IHByb29mcyA9IFtdO1xuICBpZiAoc2lkZWNhcnMpXG4gICAgZm9yIChsZXQgaSA9IDA7aSA8IHNpZGVjYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCB7IGJsb2IsIGNvbW1pdG1lbnQsIHByb29mIH0gPSBzaWRlY2Fyc1tpXTtcbiAgICAgIGJsb2JzLnB1c2goYmxvYik7XG4gICAgICBjb21taXRtZW50cy5wdXNoKGNvbW1pdG1lbnQpO1xuICAgICAgcHJvb2ZzLnB1c2gocHJvb2YpO1xuICAgIH1cbiAgcmV0dXJuIGNvbmNhdEhleChbXG4gICAgXCIweDAzXCIsXG4gICAgc2lkZWNhcnMgPyB0b1JscChbc2VyaWFsaXplZFRyYW5zYWN0aW9uLCBibG9icywgY29tbWl0bWVudHMsIHByb29mc10pIDogdG9SbHAoc2VyaWFsaXplZFRyYW5zYWN0aW9uKVxuICBdKTtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZVRyYW5zYWN0aW9uRUlQMTU1OSh0cmFuc2FjdGlvbiwgc2lnbmF0dXJlKSB7XG4gIGNvbnN0IHsgY2hhaW5JZCwgZ2FzLCBub25jZSwgdG8sIHZhbHVlLCBtYXhGZWVQZXJHYXMsIG1heFByaW9yaXR5RmVlUGVyR2FzLCBhY2Nlc3NMaXN0LCBkYXRhIH0gPSB0cmFuc2FjdGlvbjtcbiAgYXNzZXJ0VHJhbnNhY3Rpb25FSVAxNTU5KHRyYW5zYWN0aW9uKTtcbiAgY29uc3Qgc2VyaWFsaXplZEFjY2Vzc0xpc3QgPSBzZXJpYWxpemVBY2Nlc3NMaXN0KGFjY2Vzc0xpc3QpO1xuICBjb25zdCBzZXJpYWxpemVkVHJhbnNhY3Rpb24gPSBbXG4gICAgbnVtYmVyVG9IZXgoY2hhaW5JZCksXG4gICAgbm9uY2UgPyBudW1iZXJUb0hleChub25jZSkgOiBcIjB4XCIsXG4gICAgbWF4UHJpb3JpdHlGZWVQZXJHYXMgPyBudW1iZXJUb0hleChtYXhQcmlvcml0eUZlZVBlckdhcykgOiBcIjB4XCIsXG4gICAgbWF4RmVlUGVyR2FzID8gbnVtYmVyVG9IZXgobWF4RmVlUGVyR2FzKSA6IFwiMHhcIixcbiAgICBnYXMgPyBudW1iZXJUb0hleChnYXMpIDogXCIweFwiLFxuICAgIHRvID8/IFwiMHhcIixcbiAgICB2YWx1ZSA/IG51bWJlclRvSGV4KHZhbHVlKSA6IFwiMHhcIixcbiAgICBkYXRhID8/IFwiMHhcIixcbiAgICBzZXJpYWxpemVkQWNjZXNzTGlzdCxcbiAgICAuLi50b1lQYXJpdHlTaWduYXR1cmVBcnJheSh0cmFuc2FjdGlvbiwgc2lnbmF0dXJlKVxuICBdO1xuICByZXR1cm4gY29uY2F0SGV4KFtcbiAgICBcIjB4MDJcIixcbiAgICB0b1JscChzZXJpYWxpemVkVHJhbnNhY3Rpb24pXG4gIF0pO1xufVxuZnVuY3Rpb24gc2VyaWFsaXplVHJhbnNhY3Rpb25FSVAyOTMwKHRyYW5zYWN0aW9uLCBzaWduYXR1cmUpIHtcbiAgY29uc3QgeyBjaGFpbklkLCBnYXMsIGRhdGEsIG5vbmNlLCB0bywgdmFsdWUsIGFjY2Vzc0xpc3QsIGdhc1ByaWNlIH0gPSB0cmFuc2FjdGlvbjtcbiAgYXNzZXJ0VHJhbnNhY3Rpb25FSVAyOTMwKHRyYW5zYWN0aW9uKTtcbiAgY29uc3Qgc2VyaWFsaXplZEFjY2Vzc0xpc3QgPSBzZXJpYWxpemVBY2Nlc3NMaXN0KGFjY2Vzc0xpc3QpO1xuICBjb25zdCBzZXJpYWxpemVkVHJhbnNhY3Rpb24gPSBbXG4gICAgbnVtYmVyVG9IZXgoY2hhaW5JZCksXG4gICAgbm9uY2UgPyBudW1iZXJUb0hleChub25jZSkgOiBcIjB4XCIsXG4gICAgZ2FzUHJpY2UgPyBudW1iZXJUb0hleChnYXNQcmljZSkgOiBcIjB4XCIsXG4gICAgZ2FzID8gbnVtYmVyVG9IZXgoZ2FzKSA6IFwiMHhcIixcbiAgICB0byA/PyBcIjB4XCIsXG4gICAgdmFsdWUgPyBudW1iZXJUb0hleCh2YWx1ZSkgOiBcIjB4XCIsXG4gICAgZGF0YSA/PyBcIjB4XCIsXG4gICAgc2VyaWFsaXplZEFjY2Vzc0xpc3QsXG4gICAgLi4udG9ZUGFyaXR5U2lnbmF0dXJlQXJyYXkodHJhbnNhY3Rpb24sIHNpZ25hdHVyZSlcbiAgXTtcbiAgcmV0dXJuIGNvbmNhdEhleChbXG4gICAgXCIweDAxXCIsXG4gICAgdG9SbHAoc2VyaWFsaXplZFRyYW5zYWN0aW9uKVxuICBdKTtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZVRyYW5zYWN0aW9uTGVnYWN5KHRyYW5zYWN0aW9uLCBzaWduYXR1cmUpIHtcbiAgY29uc3QgeyBjaGFpbklkID0gMCwgZ2FzLCBkYXRhLCBub25jZSwgdG8sIHZhbHVlLCBnYXNQcmljZSB9ID0gdHJhbnNhY3Rpb247XG4gIGFzc2VydFRyYW5zYWN0aW9uTGVnYWN5KHRyYW5zYWN0aW9uKTtcbiAgbGV0IHNlcmlhbGl6ZWRUcmFuc2FjdGlvbiA9IFtcbiAgICBub25jZSA/IG51bWJlclRvSGV4KG5vbmNlKSA6IFwiMHhcIixcbiAgICBnYXNQcmljZSA/IG51bWJlclRvSGV4KGdhc1ByaWNlKSA6IFwiMHhcIixcbiAgICBnYXMgPyBudW1iZXJUb0hleChnYXMpIDogXCIweFwiLFxuICAgIHRvID8/IFwiMHhcIixcbiAgICB2YWx1ZSA/IG51bWJlclRvSGV4KHZhbHVlKSA6IFwiMHhcIixcbiAgICBkYXRhID8/IFwiMHhcIlxuICBdO1xuICBpZiAoc2lnbmF0dXJlKSB7XG4gICAgY29uc3QgdiA9ICgoKSA9PiB7XG4gICAgICBpZiAoc2lnbmF0dXJlLnYgPj0gMzVuKSB7XG4gICAgICAgIGNvbnN0IGluZmVycmVkQ2hhaW5JZCA9IChzaWduYXR1cmUudiAtIDM1bikgLyAybjtcbiAgICAgICAgaWYgKGluZmVycmVkQ2hhaW5JZCA+IDApXG4gICAgICAgICAgcmV0dXJuIHNpZ25hdHVyZS52O1xuICAgICAgICByZXR1cm4gMjduICsgKHNpZ25hdHVyZS52ID09PSAzNW4gPyAwbiA6IDFuKTtcbiAgICAgIH1cbiAgICAgIGlmIChjaGFpbklkID4gMClcbiAgICAgICAgcmV0dXJuIEJpZ0ludChjaGFpbklkICogMikgKyBCaWdJbnQoMzVuICsgc2lnbmF0dXJlLnYgLSAyN24pO1xuICAgICAgY29uc3QgdjIgPSAyN24gKyAoc2lnbmF0dXJlLnYgPT09IDI3biA/IDBuIDogMW4pO1xuICAgICAgaWYgKHNpZ25hdHVyZS52ICE9PSB2MilcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRMZWdhY3lWRXJyb3IoeyB2OiBzaWduYXR1cmUudiB9KTtcbiAgICAgIHJldHVybiB2MjtcbiAgICB9KSgpO1xuICAgIGNvbnN0IHIgPSB0cmltKHNpZ25hdHVyZS5yKTtcbiAgICBjb25zdCBzID0gdHJpbShzaWduYXR1cmUucyk7XG4gICAgc2VyaWFsaXplZFRyYW5zYWN0aW9uID0gW1xuICAgICAgLi4uc2VyaWFsaXplZFRyYW5zYWN0aW9uLFxuICAgICAgbnVtYmVyVG9IZXgodiksXG4gICAgICByID09PSBcIjB4MDBcIiA/IFwiMHhcIiA6IHIsXG4gICAgICBzID09PSBcIjB4MDBcIiA/IFwiMHhcIiA6IHNcbiAgICBdO1xuICB9IGVsc2UgaWYgKGNoYWluSWQgPiAwKSB7XG4gICAgc2VyaWFsaXplZFRyYW5zYWN0aW9uID0gW1xuICAgICAgLi4uc2VyaWFsaXplZFRyYW5zYWN0aW9uLFxuICAgICAgbnVtYmVyVG9IZXgoY2hhaW5JZCksXG4gICAgICBcIjB4XCIsXG4gICAgICBcIjB4XCJcbiAgICBdO1xuICB9XG4gIHJldHVybiB0b1JscChzZXJpYWxpemVkVHJhbnNhY3Rpb24pO1xufVxuZnVuY3Rpb24gdG9ZUGFyaXR5U2lnbmF0dXJlQXJyYXkodHJhbnNhY3Rpb24sIHNpZ25hdHVyZV8pIHtcbiAgY29uc3Qgc2lnbmF0dXJlID0gc2lnbmF0dXJlXyA/PyB0cmFuc2FjdGlvbjtcbiAgY29uc3QgeyB2LCB5UGFyaXR5IH0gPSBzaWduYXR1cmU7XG4gIGlmICh0eXBlb2Ygc2lnbmF0dXJlLnIgPT09IFwidW5kZWZpbmVkXCIpXG4gICAgcmV0dXJuIFtdO1xuICBpZiAodHlwZW9mIHNpZ25hdHVyZS5zID09PSBcInVuZGVmaW5lZFwiKVxuICAgIHJldHVybiBbXTtcbiAgaWYgKHR5cGVvZiB2ID09PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiB5UGFyaXR5ID09PSBcInVuZGVmaW5lZFwiKVxuICAgIHJldHVybiBbXTtcbiAgY29uc3QgciA9IHRyaW0oc2lnbmF0dXJlLnIpO1xuICBjb25zdCBzID0gdHJpbShzaWduYXR1cmUucyk7XG4gIGNvbnN0IHlQYXJpdHlfID0gKCgpID0+IHtcbiAgICBpZiAodHlwZW9mIHlQYXJpdHkgPT09IFwibnVtYmVyXCIpXG4gICAgICByZXR1cm4geVBhcml0eSA/IG51bWJlclRvSGV4KDEpIDogXCIweFwiO1xuICAgIGlmICh2ID09PSAwbilcbiAgICAgIHJldHVybiBcIjB4XCI7XG4gICAgaWYgKHYgPT09IDFuKVxuICAgICAgcmV0dXJuIG51bWJlclRvSGV4KDEpO1xuICAgIHJldHVybiB2ID09PSAyN24gPyBcIjB4XCIgOiBudW1iZXJUb0hleCgxKTtcbiAgfSkoKTtcbiAgcmV0dXJuIFt5UGFyaXR5XywgciA9PT0gXCIweDAwXCIgPyBcIjB4XCIgOiByLCBzID09PSBcIjB4MDBcIiA/IFwiMHhcIiA6IHNdO1xufVxuXG4vLyBub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL2F1dGhvcml6YXRpb24vc2VyaWFsaXplQXV0aG9yaXphdGlvbkxpc3QuanNcbmZ1bmN0aW9uIHNlcmlhbGl6ZUF1dGhvcml6YXRpb25MaXN0KGF1dGhvcml6YXRpb25MaXN0KSB7XG4gIGlmICghYXV0aG9yaXphdGlvbkxpc3QgfHwgYXV0aG9yaXphdGlvbkxpc3QubGVuZ3RoID09PSAwKVxuICAgIHJldHVybiBbXTtcbiAgY29uc3Qgc2VyaWFsaXplZEF1dGhvcml6YXRpb25MaXN0ID0gW107XG4gIGZvciAoY29uc3QgYXV0aG9yaXphdGlvbiBvZiBhdXRob3JpemF0aW9uTGlzdCkge1xuICAgIGNvbnN0IHsgY2hhaW5JZCwgbm9uY2UsIC4uLnNpZ25hdHVyZSB9ID0gYXV0aG9yaXphdGlvbjtcbiAgICBjb25zdCBjb250cmFjdEFkZHJlc3MgPSBhdXRob3JpemF0aW9uLmFkZHJlc3M7XG4gICAgc2VyaWFsaXplZEF1dGhvcml6YXRpb25MaXN0LnB1c2goW1xuICAgICAgY2hhaW5JZCA/IHRvSGV4KGNoYWluSWQpIDogXCIweFwiLFxuICAgICAgY29udHJhY3RBZGRyZXNzLFxuICAgICAgbm9uY2UgPyB0b0hleChub25jZSkgOiBcIjB4XCIsXG4gICAgICAuLi50b1lQYXJpdHlTaWduYXR1cmVBcnJheSh7fSwgc2lnbmF0dXJlKVxuICAgIF0pO1xuICB9XG4gIHJldHVybiBzZXJpYWxpemVkQXV0aG9yaXphdGlvbkxpc3Q7XG59XG4vLyBub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL2RhdGEvaXNCeXRlcy5qc1xuZnVuY3Rpb24gaXNCeXRlczIodmFsdWUpIHtcbiAgaWYgKCF2YWx1ZSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAoIShcIkJZVEVTX1BFUl9FTEVNRU5UXCIgaW4gdmFsdWUpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIHZhbHVlLkJZVEVTX1BFUl9FTEVNRU5UID09PSAxICYmIHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUgPT09IFwiVWludDhBcnJheVwiO1xufVxuXG4vLyBub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL2FkZHJlc3MvZ2V0Q29udHJhY3RBZGRyZXNzLmpzXG5pbml0X3BhZCgpO1xuaW5pdF9zbGljZSgpO1xuaW5pdF90b0J5dGVzKCk7XG5pbml0X2tlY2NhazI1NigpO1xuaW5pdF9nZXRBZGRyZXNzKCk7XG5mdW5jdGlvbiBnZXRDcmVhdGUyQWRkcmVzcyhvcHRzKSB7XG4gIGNvbnN0IGZyb20gPSB0b0J5dGVzMihnZXRBZGRyZXNzKG9wdHMuZnJvbSkpO1xuICBjb25zdCBzYWx0ID0gcGFkKGlzQnl0ZXMyKG9wdHMuc2FsdCkgPyBvcHRzLnNhbHQgOiB0b0J5dGVzMihvcHRzLnNhbHQpLCB7XG4gICAgc2l6ZTogMzJcbiAgfSk7XG4gIGNvbnN0IGJ5dGVjb2RlSGFzaCA9ICgoKSA9PiB7XG4gICAgaWYgKFwiYnl0ZWNvZGVIYXNoXCIgaW4gb3B0cykge1xuICAgICAgaWYgKGlzQnl0ZXMyKG9wdHMuYnl0ZWNvZGVIYXNoKSlcbiAgICAgICAgcmV0dXJuIG9wdHMuYnl0ZWNvZGVIYXNoO1xuICAgICAgcmV0dXJuIHRvQnl0ZXMyKG9wdHMuYnl0ZWNvZGVIYXNoKTtcbiAgICB9XG4gICAgcmV0dXJuIGtlY2NhazI1NihvcHRzLmJ5dGVjb2RlLCBcImJ5dGVzXCIpO1xuICB9KSgpO1xuICByZXR1cm4gZ2V0QWRkcmVzcyhzbGljZShrZWNjYWsyNTYoY29uY2F0KFt0b0J5dGVzMihcIjB4ZmZcIiksIGZyb20sIHNhbHQsIGJ5dGVjb2RlSGFzaF0pKSwgMTIpKTtcbn1cblxuLy8gbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS9pbmRleC5qc1xuaW5pdF9lbmNvZGVBYmlQYXJhbWV0ZXJzKCk7XG5pbml0X2VuY29kZUZ1bmN0aW9uRGF0YSgpO1xuaW5pdF9rZWNjYWsyNTYoKTtcblxuLy8gc3JjL3V0aWxzL2NhbGN1bGF0ZVdhbGxldEFkZHJlc3MudHNcbnZhciBDT05UUkFDVF9BRERSRVNTRVMgPSB7XG4gIEFDQ09VTlRfSU1QTEVNRU5UQVRJT046IFwiMHgwMDA2MDUwMTY4REUyNTVhODY3MkFDYUQ0ODIxZTcyMUNCQTQ0MzM3XCIsXG4gIEFUVEVTVEVSOiBcIjB4MDAwNDc0MzkyYTljZDg2YTQ2ODczNTRmMUNlMjk2NEI1MmU5NzQ4NFwiLFxuICBCT09UU1RSQVBQRVI6IFwiMHgwMDAwMDAwMEQzMjU0NDUyYTkwOUU0ZWVENDc0NTVBZjdFMjdDMjg5XCIsXG4gIEZBQ1RPUlk6IFwiMHgwMEU1OERGNzBGYUI5ODNhMzI0YzRDMDY4YzgyZDIwNDA3NTc5RmFDXCIsXG4gIFJFR0lTVFJZOiBcIjB4MDAwMDAwMDAwMDY5RTJhMTg3QUVGRmI4NTJiRjNjQ2RDOTUxNTFCMlwiLFxuICBXRUJBVVRITl9WQUxJREFUT1I6IFwiMHhiQTQ1YTJCRmI4RGUzRDI0Y0E5RDdGMUI1NTFFMTRkRkY1ZDY5MEZkXCJcbn07XG5mdW5jdGlvbiBjYWxjdWxhdGVXYWxsZXRBZGRyZXNzKHBhcmFtcykge1xuICBjb25zdCB7IHB1YmxpY0tleSwgY3JlZGVudGlhbElkLCBpbmRleCA9IDBuIH0gPSBwYXJhbXM7XG4gIGlmICghcHVibGljS2V5LnN0YXJ0c1dpdGgoXCIweFwiKSB8fCBwdWJsaWNLZXkubGVuZ3RoICE9PSAxMzApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHB1YmxpYyBrZXk6IG11c3QgYmUgNjQtYnl0ZSBoZXggc3RyaW5nICgweCArIDEyOCBjaGFycylcIik7XG4gIH1cbiAgY29uc3QgcHViS2V5WCA9IGAweCR7cHVibGljS2V5LnNsaWNlKDIsIDY2KX1gO1xuICBjb25zdCBwdWJLZXlZID0gYDB4JHtwdWJsaWNLZXkuc2xpY2UoNjYsIDEzMCl9YDtcbiAgY29uc3Qgd2ViQXV0aG5EYXRhID0ge1xuICAgIHB1YktleVg6IEJpZ0ludChwdWJLZXlYKSxcbiAgICBwdWJLZXlZOiBCaWdJbnQocHViS2V5WSlcbiAgfTtcbiAgaWYgKCF2YWxpZGF0ZVdlYkF1dGhuS2V5KHdlYkF1dGhuRGF0YSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIFdlYkF1dGhuIGtleTogY29vcmRpbmF0ZXMgYXJlIG5vdCBvbiBzZWNwMjU2cjEgY3VydmVcIik7XG4gIH1cbiAgY29uc3QgYXV0aGVudGljYXRvcklkSGFzaCA9IGdlbmVyYXRlQXV0aGVudGljYXRvcklkSGFzaChjcmVkZW50aWFsSWQpO1xuICByZXR1cm4gY2FsY3VsYXRlQWRkcmVzc0ludGVybmFsKHtcbiAgICBhdXRoZW50aWNhdG9ySWRIYXNoLFxuICAgIGluZGV4LFxuICAgIHdlYkF1dGhuRGF0YVxuICB9KTtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlQXV0aGVudGljYXRvcklkSGFzaChjcmVkZW50aWFsSWQpIHtcbiAgY29uc3QgcGFkZGluZyA9IFwiPVwiLnJlcGVhdCgoNCAtIGNyZWRlbnRpYWxJZC5sZW5ndGggJSA0KSAlIDQpO1xuICBjb25zdCBiYXNlNjQgPSBjcmVkZW50aWFsSWQucmVwbGFjZSgvLS9nLCBcIitcIikucmVwbGFjZSgvXy9nLCBcIi9cIikgKyBwYWRkaW5nO1xuICBjb25zdCBiaW5hcnlTdHJpbmcgPSBhdG9iKGJhc2U2NCk7XG4gIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYmluYXJ5U3RyaW5nLmxlbmd0aCk7XG4gIGZvciAobGV0IGkgPSAwO2kgPCBiaW5hcnlTdHJpbmcubGVuZ3RoOyBpKyspIHtcbiAgICBieXRlc1tpXSA9IGJpbmFyeVN0cmluZy5jaGFyQ29kZUF0KGkpO1xuICB9XG4gIHJldHVybiBrZWNjYWsyNTYoYnl0ZXMpO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVXZWJBdXRobktleSh3ZWJBdXRobkRhdGEpIHtcbiAgY29uc3QgU0VDUDI1NlIxX1AgPSAweGZmZmZmZmZmMDAwMDAwMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZuO1xuICBjb25zdCBTRUNQMjU2UjFfQiA9IDB4NWFjNjM1ZDhhYTNhOTNlN2IzZWJiZDU1NzY5ODg2YmM2NTFkMDZiMGNjNTNiMGY2M2JjZTNjM2UyN2QyNjA0Ym47XG4gIGNvbnN0IHsgcHViS2V5WCwgcHViS2V5WSB9ID0gd2ViQXV0aG5EYXRhO1xuICBpZiAocHViS2V5WCA9PT0gMG4gfHwgcHViS2V5WSA9PT0gMG4gfHwgcHViS2V5WCA+PSBTRUNQMjU2UjFfUCB8fCBwdWJLZXlZID49IFNFQ1AyNTZSMV9QKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHlTcXVhcmVkID0gcHViS2V5WSAqIHB1YktleVkgJSBTRUNQMjU2UjFfUDtcbiAgY29uc3QgeEN1YmVkID0gcHViS2V5WCAqIHB1YktleVggKiBwdWJLZXlYICUgU0VDUDI1NlIxX1A7XG4gIGNvbnN0IHRocmVlWCA9IDNuICogcHViS2V5WCAlIFNFQ1AyNTZSMV9QO1xuICBjb25zdCByaWdodFNpZGUgPSAoeEN1YmVkICsgU0VDUDI1NlIxX1AgLSB0aHJlZVggKyBTRUNQMjU2UjFfQikgJSBTRUNQMjU2UjFfUDtcbiAgcmV0dXJuIHlTcXVhcmVkID09PSByaWdodFNpZGU7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVBZGRyZXNzSW50ZXJuYWwocGFyYW1zKSB7XG4gIGNvbnN0IHsgd2ViQXV0aG5EYXRhLCBhdXRoZW50aWNhdG9ySWRIYXNoLCBpbmRleCB9ID0gcGFyYW1zO1xuICBjb25zdCBmYWN0b3J5QWRkcmVzcyA9IENPTlRSQUNUX0FERFJFU1NFUy5GQUNUT1JZO1xuICBjb25zdCBhY2NvdW50SW1wbGVtZW50YXRpb24gPSBDT05UUkFDVF9BRERSRVNTRVMuQUNDT1VOVF9JTVBMRU1FTlRBVElPTjtcbiAgY29uc3Qgd2ViQXV0aG5WYWxpZGF0b3IgPSBDT05UUkFDVF9BRERSRVNTRVMuV0VCQVVUSE5fVkFMSURBVE9SO1xuICBjb25zdCBhdHRlc3RlciA9IENPTlRSQUNUX0FERFJFU1NFUy5BVFRFU1RFUjtcbiAgY29uc3QgYm9vdHN0cmFwcGVyID0gQ09OVFJBQ1RfQUREUkVTU0VTLkJPT1RTVFJBUFBFUjtcbiAgY29uc3QgcmVnaXN0cnkgPSBDT05UUkFDVF9BRERSRVNTRVMuUkVHSVNUUlk7XG4gIGNvbnN0IHNhbHQgPSBrZWNjYWsyNTYoZW5jb2RlUGFja2VkKFtcInVpbnQyNTZcIiwgXCJ1aW50MjU2XCIsIFwiYnl0ZXMzMlwiLCBcInVpbnQyNTZcIl0sIFt3ZWJBdXRobkRhdGEucHViS2V5WCwgd2ViQXV0aG5EYXRhLnB1YktleVksIGF1dGhlbnRpY2F0b3JJZEhhc2gsIGluZGV4XSkpO1xuICBjb25zdCB2YWxpZGF0b3JJbml0RGF0YSA9IGVuY29kZUFiaVBhcmFtZXRlcnMoW1xuICAgIHtcbiAgICAgIGNvbXBvbmVudHM6IFtcbiAgICAgICAgeyBuYW1lOiBcInB1YktleVhcIiwgdHlwZTogXCJ1aW50MjU2XCIgfSxcbiAgICAgICAgeyBuYW1lOiBcInB1YktleVlcIiwgdHlwZTogXCJ1aW50MjU2XCIgfVxuICAgICAgXSxcbiAgICAgIHR5cGU6IFwidHVwbGVcIlxuICAgIH0sXG4gICAgeyB0eXBlOiBcImJ5dGVzMzJcIiB9XG4gIF0sIFt3ZWJBdXRobkRhdGEsIGF1dGhlbnRpY2F0b3JJZEhhc2hdKTtcbiAgY29uc3QgcmVnaXN0cnlDb25maWcgPSB7XG4gICAgYXR0ZXN0ZXJzOiBbYXR0ZXN0ZXJdLFxuICAgIHJlZ2lzdHJ5LFxuICAgIHRocmVzaG9sZDogMW5cbiAgfTtcbiAgY29uc3QgYm9vdHN0cmFwQ2FsbCA9IGVuY29kZUZ1bmN0aW9uRGF0YSh7XG4gICAgYWJpOiBbXG4gICAgICB7XG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgIHsgbmFtZTogXCJ2YWxpZGF0b3JcIiwgdHlwZTogXCJhZGRyZXNzXCIgfSxcbiAgICAgICAgICB7IG5hbWU6IFwidmFsaWRhdG9ySW5pdERhdGFcIiwgdHlwZTogXCJieXRlc1wiIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgY29tcG9uZW50czogW1xuICAgICAgICAgICAgICB7IG5hbWU6IFwicmVnaXN0cnlcIiwgdHlwZTogXCJhZGRyZXNzXCIgfSxcbiAgICAgICAgICAgICAgeyBuYW1lOiBcImF0dGVzdGVyc1wiLCB0eXBlOiBcImFkZHJlc3NbXVwiIH0sXG4gICAgICAgICAgICAgIHsgbmFtZTogXCJ0aHJlc2hvbGRcIiwgdHlwZTogXCJ1aW50OFwiIH1cbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBuYW1lOiBcInJlZ2lzdHJ5Q29uZmlnXCIsXG4gICAgICAgICAgICB0eXBlOiBcInR1cGxlXCJcbiAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIG5hbWU6IFwiaW5pdE5leHVzV2l0aFNpbmdsZVZhbGlkYXRvclwiLFxuICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCJcbiAgICAgIH1cbiAgICBdLFxuICAgIGFyZ3M6IFt3ZWJBdXRoblZhbGlkYXRvciwgdmFsaWRhdG9ySW5pdERhdGEsIHJlZ2lzdHJ5Q29uZmlnXSxcbiAgICBmdW5jdGlvbk5hbWU6IFwiaW5pdE5leHVzV2l0aFNpbmdsZVZhbGlkYXRvclwiXG4gIH0pO1xuICBjb25zdCBpbml0RGF0YSA9IGVuY29kZUFiaVBhcmFtZXRlcnMoW3sgdHlwZTogXCJhZGRyZXNzXCIgfSwgeyB0eXBlOiBcImJ5dGVzXCIgfV0sIFtib290c3RyYXBwZXIsIGJvb3RzdHJhcENhbGxdKTtcbiAgcmV0dXJuIHByZWRpY3RQcm94eUFkZHJlc3MoYWNjb3VudEltcGxlbWVudGF0aW9uLCBzYWx0LCBpbml0RGF0YSwgZmFjdG9yeUFkZHJlc3MpO1xufVxuZnVuY3Rpb24gcHJlZGljdFByb3h5QWRkcmVzcyhpbXBsZW1lbnRhdGlvbiwgc2FsdCwgaW5pdERhdGEsIGRlcGxveWVyKSB7XG4gIGNvbnN0IGluaXRpYWxpemVDYWxsID0gZW5jb2RlRnVuY3Rpb25EYXRhKHtcbiAgICBhYmk6IFtcbiAgICAgIHtcbiAgICAgICAgaW5wdXRzOiBbeyBuYW1lOiBcImRhdGFcIiwgdHlwZTogXCJieXRlc1wiIH1dLFxuICAgICAgICBuYW1lOiBcImluaXRpYWxpemVBY2NvdW50XCIsXG4gICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIlxuICAgICAgfVxuICAgIF0sXG4gICAgYXJnczogW2luaXREYXRhXSxcbiAgICBmdW5jdGlvbk5hbWU6IFwiaW5pdGlhbGl6ZUFjY291bnRcIlxuICB9KTtcbiAgY29uc3QgY29uc3RydWN0b3JBcmdzID0gZW5jb2RlQWJpUGFyYW1ldGVycyhbeyB0eXBlOiBcImFkZHJlc3NcIiB9LCB7IHR5cGU6IFwiYnl0ZXNcIiB9XSwgW2ltcGxlbWVudGF0aW9uLCBpbml0aWFsaXplQ2FsbF0pO1xuICBjb25zdCBuZXh1c1Byb3h5Q3JlYXRpb25Db2RlID0gXCIweDYwODA2MDQwNTI2MTAyYzg4MDM4MDM4MDYxMDAxNDgxNjEwMThjNTY1YjkyODMzOTgxMDE2MDQwODI4MjAzMTI2MTAxODg1NzgxNTE2MDAxNjAwMTYwYTAxYjAzODExNjkyOTA5MTkwODM4MzAzNjEwMTg4NTc2MDIwODEwMTUxOTA2MDAxNjAwMTYwNDAxYjAzODIxMTYxMDE4ODU3MDE5MjgxNjAxZjg1MDExMjE1NjEwMTg4NTc4MzUxNjEwMDZlNjEwMDY5ODI2MTAxYzU1NjViNjEwMThjNTY1Yjk0ODE4NjUyNjAyMDg2MDE5MzYwMjA4MzgzMDEwMTExNjEwMTg4NTc4MTVmOTI2MDIwODA5MzAxODY1ZTg2MDEwMTUyNjAwMTdmOTBiNzcyYzJjYjhhNTFhYTdhOGE2NWZjMjM1NDNjNmQwMjJkNWIzZjhlMmI5MmVlZDc5ZmJhN2VlZjgyOTMwMDVkODIzYjE1NjEwMTc2NTc3ZjM2MDg5NGExM2JhMWEzMjEwNjY3YzgyODQ5MmRiOThkY2EzZTIwNzZjYzM3MzVhOTIwYTNjYTUwNWQzODJiYmM4MDU0NjAwMTYwMDE2MGEwMWIwMzE5MTY4MjE3OTA1NTdmYmM3Y2Q3NWEyMGVlMjdmZDlhZGViYWIzMjA0MWY3NTUyMTRkYmM2YmZmYTkwY2MwMjI1YjM5ZGEyZTVjMmQzYjVmODBhMjgyNTExNTYxMDE1ZTU3NWY4MDkxNjEwMTQ2OTQ1MTkwODQ1YWY0M2QxNTYxMDE1NjU3M2Q5MTYxMDEzNzYxMDA2OTg0NjEwMWM1NTY1YjkyODM1MjNkNWY2MDIwODUwMTNlNjEwMWUwNTY1YjUwNWI2MDQwNTE2MDg5OTA4MTYxMDIzZjgyMzlmMzViNjA2MDkxNjEwMWUwNTY1YjUwNTA1MDM0MTU2MTAxNDg1NzYzYjM5ODk3OWY2MGUwMWI1ZjUyNjAwNDVmZmQ1YjYzNGM5YzhjZTM2MGUwMWI1ZjUyNjAwNDUyNjAyNDVmZmQ1YjVmODBmZDViNjA0MDUxOTE5MDYwMWYwMTYwMWYxOTE2ODIwMTYwMDE2MDAxNjA0MDFiMDM4MTExODM4MjEwMTc2MTAxYjE1NzYwNDA1MjU2NWI2MzRlNDg3YjcxNjBlMDFiNWY1MjYwNDE2MDA0NTI2MDI0NWZmZDViNjAwMTYwMDE2MDQwMWIwMzgxMTE2MTAxYjE1NzYwMWYwMTYwMWYxOTE2NjAyMDAxOTA1NjViOTA2MTAyMDQ1NzUwODA1MTE1NjEwMWY1NTc4MDUxOTA2MDIwMDFmZDViNjNkNmJkYTI3NTYwZTAxYjVmNTI2MDA0NWZmZDViODE1MTE1ODA2MTAyMzU1NzViNjEwMjE1NTc1MDkwNTY1YjYzOTk5NmIzMTU2MGUwMWI1ZjkwODE1MjYwMDE2MDAxNjBhMDFiMDM5MTkwOTExNjYwMDQ1MjYwMjQ5MGZkNWI1MDgwM2IxNTYxMDIwZDU2ZmU2MDgwNjA0MDUyMzYxNTYwNTE1NzdmMzYwODk0YTEzYmExYTMyMTA2NjdjODI4NDkyZGI5OGRjYTNlMjA3NmNjMzczNWE5MjBhM2NhNTA1ZDM4MmJiYzU0NWY5MDgxOTA2MDAxNjAwMTYwYTAxYjAzMTYzNjgyODAzNzgxMzY5MTVhZjQzZDVmODAzZTE1NjA0ZDU3M2Q1ZmYzNWIzZDVmZmQ1YjAwZmVhMjY0Njk3MDY2NzM1ODIyMTIyMDQxYjVmNzBhMzUxOTUyMTQyMjIzZjIyNTA0Y2E3YjRlNmQ5NzVmM2EzMDJkMTE0ZmY4MjA0NDJmY2Y4MTVhYzI2NDczNmY2YzYzNDMwMDA4MWIwMDMzXCI7XG4gIGNvbnN0IGluaXRDb2RlSGFzaCA9IGtlY2NhazI1NihlbmNvZGVQYWNrZWQoW1wiYnl0ZXNcIiwgXCJieXRlc1wiXSwgW25leHVzUHJveHlDcmVhdGlvbkNvZGUsIGNvbnN0cnVjdG9yQXJnc10pKTtcbiAgcmV0dXJuIGdldENyZWF0ZTJBZGRyZXNzKHtcbiAgICBieXRlY29kZUhhc2g6IGluaXRDb2RlSGFzaCxcbiAgICBmcm9tOiBkZXBsb3llcixcbiAgICBzYWx0XG4gIH0pO1xufVxuLy8gbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS9vcC1zdGFjay9jb250cmFjdHMuanNcbnZhciBjb250cmFjdHMgPSB7XG4gIGdhc1ByaWNlT3JhY2xlOiB7IGFkZHJlc3M6IFwiMHg0MjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBGXCIgfSxcbiAgbDFCbG9jazogeyBhZGRyZXNzOiBcIjB4NDIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxNVwiIH0sXG4gIGwyQ3Jvc3NEb21haW5NZXNzZW5nZXI6IHtcbiAgICBhZGRyZXNzOiBcIjB4NDIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwN1wiXG4gIH0sXG4gIGwyRXJjNzIxQnJpZGdlOiB7IGFkZHJlc3M6IFwiMHg0MjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDE0XCIgfSxcbiAgbDJTdGFuZGFyZEJyaWRnZTogeyBhZGRyZXNzOiBcIjB4NDIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMFwiIH0sXG4gIGwyVG9MMU1lc3NhZ2VQYXNzZXI6IHtcbiAgICBhZGRyZXNzOiBcIjB4NDIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxNlwiXG4gIH1cbn07XG5cbi8vIG5vZGVfbW9kdWxlcy92aWVtL19lc20vb3Atc3RhY2svZm9ybWF0dGVycy5qc1xuaW5pdF9mcm9tSGV4KCk7XG52YXIgZm9ybWF0dGVycyA9IHtcbiAgYmxvY2s6IC8qIEBfX1BVUkVfXyAqLyBkZWZpbmVCbG9jayh7XG4gICAgZm9ybWF0KGFyZ3MpIHtcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9ucyA9IGFyZ3MudHJhbnNhY3Rpb25zPy5tYXAoKHRyYW5zYWN0aW9uKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdHJhbnNhY3Rpb24gPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgcmV0dXJuIHRyYW5zYWN0aW9uO1xuICAgICAgICBjb25zdCBmb3JtYXR0ZWQgPSBmb3JtYXRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbik7XG4gICAgICAgIGlmIChmb3JtYXR0ZWQudHlwZUhleCA9PT0gXCIweDdlXCIpIHtcbiAgICAgICAgICBmb3JtYXR0ZWQuaXNTeXN0ZW1UeCA9IHRyYW5zYWN0aW9uLmlzU3lzdGVtVHg7XG4gICAgICAgICAgZm9ybWF0dGVkLm1pbnQgPSB0cmFuc2FjdGlvbi5taW50ID8gaGV4VG9CaWdJbnQodHJhbnNhY3Rpb24ubWludCkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgZm9ybWF0dGVkLnNvdXJjZUhhc2ggPSB0cmFuc2FjdGlvbi5zb3VyY2VIYXNoO1xuICAgICAgICAgIGZvcm1hdHRlZC50eXBlID0gXCJkZXBvc2l0XCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvcm1hdHRlZDtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHJhbnNhY3Rpb25zLFxuICAgICAgICBzdGF0ZVJvb3Q6IGFyZ3Muc3RhdGVSb290XG4gICAgICB9O1xuICAgIH1cbiAgfSksXG4gIHRyYW5zYWN0aW9uOiAvKiBAX19QVVJFX18gKi8gZGVmaW5lVHJhbnNhY3Rpb24oe1xuICAgIGZvcm1hdChhcmdzKSB7XG4gICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHt9O1xuICAgICAgaWYgKGFyZ3MudHlwZSA9PT0gXCIweDdlXCIpIHtcbiAgICAgICAgdHJhbnNhY3Rpb24uaXNTeXN0ZW1UeCA9IGFyZ3MuaXNTeXN0ZW1UeDtcbiAgICAgICAgdHJhbnNhY3Rpb24ubWludCA9IGFyZ3MubWludCA/IGhleFRvQmlnSW50KGFyZ3MubWludCkgOiB1bmRlZmluZWQ7XG4gICAgICAgIHRyYW5zYWN0aW9uLnNvdXJjZUhhc2ggPSBhcmdzLnNvdXJjZUhhc2g7XG4gICAgICAgIHRyYW5zYWN0aW9uLnR5cGUgPSBcImRlcG9zaXRcIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cmFuc2FjdGlvbjtcbiAgICB9XG4gIH0pLFxuICB0cmFuc2FjdGlvblJlY2VpcHQ6IC8qIEBfX1BVUkVfXyAqLyBkZWZpbmVUcmFuc2FjdGlvblJlY2VpcHQoe1xuICAgIGZvcm1hdChhcmdzKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsMUdhc1ByaWNlOiBhcmdzLmwxR2FzUHJpY2UgPyBoZXhUb0JpZ0ludChhcmdzLmwxR2FzUHJpY2UpIDogbnVsbCxcbiAgICAgICAgbDFHYXNVc2VkOiBhcmdzLmwxR2FzVXNlZCA/IGhleFRvQmlnSW50KGFyZ3MubDFHYXNVc2VkKSA6IG51bGwsXG4gICAgICAgIGwxRmVlOiBhcmdzLmwxRmVlID8gaGV4VG9CaWdJbnQoYXJncy5sMUZlZSkgOiBudWxsLFxuICAgICAgICBsMUZlZVNjYWxhcjogYXJncy5sMUZlZVNjYWxhciA/IE51bWJlcihhcmdzLmwxRmVlU2NhbGFyKSA6IG51bGxcbiAgICAgIH07XG4gICAgfVxuICB9KVxufTtcblxuLy8gbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS9vcC1zdGFjay9zZXJpYWxpemVycy5qc1xuaW5pdF9hZGRyZXNzKCk7XG5pbml0X2lzQWRkcmVzcygpO1xuaW5pdF90b0hleCgpO1xuZnVuY3Rpb24gc2VyaWFsaXplVHJhbnNhY3Rpb24yKHRyYW5zYWN0aW9uLCBzaWduYXR1cmUpIHtcbiAgaWYgKGlzRGVwb3NpdCh0cmFuc2FjdGlvbikpXG4gICAgcmV0dXJuIHNlcmlhbGl6ZVRyYW5zYWN0aW9uRGVwb3NpdCh0cmFuc2FjdGlvbik7XG4gIHJldHVybiBzZXJpYWxpemVUcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgc2lnbmF0dXJlKTtcbn1cbnZhciBzZXJpYWxpemVycyA9IHtcbiAgdHJhbnNhY3Rpb246IHNlcmlhbGl6ZVRyYW5zYWN0aW9uMlxufTtcbmZ1bmN0aW9uIHNlcmlhbGl6ZVRyYW5zYWN0aW9uRGVwb3NpdCh0cmFuc2FjdGlvbikge1xuICBhc3NlcnRUcmFuc2FjdGlvbkRlcG9zaXQodHJhbnNhY3Rpb24pO1xuICBjb25zdCB7IHNvdXJjZUhhc2gsIGRhdGEsIGZyb20sIGdhcywgaXNTeXN0ZW1UeCwgbWludCwgdG8sIHZhbHVlIH0gPSB0cmFuc2FjdGlvbjtcbiAgY29uc3Qgc2VyaWFsaXplZFRyYW5zYWN0aW9uID0gW1xuICAgIHNvdXJjZUhhc2gsXG4gICAgZnJvbSxcbiAgICB0byA/PyBcIjB4XCIsXG4gICAgbWludCA/IHRvSGV4KG1pbnQpIDogXCIweFwiLFxuICAgIHZhbHVlID8gdG9IZXgodmFsdWUpIDogXCIweFwiLFxuICAgIGdhcyA/IHRvSGV4KGdhcykgOiBcIjB4XCIsXG4gICAgaXNTeXN0ZW1UeCA/IFwiMHgxXCIgOiBcIjB4XCIsXG4gICAgZGF0YSA/PyBcIjB4XCJcbiAgXTtcbiAgcmV0dXJuIGNvbmNhdEhleChbXG4gICAgXCIweDdlXCIsXG4gICAgdG9SbHAoc2VyaWFsaXplZFRyYW5zYWN0aW9uKVxuICBdKTtcbn1cbmZ1bmN0aW9uIGlzRGVwb3NpdCh0cmFuc2FjdGlvbikge1xuICBpZiAodHJhbnNhY3Rpb24udHlwZSA9PT0gXCJkZXBvc2l0XCIpXG4gICAgcmV0dXJuIHRydWU7XG4gIGlmICh0eXBlb2YgdHJhbnNhY3Rpb24uc291cmNlSGFzaCAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gYXNzZXJ0VHJhbnNhY3Rpb25EZXBvc2l0KHRyYW5zYWN0aW9uKSB7XG4gIGNvbnN0IHsgZnJvbSwgdG8gfSA9IHRyYW5zYWN0aW9uO1xuICBpZiAoZnJvbSAmJiAhaXNBZGRyZXNzKGZyb20pKVxuICAgIHRocm93IG5ldyBJbnZhbGlkQWRkcmVzc0Vycm9yKHsgYWRkcmVzczogZnJvbSB9KTtcbiAgaWYgKHRvICYmICFpc0FkZHJlc3ModG8pKVxuICAgIHRocm93IG5ldyBJbnZhbGlkQWRkcmVzc0Vycm9yKHsgYWRkcmVzczogdG8gfSk7XG59XG5cbi8vIG5vZGVfbW9kdWxlcy92aWVtL19lc20vb3Atc3RhY2svY2hhaW5Db25maWcuanNcbnZhciBjaGFpbkNvbmZpZyA9IHtcbiAgYmxvY2tUaW1lOiAyMDAwLFxuICBjb250cmFjdHMsXG4gIGZvcm1hdHRlcnMsXG4gIHNlcmlhbGl6ZXJzXG59O1xuXG4vLyBub2RlX21vZHVsZXMvdmllbS9fZXNtL2NoYWlucy9kZWZpbml0aW9ucy9hcmJpdHJ1bS5qc1xudmFyIGFyYml0cnVtID0gLyogQF9fUFVSRV9fICovIGRlZmluZUNoYWluKHtcbiAgaWQ6IDQyMTYxLFxuICBuYW1lOiBcIkFyYml0cnVtIE9uZVwiLFxuICBuYXRpdmVDdXJyZW5jeTogeyBuYW1lOiBcIkV0aGVyXCIsIHN5bWJvbDogXCJFVEhcIiwgZGVjaW1hbHM6IDE4IH0sXG4gIGJsb2NrVGltZTogMjUwLFxuICBycGNVcmxzOiB7XG4gICAgZGVmYXVsdDoge1xuICAgICAgaHR0cDogW1wiaHR0cHM6Ly9hcmIxLmFyYml0cnVtLmlvL3JwY1wiXVxuICAgIH1cbiAgfSxcbiAgYmxvY2tFeHBsb3JlcnM6IHtcbiAgICBkZWZhdWx0OiB7XG4gICAgICBuYW1lOiBcIkFyYmlzY2FuXCIsXG4gICAgICB1cmw6IFwiaHR0cHM6Ly9hcmJpc2Nhbi5pb1wiLFxuICAgICAgYXBpVXJsOiBcImh0dHBzOi8vYXBpLmFyYmlzY2FuLmlvL2FwaVwiXG4gICAgfVxuICB9LFxuICBjb250cmFjdHM6IHtcbiAgICBtdWx0aWNhbGwzOiB7XG4gICAgICBhZGRyZXNzOiBcIjB4Y2ExMWJkZTA1OTc3YjM2MzExNjcwMjg4NjJiZTJhMTczOTc2Y2ExMVwiLFxuICAgICAgYmxvY2tDcmVhdGVkOiA3NjU0NzA3XG4gICAgfVxuICB9XG59KTtcbi8vIG5vZGVfbW9kdWxlcy92aWVtL19lc20vY2hhaW5zL2RlZmluaXRpb25zL2FyYml0cnVtU2Vwb2xpYS5qc1xudmFyIGFyYml0cnVtU2Vwb2xpYSA9IC8qIEBfX1BVUkVfXyAqLyBkZWZpbmVDaGFpbih7XG4gIGlkOiA0MjE2MTQsXG4gIG5hbWU6IFwiQXJiaXRydW0gU2Vwb2xpYVwiLFxuICBibG9ja1RpbWU6IDI1MCxcbiAgbmF0aXZlQ3VycmVuY3k6IHtcbiAgICBuYW1lOiBcIkFyYml0cnVtIFNlcG9saWEgRXRoZXJcIixcbiAgICBzeW1ib2w6IFwiRVRIXCIsXG4gICAgZGVjaW1hbHM6IDE4XG4gIH0sXG4gIHJwY1VybHM6IHtcbiAgICBkZWZhdWx0OiB7XG4gICAgICBodHRwOiBbXCJodHRwczovL3NlcG9saWEtcm9sbHVwLmFyYml0cnVtLmlvL3JwY1wiXVxuICAgIH1cbiAgfSxcbiAgYmxvY2tFeHBsb3JlcnM6IHtcbiAgICBkZWZhdWx0OiB7XG4gICAgICBuYW1lOiBcIkFyYmlzY2FuXCIsXG4gICAgICB1cmw6IFwiaHR0cHM6Ly9zZXBvbGlhLmFyYmlzY2FuLmlvXCIsXG4gICAgICBhcGlVcmw6IFwiaHR0cHM6Ly9hcGktc2Vwb2xpYS5hcmJpc2Nhbi5pby9hcGlcIlxuICAgIH1cbiAgfSxcbiAgY29udHJhY3RzOiB7XG4gICAgbXVsdGljYWxsMzoge1xuICAgICAgYWRkcmVzczogXCIweGNhMTFiZGUwNTk3N2IzNjMxMTY3MDI4ODYyYmUyYTE3Mzk3NmNhMTFcIixcbiAgICAgIGJsb2NrQ3JlYXRlZDogODE5MzBcbiAgICB9XG4gIH0sXG4gIHRlc3RuZXQ6IHRydWVcbn0pO1xuLy8gbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS9jaGFpbnMvZGVmaW5pdGlvbnMvYmFzZS5qc1xudmFyIHNvdXJjZUlkID0gMTtcbnZhciBiYXNlID0gLyogQF9fUFVSRV9fICovIGRlZmluZUNoYWluKHtcbiAgLi4uY2hhaW5Db25maWcsXG4gIGlkOiA4NDUzLFxuICBuYW1lOiBcIkJhc2VcIixcbiAgbmF0aXZlQ3VycmVuY3k6IHsgbmFtZTogXCJFdGhlclwiLCBzeW1ib2w6IFwiRVRIXCIsIGRlY2ltYWxzOiAxOCB9LFxuICBycGNVcmxzOiB7XG4gICAgZGVmYXVsdDoge1xuICAgICAgaHR0cDogW1wiaHR0cHM6Ly9tYWlubmV0LmJhc2Uub3JnXCJdXG4gICAgfVxuICB9LFxuICBibG9ja0V4cGxvcmVyczoge1xuICAgIGRlZmF1bHQ6IHtcbiAgICAgIG5hbWU6IFwiQmFzZXNjYW5cIixcbiAgICAgIHVybDogXCJodHRwczovL2Jhc2VzY2FuLm9yZ1wiLFxuICAgICAgYXBpVXJsOiBcImh0dHBzOi8vYXBpLmJhc2VzY2FuLm9yZy9hcGlcIlxuICAgIH1cbiAgfSxcbiAgY29udHJhY3RzOiB7XG4gICAgLi4uY2hhaW5Db25maWcuY29udHJhY3RzLFxuICAgIGRpc3B1dGVHYW1lRmFjdG9yeToge1xuICAgICAgW3NvdXJjZUlkXToge1xuICAgICAgICBhZGRyZXNzOiBcIjB4NDNlZEI4OEM0QjgwZkREMkFkRkYyNDEyQTdCZWJGOWRGNDJjQjQwZVwiXG4gICAgICB9XG4gICAgfSxcbiAgICBsMk91dHB1dE9yYWNsZToge1xuICAgICAgW3NvdXJjZUlkXToge1xuICAgICAgICBhZGRyZXNzOiBcIjB4NTYzMTViOTBjNDA3MzA5MjVlYzU0ODVjZjAwNGQ4MzUwNTg1MThBMFwiXG4gICAgICB9XG4gICAgfSxcbiAgICBtdWx0aWNhbGwzOiB7XG4gICAgICBhZGRyZXNzOiBcIjB4Y2ExMWJkZTA1OTc3YjM2MzExNjcwMjg4NjJiZTJhMTczOTc2Y2ExMVwiLFxuICAgICAgYmxvY2tDcmVhdGVkOiA1MDIyXG4gICAgfSxcbiAgICBwb3J0YWw6IHtcbiAgICAgIFtzb3VyY2VJZF06IHtcbiAgICAgICAgYWRkcmVzczogXCIweDQ5MDQ4MDQ0RDU3ZTFDOTJBNzdmNzk5ODhkMjFGYThmQUY3NEU5N2VcIixcbiAgICAgICAgYmxvY2tDcmVhdGVkOiAxNzQ4MjE0M1xuICAgICAgfVxuICAgIH0sXG4gICAgbDFTdGFuZGFyZEJyaWRnZToge1xuICAgICAgW3NvdXJjZUlkXToge1xuICAgICAgICBhZGRyZXNzOiBcIjB4MzE1NENmMTZjY2RiNEM2ZDkyMjYyOTY2NDE3NGI5MDRkODBGMkMzNVwiLFxuICAgICAgICBibG9ja0NyZWF0ZWQ6IDE3NDgyMTQzXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBzb3VyY2VJZFxufSk7XG52YXIgYmFzZVByZWNvbmYgPSAvKiBAX19QVVJFX18gKi8gZGVmaW5lQ2hhaW4oe1xuICAuLi5iYXNlLFxuICBleHBlcmltZW50YWxfcHJlY29uZmlybWF0aW9uVGltZTogMjAwLFxuICBycGNVcmxzOiB7XG4gICAgZGVmYXVsdDoge1xuICAgICAgaHR0cDogW1wiaHR0cHM6Ly9tYWlubmV0LXByZWNvbmYuYmFzZS5vcmdcIl1cbiAgICB9XG4gIH1cbn0pO1xuLy8gbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS9jaGFpbnMvZGVmaW5pdGlvbnMvYmFzZVNlcG9saWEuanNcbnZhciBzb3VyY2VJZDIgPSAxMTE1NTExMTtcbnZhciBiYXNlU2Vwb2xpYSA9IC8qIEBfX1BVUkVfXyAqLyBkZWZpbmVDaGFpbih7XG4gIC4uLmNoYWluQ29uZmlnLFxuICBpZDogODQ1MzIsXG4gIG5ldHdvcms6IFwiYmFzZS1zZXBvbGlhXCIsXG4gIG5hbWU6IFwiQmFzZSBTZXBvbGlhXCIsXG4gIG5hdGl2ZUN1cnJlbmN5OiB7IG5hbWU6IFwiU2Vwb2xpYSBFdGhlclwiLCBzeW1ib2w6IFwiRVRIXCIsIGRlY2ltYWxzOiAxOCB9LFxuICBycGNVcmxzOiB7XG4gICAgZGVmYXVsdDoge1xuICAgICAgaHR0cDogW1wiaHR0cHM6Ly9zZXBvbGlhLmJhc2Uub3JnXCJdXG4gICAgfVxuICB9LFxuICBibG9ja0V4cGxvcmVyczoge1xuICAgIGRlZmF1bHQ6IHtcbiAgICAgIG5hbWU6IFwiQmFzZXNjYW5cIixcbiAgICAgIHVybDogXCJodHRwczovL3NlcG9saWEuYmFzZXNjYW4ub3JnXCIsXG4gICAgICBhcGlVcmw6IFwiaHR0cHM6Ly9hcGktc2Vwb2xpYS5iYXNlc2Nhbi5vcmcvYXBpXCJcbiAgICB9XG4gIH0sXG4gIGNvbnRyYWN0czoge1xuICAgIC4uLmNoYWluQ29uZmlnLmNvbnRyYWN0cyxcbiAgICBkaXNwdXRlR2FtZUZhY3Rvcnk6IHtcbiAgICAgIFtzb3VyY2VJZDJdOiB7XG4gICAgICAgIGFkZHJlc3M6IFwiMHhkNkU2ZEJmNEY3RUEwYWM0MTJmRDhiNjVFRDI5N2U2NEJCN2EwNkUxXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGwyT3V0cHV0T3JhY2xlOiB7XG4gICAgICBbc291cmNlSWQyXToge1xuICAgICAgICBhZGRyZXNzOiBcIjB4ODQ0NTdjYTlEMDE2M0ZiQzRiYmZlNERmYmIyMGJhNDZlNDhERjI1NFwiXG4gICAgICB9XG4gICAgfSxcbiAgICBwb3J0YWw6IHtcbiAgICAgIFtzb3VyY2VJZDJdOiB7XG4gICAgICAgIGFkZHJlc3M6IFwiMHg0OWY1M2U0MTQ1MmM3NDU4OWU4NWNhMTY3NzQyNmJhNDI2NDU5ZTg1XCIsXG4gICAgICAgIGJsb2NrQ3JlYXRlZDogNDQ0NjY3N1xuICAgICAgfVxuICAgIH0sXG4gICAgbDFTdGFuZGFyZEJyaWRnZToge1xuICAgICAgW3NvdXJjZUlkMl06IHtcbiAgICAgICAgYWRkcmVzczogXCIweGZkMEJmNzFGNjA2NjBFMmY2MDhlZDU2ZTE2NTlDNDUwZUIxMTMxMjBcIixcbiAgICAgICAgYmxvY2tDcmVhdGVkOiA0NDQ2Njc3XG4gICAgICB9XG4gICAgfSxcbiAgICBtdWx0aWNhbGwzOiB7XG4gICAgICBhZGRyZXNzOiBcIjB4Y2ExMWJkZTA1OTc3YjM2MzExNjcwMjg4NjJiZTJhMTczOTc2Y2ExMVwiLFxuICAgICAgYmxvY2tDcmVhdGVkOiAxMDU5NjQ3XG4gICAgfVxuICB9LFxuICB0ZXN0bmV0OiB0cnVlLFxuICBzb3VyY2VJZDogc291cmNlSWQyXG59KTtcbnZhciBiYXNlU2Vwb2xpYVByZWNvbmYgPSAvKiBAX19QVVJFX18gKi8gZGVmaW5lQ2hhaW4oe1xuICAuLi5iYXNlU2Vwb2xpYSxcbiAgZXhwZXJpbWVudGFsX3ByZWNvbmZpcm1hdGlvblRpbWU6IDIwMCxcbiAgcnBjVXJsczoge1xuICAgIGRlZmF1bHQ6IHtcbiAgICAgIGh0dHA6IFtcImh0dHBzOi8vc2Vwb2xpYS1wcmVjb25mLmJhc2Uub3JnXCJdXG4gICAgfVxuICB9XG59KTtcbi8vIG5vZGVfbW9kdWxlcy92aWVtL19lc20vY2hhaW5zL2RlZmluaXRpb25zL21haW5uZXQuanNcbnZhciBtYWlubmV0ID0gLyogQF9fUFVSRV9fICovIGRlZmluZUNoYWluKHtcbiAgaWQ6IDEsXG4gIG5hbWU6IFwiRXRoZXJldW1cIixcbiAgbmF0aXZlQ3VycmVuY3k6IHsgbmFtZTogXCJFdGhlclwiLCBzeW1ib2w6IFwiRVRIXCIsIGRlY2ltYWxzOiAxOCB9LFxuICBycGNVcmxzOiB7XG4gICAgZGVmYXVsdDoge1xuICAgICAgaHR0cDogW1wiaHR0cHM6Ly9ldGgubWVya2xlLmlvXCJdXG4gICAgfVxuICB9LFxuICBibG9ja0V4cGxvcmVyczoge1xuICAgIGRlZmF1bHQ6IHtcbiAgICAgIG5hbWU6IFwiRXRoZXJzY2FuXCIsXG4gICAgICB1cmw6IFwiaHR0cHM6Ly9ldGhlcnNjYW4uaW9cIixcbiAgICAgIGFwaVVybDogXCJodHRwczovL2FwaS5ldGhlcnNjYW4uaW8vYXBpXCJcbiAgICB9XG4gIH0sXG4gIGNvbnRyYWN0czoge1xuICAgIGVuc1JlZ2lzdHJ5OiB7XG4gICAgICBhZGRyZXNzOiBcIjB4MDAwMDAwMDAwMDBDMkUwNzRlQzY5QTBkRmIyOTk3QkE2QzdkMmUxZVwiXG4gICAgfSxcbiAgICBlbnNVbml2ZXJzYWxSZXNvbHZlcjoge1xuICAgICAgYWRkcmVzczogXCIweGNlMDFmOGVlZTdFNDc5QzkyOEY4OTE5YWJENTNFNTUzYTM2Q2VGNjdcIixcbiAgICAgIGJsb2NrQ3JlYXRlZDogMTkyNTgyMTNcbiAgICB9LFxuICAgIG11bHRpY2FsbDM6IHtcbiAgICAgIGFkZHJlc3M6IFwiMHhjYTExYmRlMDU5NzdiMzYzMTE2NzAyODg2MmJlMmExNzM5NzZjYTExXCIsXG4gICAgICBibG9ja0NyZWF0ZWQ6IDE0MzUzNjAxXG4gICAgfVxuICB9XG59KTtcbi8vIG5vZGVfbW9kdWxlcy92aWVtL19lc20vY2hhaW5zL2RlZmluaXRpb25zL29wdGltaXNtLmpzXG52YXIgc291cmNlSWQzID0gMTtcbnZhciBvcHRpbWlzbSA9IC8qIEBfX1BVUkVfXyAqLyBkZWZpbmVDaGFpbih7XG4gIC4uLmNoYWluQ29uZmlnLFxuICBpZDogMTAsXG4gIG5hbWU6IFwiT1AgTWFpbm5ldFwiLFxuICBuYXRpdmVDdXJyZW5jeTogeyBuYW1lOiBcIkV0aGVyXCIsIHN5bWJvbDogXCJFVEhcIiwgZGVjaW1hbHM6IDE4IH0sXG4gIHJwY1VybHM6IHtcbiAgICBkZWZhdWx0OiB7XG4gICAgICBodHRwOiBbXCJodHRwczovL21haW5uZXQub3B0aW1pc20uaW9cIl1cbiAgICB9XG4gIH0sXG4gIGJsb2NrRXhwbG9yZXJzOiB7XG4gICAgZGVmYXVsdDoge1xuICAgICAgbmFtZTogXCJPcHRpbWlzbSBFeHBsb3JlclwiLFxuICAgICAgdXJsOiBcImh0dHBzOi8vb3B0aW1pc3RpYy5ldGhlcnNjYW4uaW9cIixcbiAgICAgIGFwaVVybDogXCJodHRwczovL2FwaS1vcHRpbWlzdGljLmV0aGVyc2Nhbi5pby9hcGlcIlxuICAgIH1cbiAgfSxcbiAgY29udHJhY3RzOiB7XG4gICAgLi4uY2hhaW5Db25maWcuY29udHJhY3RzLFxuICAgIGRpc3B1dGVHYW1lRmFjdG9yeToge1xuICAgICAgW3NvdXJjZUlkM106IHtcbiAgICAgICAgYWRkcmVzczogXCIweGU1OTY1QWI1OTYyZURjNzQ3N0M4NTIwMjQzQTk1NTE3Q0QyNTJmQTlcIlxuICAgICAgfVxuICAgIH0sXG4gICAgbDJPdXRwdXRPcmFjbGU6IHtcbiAgICAgIFtzb3VyY2VJZDNdOiB7XG4gICAgICAgIGFkZHJlc3M6IFwiMHhkZmU5Nzg2ODIzM2QxYWEyMmU4MTVhMjY2OTgyZjJjZjE3Njg1YTI3XCJcbiAgICAgIH1cbiAgICB9LFxuICAgIG11bHRpY2FsbDM6IHtcbiAgICAgIGFkZHJlc3M6IFwiMHhjYTExYmRlMDU5NzdiMzYzMTE2NzAyODg2MmJlMmExNzM5NzZjYTExXCIsXG4gICAgICBibG9ja0NyZWF0ZWQ6IDQyODYyNjNcbiAgICB9LFxuICAgIHBvcnRhbDoge1xuICAgICAgW3NvdXJjZUlkM106IHtcbiAgICAgICAgYWRkcmVzczogXCIweGJFYjVGYzU3OTExNTA3MTc2NGM3NDIzQTRmMTJlRGRlNDFmMTA2RWRcIlxuICAgICAgfVxuICAgIH0sXG4gICAgbDFTdGFuZGFyZEJyaWRnZToge1xuICAgICAgW3NvdXJjZUlkM106IHtcbiAgICAgICAgYWRkcmVzczogXCIweDk5QzlmYzQ2ZjkyRThhMWMwZGVDMWIxNzQ3ZDAxMDkwM0U4ODRiRTFcIlxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgc291cmNlSWQ6IHNvdXJjZUlkM1xufSk7XG4vLyBub2RlX21vZHVsZXMvdmllbS9fZXNtL2NoYWlucy9kZWZpbml0aW9ucy9vcHRpbWlzbVNlcG9saWEuanNcbnZhciBzb3VyY2VJZDQgPSAxMTE1NTExMTtcbnZhciBvcHRpbWlzbVNlcG9saWEgPSAvKiBAX19QVVJFX18gKi8gZGVmaW5lQ2hhaW4oe1xuICAuLi5jaGFpbkNvbmZpZyxcbiAgaWQ6IDExMTU1NDIwLFxuICBuYW1lOiBcIk9QIFNlcG9saWFcIixcbiAgbmF0aXZlQ3VycmVuY3k6IHsgbmFtZTogXCJTZXBvbGlhIEV0aGVyXCIsIHN5bWJvbDogXCJFVEhcIiwgZGVjaW1hbHM6IDE4IH0sXG4gIHJwY1VybHM6IHtcbiAgICBkZWZhdWx0OiB7XG4gICAgICBodHRwOiBbXCJodHRwczovL3NlcG9saWEub3B0aW1pc20uaW9cIl1cbiAgICB9XG4gIH0sXG4gIGJsb2NrRXhwbG9yZXJzOiB7XG4gICAgZGVmYXVsdDoge1xuICAgICAgbmFtZTogXCJCbG9ja3Njb3V0XCIsXG4gICAgICB1cmw6IFwiaHR0cHM6Ly9vcHRpbWlzbS1zZXBvbGlhLmJsb2Nrc2NvdXQuY29tXCIsXG4gICAgICBhcGlVcmw6IFwiaHR0cHM6Ly9vcHRpbWlzbS1zZXBvbGlhLmJsb2Nrc2NvdXQuY29tL2FwaVwiXG4gICAgfVxuICB9LFxuICBjb250cmFjdHM6IHtcbiAgICAuLi5jaGFpbkNvbmZpZy5jb250cmFjdHMsXG4gICAgZGlzcHV0ZUdhbWVGYWN0b3J5OiB7XG4gICAgICBbc291cmNlSWQ0XToge1xuICAgICAgICBhZGRyZXNzOiBcIjB4MDVGOTYxM2FEQjMwMDI2RkZkNjM0ZjM4ZTVDNGRGZDMwYTE5N0ZhMVwiXG4gICAgICB9XG4gICAgfSxcbiAgICBsMk91dHB1dE9yYWNsZToge1xuICAgICAgW3NvdXJjZUlkNF06IHtcbiAgICAgICAgYWRkcmVzczogXCIweDkwRTljNGY4YTk5NGEyNTBGNmFFZmQ2MUNBRmI0RjJlODk1RDQ1OEZcIlxuICAgICAgfVxuICAgIH0sXG4gICAgbXVsdGljYWxsMzoge1xuICAgICAgYWRkcmVzczogXCIweGNhMTFiZGUwNTk3N2IzNjMxMTY3MDI4ODYyYmUyYTE3Mzk3NmNhMTFcIixcbiAgICAgIGJsb2NrQ3JlYXRlZDogMTYyMDIwNFxuICAgIH0sXG4gICAgcG9ydGFsOiB7XG4gICAgICBbc291cmNlSWQ0XToge1xuICAgICAgICBhZGRyZXNzOiBcIjB4MTZGYzUwNThGMjU2NDgxOTQ0NzE5MzlkZjc1Q0YyN0EyZmRDNDhCQ1wiXG4gICAgICB9XG4gICAgfSxcbiAgICBsMVN0YW5kYXJkQnJpZGdlOiB7XG4gICAgICBbc291cmNlSWQ0XToge1xuICAgICAgICBhZGRyZXNzOiBcIjB4RkJiMDYyMUUwQjIzYjU0NzhCNjMwQkQ1NWE1ZjIxZjY3NzMwQjBGMVwiXG4gICAgICB9XG4gICAgfVxuICB9LFxuICB0ZXN0bmV0OiB0cnVlLFxuICBzb3VyY2VJZDogc291cmNlSWQ0XG59KTtcbi8vIG5vZGVfbW9kdWxlcy92aWVtL19lc20vY2hhaW5zL2RlZmluaXRpb25zL3BvbHlnb24uanNcbnZhciBwb2x5Z29uID0gLyogQF9fUFVSRV9fICovIGRlZmluZUNoYWluKHtcbiAgaWQ6IDEzNyxcbiAgbmFtZTogXCJQb2x5Z29uXCIsXG4gIG5hdGl2ZUN1cnJlbmN5OiB7IG5hbWU6IFwiUE9MXCIsIHN5bWJvbDogXCJQT0xcIiwgZGVjaW1hbHM6IDE4IH0sXG4gIHJwY1VybHM6IHtcbiAgICBkZWZhdWx0OiB7XG4gICAgICBodHRwOiBbXCJodHRwczovL3BvbHlnb24tcnBjLmNvbVwiXVxuICAgIH1cbiAgfSxcbiAgYmxvY2tFeHBsb3JlcnM6IHtcbiAgICBkZWZhdWx0OiB7XG4gICAgICBuYW1lOiBcIlBvbHlnb25TY2FuXCIsXG4gICAgICB1cmw6IFwiaHR0cHM6Ly9wb2x5Z29uc2Nhbi5jb21cIixcbiAgICAgIGFwaVVybDogXCJodHRwczovL2FwaS5wb2x5Z29uc2Nhbi5jb20vYXBpXCJcbiAgICB9XG4gIH0sXG4gIGNvbnRyYWN0czoge1xuICAgIG11bHRpY2FsbDM6IHtcbiAgICAgIGFkZHJlc3M6IFwiMHhjYTExYmRlMDU5NzdiMzYzMTE2NzAyODg2MmJlMmExNzM5NzZjYTExXCIsXG4gICAgICBibG9ja0NyZWF0ZWQ6IDI1NzcwMTYwXG4gICAgfVxuICB9XG59KTtcbi8vIG5vZGVfbW9kdWxlcy92aWVtL19lc20vY2hhaW5zL2RlZmluaXRpb25zL3BvbHlnb25BbW95LmpzXG52YXIgcG9seWdvbkFtb3kgPSAvKiBAX19QVVJFX18gKi8gZGVmaW5lQ2hhaW4oe1xuICBpZDogODAwMDIsXG4gIG5hbWU6IFwiUG9seWdvbiBBbW95XCIsXG4gIG5hdGl2ZUN1cnJlbmN5OiB7IG5hbWU6IFwiUE9MXCIsIHN5bWJvbDogXCJQT0xcIiwgZGVjaW1hbHM6IDE4IH0sXG4gIHJwY1VybHM6IHtcbiAgICBkZWZhdWx0OiB7XG4gICAgICBodHRwOiBbXCJodHRwczovL3JwYy1hbW95LnBvbHlnb24udGVjaG5vbG9neVwiXVxuICAgIH1cbiAgfSxcbiAgYmxvY2tFeHBsb3JlcnM6IHtcbiAgICBkZWZhdWx0OiB7XG4gICAgICBuYW1lOiBcIlBvbHlnb25TY2FuXCIsXG4gICAgICB1cmw6IFwiaHR0cHM6Ly9hbW95LnBvbHlnb25zY2FuLmNvbVwiLFxuICAgICAgYXBpVXJsOiBcImh0dHBzOi8vYXBpLWFtb3kucG9seWdvbnNjYW4uY29tL2FwaVwiXG4gICAgfVxuICB9LFxuICBjb250cmFjdHM6IHtcbiAgICBtdWx0aWNhbGwzOiB7XG4gICAgICBhZGRyZXNzOiBcIjB4Y2ExMWJkZTA1OTc3YjM2MzExNjcwMjg4NjJiZTJhMTczOTc2Y2ExMVwiLFxuICAgICAgYmxvY2tDcmVhdGVkOiAzMTI3Mzg4XG4gICAgfVxuICB9LFxuICB0ZXN0bmV0OiB0cnVlXG59KTtcbi8vIG5vZGVfbW9kdWxlcy92aWVtL19lc20vY2hhaW5zL2RlZmluaXRpb25zL3NlcG9saWEuanNcbnZhciBzZXBvbGlhID0gLyogQF9fUFVSRV9fICovIGRlZmluZUNoYWluKHtcbiAgaWQ6IDExMTU1MTExLFxuICBuYW1lOiBcIlNlcG9saWFcIixcbiAgbmF0aXZlQ3VycmVuY3k6IHsgbmFtZTogXCJTZXBvbGlhIEV0aGVyXCIsIHN5bWJvbDogXCJFVEhcIiwgZGVjaW1hbHM6IDE4IH0sXG4gIHJwY1VybHM6IHtcbiAgICBkZWZhdWx0OiB7XG4gICAgICBodHRwOiBbXCJodHRwczovL3NlcG9saWEuZHJwYy5vcmdcIl1cbiAgICB9XG4gIH0sXG4gIGJsb2NrRXhwbG9yZXJzOiB7XG4gICAgZGVmYXVsdDoge1xuICAgICAgbmFtZTogXCJFdGhlcnNjYW5cIixcbiAgICAgIHVybDogXCJodHRwczovL3NlcG9saWEuZXRoZXJzY2FuLmlvXCIsXG4gICAgICBhcGlVcmw6IFwiaHR0cHM6Ly9hcGktc2Vwb2xpYS5ldGhlcnNjYW4uaW8vYXBpXCJcbiAgICB9XG4gIH0sXG4gIGNvbnRyYWN0czoge1xuICAgIG11bHRpY2FsbDM6IHtcbiAgICAgIGFkZHJlc3M6IFwiMHhjYTExYmRlMDU5NzdiMzYzMTE2NzAyODg2MmJlMmExNzM5NzZjYTExXCIsXG4gICAgICBibG9ja0NyZWF0ZWQ6IDc1MTUzMlxuICAgIH0sXG4gICAgZW5zUmVnaXN0cnk6IHsgYWRkcmVzczogXCIweDAwMDAwMDAwMDAwQzJFMDc0ZUM2OUEwZEZiMjk5N0JBNkM3ZDJlMWVcIiB9LFxuICAgIGVuc1VuaXZlcnNhbFJlc29sdmVyOiB7XG4gICAgICBhZGRyZXNzOiBcIjB4YzhBZjk5OWUzODI3M0Q2NThCRTFiOTIxYjg4QTlEZGYwMDU3NjljQ1wiLFxuICAgICAgYmxvY2tDcmVhdGVkOiA1MzE3MDgwXG4gICAgfVxuICB9LFxuICB0ZXN0bmV0OiB0cnVlXG59KTtcbi8vIHNyYy9jb25zdGFudHMudHNcbnZhciBTREtfQkFDS0VORF9VUkwgPSBcImh0dHBzOi8va2V5cy5nZW1pbmkuY29tXCI7XG52YXIgRU5TX0FQSV9VUkwgPSBcImh0dHBzOi8vaG9yaXpvbi1hcGkuZ2VtaW5pLmNvbS9hcGkvZW5zXCI7XG52YXIgU0RLX1ZFUlNJT04gPSBcIjAuMi4wXCI7XG52YXIgREVGQVVMVF9DSEFJTl9JRCA9IDQyMTYxO1xudmFyIE1BSU5ORVRfQ0hBSU5fSURTID0ge1xuICBBUkJJVFJVTV9PTkU6IDQyMTYxLFxuICBCQVNFOiA4NDUzLFxuICBFVEhFUkVVTTogMSxcbiAgT1BfTUFJTk5FVDogMTAsXG4gIFBPTFlHT046IDEzN1xufTtcbnZhciBURVNUTkVUX0NIQUlOX0lEUyA9IHtcbiAgQVJCSVRSVU1fU0VQT0xJQTogNDIxNjE0LFxuICBCQVNFX1NFUE9MSUE6IDg0NTMyLFxuICBPUF9TRVBPTElBOiAxMTE1NTQyMCxcbiAgUE9MWUdPTl9BTU9ZOiA4MDAwMixcbiAgU0VQT0xJQTogMTExNTUxMTFcbn07XG52YXIgU1VQUE9SVEVEX0NIQUlOX0lEUyA9IFtcbiAgLi4uT2JqZWN0LnZhbHVlcyhNQUlOTkVUX0NIQUlOX0lEUyksXG4gIC4uLk9iamVjdC52YWx1ZXMoVEVTVE5FVF9DSEFJTl9JRFMpXG5dO1xuZnVuY3Rpb24gZ2V0RGVmYXVsdFJwY1VybChjaGFpbklkKSB7XG4gIGNvbnN0IGNoYWluTWFwID0ge1xuICAgIFttYWlubmV0LmlkXTogbWFpbm5ldC5ycGNVcmxzLmRlZmF1bHQuaHR0cFswXSxcbiAgICBbYXJiaXRydW0uaWRdOiBhcmJpdHJ1bS5ycGNVcmxzLmRlZmF1bHQuaHR0cFswXSxcbiAgICBbb3B0aW1pc20uaWRdOiBvcHRpbWlzbS5ycGNVcmxzLmRlZmF1bHQuaHR0cFswXSxcbiAgICBbYmFzZS5pZF06IGJhc2UucnBjVXJscy5kZWZhdWx0Lmh0dHBbMF0sXG4gICAgW3BvbHlnb24uaWRdOiBwb2x5Z29uLnJwY1VybHMuZGVmYXVsdC5odHRwWzBdLFxuICAgIFtzZXBvbGlhLmlkXTogc2Vwb2xpYS5ycGNVcmxzLmRlZmF1bHQuaHR0cFswXSxcbiAgICBbYXJiaXRydW1TZXBvbGlhLmlkXTogYXJiaXRydW1TZXBvbGlhLnJwY1VybHMuZGVmYXVsdC5odHRwWzBdLFxuICAgIFtvcHRpbWlzbVNlcG9saWEuaWRdOiBvcHRpbWlzbVNlcG9saWEucnBjVXJscy5kZWZhdWx0Lmh0dHBbMF0sXG4gICAgW2Jhc2VTZXBvbGlhLmlkXTogYmFzZVNlcG9saWEucnBjVXJscy5kZWZhdWx0Lmh0dHBbMF0sXG4gICAgW3BvbHlnb25BbW95LmlkXTogcG9seWdvbkFtb3kucnBjVXJscy5kZWZhdWx0Lmh0dHBbMF1cbiAgfTtcbiAgcmV0dXJuIGNoYWluTWFwW2NoYWluSWRdO1xufVxudmFyIFBPUFVQX1dJRFRIID0gNDIwO1xudmFyIFBPUFVQX0hFSUdIVCA9IDY1MDtcblxuLy8gc3JjL3V0aWxzL2Vucy50c1xuYXN5bmMgZnVuY3Rpb24gcmV2ZXJzZVJlc29sdmVFbnMoYWRkcmVzcykge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7RU5TX0FQSV9VUkx9L3JldmVyc2UvJHthZGRyZXNzfWApO1xuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRU5TIEFQSSByZXF1ZXN0IGZhaWxlZDogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICByZXR1cm4ge1xuICAgICAgYWRkcmVzczogZGF0YS5hZGRyZXNzLFxuICAgICAgbmFtZTogZGF0YS5uYW1lIHx8IG51bGxcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gcmVzb2x2ZSBFTlMgbmFtZTpcIiwgZXJyb3IpO1xuICAgIHJldHVybiB7XG4gICAgICBhZGRyZXNzLFxuICAgICAgbmFtZTogbnVsbFxuICAgIH07XG4gIH1cbn1cbi8vIHNyYy91dGlscy9wb3B1cC50c1xudmFyIG9wZW5Qb3B1cCA9ICh1cmwpID0+IHtcbiAgY29uc3QgbGVmdCA9ICh3aW5kb3cuaW5uZXJXaWR0aCAtIFBPUFVQX1dJRFRIKSAvIDIgKyB3aW5kb3cuc2NyZWVuWDtcbiAgY29uc3QgdG9wID0gKHdpbmRvdy5pbm5lckhlaWdodCAtIFBPUFVQX0hFSUdIVCkgLyAyICsgd2luZG93LnNjcmVlblk7XG4gIGNvbnN0IHBvcHVwSWQgPSBgZ2VtaW5pX3dhbGxldF8ke2NyeXB0by5yYW5kb21VVUlEKCl9YDtcbiAgY29uc3QgcG9wdXAgPSB3aW5kb3cub3Blbih1cmwsIHBvcHVwSWQsIGB3aWR0aD0ke1BPUFVQX1dJRFRIfSwgaGVpZ2h0PSR7UE9QVVBfSEVJR0hUfSwgbGVmdD0ke2xlZnR9LCB0b3A9JHt0b3B9YCk7XG4gIHBvcHVwPy5mb2N1cygpO1xuICBpZiAoIXBvcHVwKSB7XG4gICAgdGhyb3cgcnBjRXJyb3JzLmludGVybmFsKFwiUG9wIHVwIHdpbmRvdyBmYWlsZWQgdG8gb3BlblwiKTtcbiAgfVxuICByZXR1cm4gcG9wdXA7XG59O1xudmFyIGNsb3NlUG9wdXAgPSAocG9wdXApID0+IHtcbiAgaWYgKHBvcHVwICYmICFwb3B1cC5jbG9zZWQpIHtcbiAgICBwb3B1cC5jbG9zZSgpO1xuICB9XG59O1xuLy8gc3JjL3V0aWxzL3N0cmluZ3MudHNcbnZhciBoZXhTdHJpbmdGcm9tTnVtYmVyID0gKG51bSkgPT4gYDB4JHtCaWdJbnQobnVtKS50b1N0cmluZygxNil9YDtcbnZhciBzYWZlSnNvblN0cmluZ2lmeSA9IChvYmopID0+IEpTT04uc3RyaW5naWZ5KG9iaiwgKF8sIHZhbHVlKSA9PiB0eXBlb2YgdmFsdWUgPT09IFwiYmlnaW50XCIgPyB2YWx1ZS50b1N0cmluZygpICsgXCJuXCIgOiB2YWx1ZSwgMik7XG5cbi8vIHNyYy91dGlscy9pbmRleC50c1xudmFyIGdlbmVyYXRlUmVxdWVzdElkID0gKCkgPT4gY3J5cHRvLnJhbmRvbVVVSUQoKTtcblxuLy8gc3JjL2NvbW11bmljYXRvci50c1xuY2xhc3MgQ29tbXVuaWNhdG9yIHtcbiAgYXBwTWV0YWRhdGE7XG4gIHVybDtcbiAgcG9wdXAgPSBudWxsO1xuICBsaXN0ZW5lcnMgPSBuZXcgTWFwO1xuICBvbkRpc2Nvbm5lY3RDYWxsYmFjaztcbiAgY29uc3RydWN0b3IoeyBhcHBNZXRhZGF0YSwgb25EaXNjb25uZWN0Q2FsbGJhY2sgfSkge1xuICAgIHRoaXMudXJsID0gbmV3IFVSTChTREtfQkFDS0VORF9VUkwpO1xuICAgIHRoaXMuYXBwTWV0YWRhdGEgPSBhcHBNZXRhZGF0YTtcbiAgICB0aGlzLm9uRGlzY29ubmVjdENhbGxiYWNrID0gb25EaXNjb25uZWN0Q2FsbGJhY2s7XG4gIH1cbiAgYXN5bmMgcG9zdE1lc3NhZ2UobWVzc2FnZSkge1xuICAgIGNvbnN0IHBvcHVwID0gYXdhaXQgdGhpcy53YWl0Rm9yUG9wdXBMb2FkZWQoKTtcbiAgICBwb3B1cC5wb3N0TWVzc2FnZShtZXNzYWdlLCB0aGlzLnVybC5vcmlnaW4pO1xuICB9XG4gIGFzeW5jIHBvc3RSZXF1ZXN0QW5kV2FpdEZvclJlc3BvbnNlKHJlcXVlc3QpIHtcbiAgICBjb25zdCByZXNwb25zZVByb21pc2UgPSB0aGlzLm9uTWVzc2FnZSgoeyByZXF1ZXN0SWQgfSkgPT4gcmVxdWVzdElkID09PSByZXF1ZXN0LnJlcXVlc3RJZCk7XG4gICAgYXdhaXQgdGhpcy5wb3N0TWVzc2FnZShyZXF1ZXN0KTtcbiAgICByZXR1cm4gcmVzcG9uc2VQcm9taXNlO1xuICB9XG4gIGFzeW5jIG9uTWVzc2FnZShwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgbGlzdGVuZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKGV2ZW50Lm9yaWdpbiAhPT0gdGhpcy51cmwub3JpZ2luKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGV2ZW50LmRhdGE7XG4gICAgICAgIGlmIChwcmVkaWNhdGUobWVzc2FnZSkpIHtcbiAgICAgICAgICByZXNvbHZlKG1lc3NhZ2UpO1xuICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBsaXN0ZW5lcik7XG4gICAgICAgICAgdGhpcy5saXN0ZW5lcnMuZGVsZXRlKGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBsaXN0ZW5lcik7XG4gICAgICB0aGlzLmxpc3RlbmVycy5zZXQobGlzdGVuZXIsIHsgcmVqZWN0IH0pO1xuICAgIH0pO1xuICB9XG4gIG9uUmVxdWVzdENhbmNlbGxlZCgpIHtcbiAgICBjbG9zZVBvcHVwKHRoaXMucG9wdXAgPz8gdW5kZWZpbmVkKTtcbiAgICB0aGlzLnBvcHVwID0gbnVsbDtcbiAgICB0aGlzLmxpc3RlbmVycy5mb3JFYWNoKCh7IHJlamVjdCB9LCBsaXN0ZW5lcikgPT4ge1xuICAgICAgcmVqZWN0KHByb3ZpZGVyRXJyb3JzLnVzZXJSZWplY3RlZFJlcXVlc3QoKSk7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgbGlzdGVuZXIpO1xuICAgIH0pO1xuICAgIHRoaXMubGlzdGVuZXJzLmNsZWFyKCk7XG4gIH1cbiAgYXN5bmMgd2FpdEZvclBvcHVwTG9hZGVkKCkge1xuICAgIGlmICh0aGlzLnBvcHVwICYmICF0aGlzLnBvcHVwLmNsb3NlZCkge1xuICAgICAgdGhpcy5wb3B1cC5mb2N1cygpO1xuICAgICAgcmV0dXJuIHRoaXMucG9wdXA7XG4gICAgfVxuICAgIHRoaXMucG9wdXAgPSBvcGVuUG9wdXAodGhpcy51cmwpO1xuICAgIHRoaXMub25NZXNzYWdlKCh7IGV2ZW50IH0pID0+IGV2ZW50ID09PSBcIlBPUFVQX1VOTE9BREVEXCIgLyogUE9QVVBfVU5MT0FERUQgKi8pLnRoZW4oKCkgPT4gdGhpcy5vblJlcXVlc3RDYW5jZWxsZWQoKSkuY2F0Y2goKCkgPT4ge30pO1xuICAgIHRoaXMub25NZXNzYWdlKCh7IGV2ZW50IH0pID0+IGV2ZW50ID09PSBcIlNES19ESVNDT05ORUNUXCIgLyogU0RLX0RJU0NPTk5FQ1QgKi8pLnRoZW4oKCkgPT4ge1xuICAgICAgdGhpcy5vbkRpc2Nvbm5lY3RDYWxsYmFjaz8uKCk7XG4gICAgICB0aGlzLm9uUmVxdWVzdENhbmNlbGxlZCgpO1xuICAgIH0pLmNhdGNoKCgpID0+IHt9KTtcbiAgICByZXR1cm4gdGhpcy5vbk1lc3NhZ2UoKHsgZXZlbnQgfSkgPT4gZXZlbnQgPT09IFwiUE9QVVBfTE9BREVEXCIgLyogUE9QVVBfTE9BREVEICovKS50aGVuKChtZXNzYWdlKSA9PiB7XG4gICAgICB0aGlzLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgY2hhaW5JZDogREVGQVVMVF9DSEFJTl9JRCxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGFwcE1ldGFkYXRhOiB0aGlzLmFwcE1ldGFkYXRhLFxuICAgICAgICAgIG9yaWdpbjogd2luZG93LmxvY2F0aW9uLm9yaWdpbixcbiAgICAgICAgICBzZGtWZXJzaW9uOiBTREtfVkVSU0lPTlxuICAgICAgICB9LFxuICAgICAgICBldmVudDogXCJQT1BVUF9BUFBfQ09OVEVYVFwiIC8qIFBPUFVQX0FQUF9DT05URVhUICovLFxuICAgICAgICBvcmlnaW46IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4sXG4gICAgICAgIHJlcXVlc3RJZDogbWVzc2FnZS5yZXF1ZXN0SWRcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSkudGhlbigoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMucG9wdXApXG4gICAgICAgIHRocm93IHJwY0Vycm9ycy5pbnRlcm5hbCgpO1xuICAgICAgcmV0dXJuIHRoaXMucG9wdXA7XG4gICAgfSk7XG4gIH1cbn1cbi8vIHNyYy9zdG9yYWdlL3N0b3JhZ2VJbnRlcmZhY2UudHNcbnZhciBTVE9SQUdFX0VUSF9BQ0NPVU5UU19LRVkgPSBcImV0aC1hY2NvdW50c1wiO1xudmFyIFNUT1JBR0VfRVRIX0FDVElWRV9DSEFJTl9LRVkgPSBcImV0aC1hY3RpdmUtY2hhaW5cIjtcbnZhciBTVE9SQUdFX1BBU1NLRVlfQ1JFREVOVElBTF9LRVkgPSBcInBhc3NrZXktY3JlZGVudGlhbFwiO1xudmFyIFNUT1JBR0VfU01BUlRfQUNDT1VOVF9LRVkgPSBcInNtYXJ0LWFjY291bnRcIjtcbnZhciBTVE9SQUdFX1NFVFRJTkdTX0tFWSA9IFwic2V0dGluZ3NcIjtcblxuLy8gc3JjL3N0b3JhZ2Uvc3RvcmFnZS50c1xudmFyIG1lbW9yeVN0b3JhZ2UgPSB7fTtcbmNsYXNzIEdlbWluaVN0b3JhZ2Uge1xuICBzY29wZSA9IFwiQGdlbWluaVwiO1xuICBtb2R1bGUgPSBcIndhbGxldFwiO1xuICBzY29wZWRLZXkoa2V5KSB7XG4gICAgcmV0dXJuIGAke3RoaXMuc2NvcGV9LiR7dGhpcy5tb2R1bGV9LiR7a2V5fWA7XG4gIH1cbiAgYXN5bmMgc3RvcmVPYmplY3Qoa2V5LCBpdGVtKSB7XG4gICAgY29uc3QganNvbiA9IHNhZmVKc29uU3RyaW5naWZ5KGl0ZW0pO1xuICAgIGF3YWl0IHRoaXMuc2V0SXRlbShrZXksIGpzb24pO1xuICB9XG4gIGFzeW5jIGxvYWRPYmplY3Qoa2V5LCBmYWxsYmFjaykge1xuICAgIGNvbnN0IGl0ZW0gPSBhd2FpdCB0aGlzLmdldEl0ZW0oa2V5KTtcbiAgICBpZiAoIWl0ZW0pIHtcbiAgICAgIGF3YWl0IHRoaXMuc3RvcmVPYmplY3Qoa2V5LCBmYWxsYmFjayk7XG4gICAgICByZXR1cm4gZmFsbGJhY2s7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gSlNPTi5wYXJzZShpdGVtKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgcGFyc2luZyBKU09OIGZvciBrZXkgJHtrZXl9OmAsIGVycm9yKTtcbiAgICAgIHJldHVybiBmYWxsYmFjaztcbiAgICB9XG4gIH1cbiAgc2V0SXRlbShrZXksIHZhbHVlKSB7XG4gICAgY29uc3Qgc2NvcGVkID0gdGhpcy5zY29wZWRLZXkoa2V5KTtcbiAgICB0cnkge1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oc2NvcGVkLCB2YWx1ZSk7XG4gICAgfSBjYXRjaCB7XG4gICAgICBtZW1vcnlTdG9yYWdlW3Njb3BlZF0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9XG4gIGdldEl0ZW0oa2V5KSB7XG4gICAgY29uc3Qgc2NvcGVkID0gdGhpcy5zY29wZWRLZXkoa2V5KTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShsb2NhbFN0b3JhZ2UuZ2V0SXRlbShzY29wZWQpID8/IHVuZGVmaW5lZCk7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG1lbW9yeVN0b3JhZ2Vbc2NvcGVkXSB8fCB1bmRlZmluZWQpO1xuICAgIH1cbiAgfVxuICByZW1vdmVJdGVtKGtleSkge1xuICAgIGNvbnN0IHNjb3BlZCA9IHRoaXMuc2NvcGVkS2V5KGtleSk7XG4gICAgdHJ5IHtcbiAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKHNjb3BlZCk7XG4gICAgfSBjYXRjaCB7XG4gICAgICBkZWxldGUgbWVtb3J5U3RvcmFnZVtzY29wZWRdO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH1cbn1cbi8vIHNyYy93YWxsZXRzL3dhbGxldC50c1xuZnVuY3Rpb24gaXNDaGFpblN1cHBvcnRlZEJ5R2VtaW5pU3coY2hhaW5JZCkge1xuICByZXR1cm4gU1VQUE9SVEVEX0NIQUlOX0lEUy5pbmNsdWRlcyhjaGFpbklkKTtcbn1cblxuY2xhc3MgR2VtaW5pV2FsbGV0IHtcbiAgY29tbXVuaWNhdG9yO1xuICBzdG9yYWdlO1xuICBpbml0UHJvbWlzZTtcbiAgYWNjb3VudHMgPSBbXTtcbiAgY2hhaW4gPSB7IGlkOiBERUZBVUxUX0NIQUlOX0lEIH07XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBhcHBNZXRhZGF0YSxcbiAgICBjaGFpbixcbiAgICBvbkRpc2Nvbm5lY3RDYWxsYmFjayxcbiAgICBzdG9yYWdlXG4gIH0pIHtcbiAgICB0aGlzLmNvbW11bmljYXRvciA9IG5ldyBDb21tdW5pY2F0b3Ioe1xuICAgICAgYXBwTWV0YWRhdGEsXG4gICAgICBvbkRpc2Nvbm5lY3RDYWxsYmFja1xuICAgIH0pO1xuICAgIHRoaXMuc3RvcmFnZSA9IHN0b3JhZ2UgfHwgbmV3IEdlbWluaVN0b3JhZ2U7XG4gICAgY29uc3QgaW5pdGlhbENoYWluID0gY2hhaW4gfHwgeyBpZDogREVGQVVMVF9DSEFJTl9JRCB9O1xuICAgIHRoaXMuaW5pdFByb21pc2UgPSB0aGlzLmluaXRpYWxpemVGcm9tU3RvcmFnZShpbml0aWFsQ2hhaW4pO1xuICB9XG4gIGFzeW5jIGluaXRpYWxpemVGcm9tU3RvcmFnZShkZWZhdWx0Q2hhaW4pIHtcbiAgICBjb25zdCBmYWxsYmFja0NoYWluID0ge1xuICAgICAgaWQ6IGRlZmF1bHRDaGFpbi5pZCxcbiAgICAgIHJwY1VybDogZGVmYXVsdENoYWluLnJwY1VybCB8fCBnZXREZWZhdWx0UnBjVXJsKGRlZmF1bHRDaGFpbi5pZClcbiAgICB9O1xuICAgIGNvbnN0IFtzdG9yZWRDaGFpbiwgc3RvcmVkQWNjb3VudHNdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgdGhpcy5zdG9yYWdlLmxvYWRPYmplY3QoU1RPUkFHRV9FVEhfQUNUSVZFX0NIQUlOX0tFWSwgZmFsbGJhY2tDaGFpbiksXG4gICAgICB0aGlzLnN0b3JhZ2UubG9hZE9iamVjdChTVE9SQUdFX0VUSF9BQ0NPVU5UU19LRVksIHRoaXMuYWNjb3VudHMpXG4gICAgXSk7XG4gICAgdGhpcy5jaGFpbiA9IHtcbiAgICAgIC4uLnN0b3JlZENoYWluLFxuICAgICAgcnBjVXJsOiBzdG9yZWRDaGFpbi5ycGNVcmwgfHwgZ2V0RGVmYXVsdFJwY1VybChzdG9yZWRDaGFpbi5pZClcbiAgICB9O1xuICAgIHRoaXMuYWNjb3VudHMgPSBzdG9yZWRBY2NvdW50cztcbiAgfVxuICBhc3luYyBlbnN1cmVJbml0aWFsaXplZCgpIHtcbiAgICBhd2FpdCB0aGlzLmluaXRQcm9taXNlO1xuICB9XG4gIGFzeW5jIGNvbm5lY3QoKSB7XG4gICAgYXdhaXQgdGhpcy5lbnN1cmVJbml0aWFsaXplZCgpO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5zZW5kTWVzc2FnZVRvUG9wdXAoe1xuICAgICAgY2hhaW5JZDogdGhpcy5jaGFpbi5pZCxcbiAgICAgIGV2ZW50OiBcIlNES19DT05ORUNUXCIgLyogU0RLX0NPTk5FQ1QgKi8sXG4gICAgICBvcmlnaW46IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW5cbiAgICB9KTtcbiAgICB0aGlzLmFjY291bnRzID0gW3Jlc3BvbnNlLmRhdGEuYWRkcmVzc107XG4gICAgYXdhaXQgdGhpcy5zdG9yYWdlLnN0b3JlT2JqZWN0KFNUT1JBR0VfRVRIX0FDQ09VTlRTX0tFWSwgdGhpcy5hY2NvdW50cyk7XG4gICAgcmV0dXJuIHRoaXMuYWNjb3VudHM7XG4gIH1cbiAgYXN5bmMgc3dpdGNoQ2hhaW4oe1xuICAgIGlkXG4gIH0pIHtcbiAgICBhd2FpdCB0aGlzLmVuc3VyZUluaXRpYWxpemVkKCk7XG4gICAgaWYgKGlzQ2hhaW5TdXBwb3J0ZWRCeUdlbWluaVN3KGlkKSkge1xuICAgICAgdGhpcy5jaGFpbiA9IHtcbiAgICAgICAgaWQsXG4gICAgICAgIHJwY1VybDogZ2V0RGVmYXVsdFJwY1VybChpZClcbiAgICAgIH07XG4gICAgICBhd2FpdCB0aGlzLnN0b3JhZ2Uuc3RvcmVPYmplY3QoU1RPUkFHRV9FVEhfQUNUSVZFX0NIQUlOX0tFWSwgdGhpcy5jaGFpbik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5zZW5kTWVzc2FnZVRvUG9wdXAoe1xuICAgICAgY2hhaW5JZDogdGhpcy5jaGFpbi5pZCxcbiAgICAgIGRhdGE6IGlkLFxuICAgICAgZXZlbnQ6IFwiU0RLX1NXSVRDSF9DSEFJTlwiIC8qIFNES19TV0lUQ0hfQ0hBSU4gKi8sXG4gICAgICBvcmlnaW46IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW5cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YS5lcnJvcjtcbiAgfVxuICBhc3luYyBzZW5kVHJhbnNhY3Rpb24odHhEYXRhKSB7XG4gICAgYXdhaXQgdGhpcy5lbnN1cmVJbml0aWFsaXplZCgpO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5zZW5kTWVzc2FnZVRvUG9wdXAoe1xuICAgICAgY2hhaW5JZDogdGhpcy5jaGFpbi5pZCxcbiAgICAgIGRhdGE6IHR4RGF0YSxcbiAgICAgIGV2ZW50OiBcIlNES19TRU5EX1RSQU5TQUNUSU9OXCIgLyogU0RLX1NFTkRfVFJBTlNBQ1RJT04gKi8sXG4gICAgICBvcmlnaW46IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW5cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgfVxuICBhc3luYyBzaWduRGF0YSh7XG4gICAgbWVzc2FnZVxuICB9KSB7XG4gICAgYXdhaXQgdGhpcy5lbnN1cmVJbml0aWFsaXplZCgpO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5zZW5kTWVzc2FnZVRvUG9wdXAoe1xuICAgICAgY2hhaW5JZDogdGhpcy5jaGFpbi5pZCxcbiAgICAgIGRhdGE6IHsgbWVzc2FnZSB9LFxuICAgICAgZXZlbnQ6IFwiU0RLX1NJR05fREFUQVwiIC8qIFNES19TSUdOX0RBVEEgKi8sXG4gICAgICBvcmlnaW46IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW5cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgfVxuICBhc3luYyBzaWduVHlwZWREYXRhKHtcbiAgICBtZXNzYWdlLFxuICAgIHR5cGVzLFxuICAgIHByaW1hcnlUeXBlLFxuICAgIGRvbWFpblxuICB9KSB7XG4gICAgYXdhaXQgdGhpcy5lbnN1cmVJbml0aWFsaXplZCgpO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5zZW5kTWVzc2FnZVRvUG9wdXAoe1xuICAgICAgY2hhaW5JZDogdGhpcy5jaGFpbi5pZCxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgZG9tYWluLFxuICAgICAgICBtZXNzYWdlLFxuICAgICAgICBwcmltYXJ5VHlwZSxcbiAgICAgICAgdHlwZXNcbiAgICAgIH0sXG4gICAgICBldmVudDogXCJTREtfU0lHTl9UWVBFRF9EQVRBXCIgLyogU0RLX1NJR05fVFlQRURfREFUQSAqLyxcbiAgICAgIG9yaWdpbjogd2luZG93LmxvY2F0aW9uLm9yaWdpblxuICAgIH0pO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICB9XG4gIGFzeW5jIG9wZW5TZXR0aW5ncygpIHtcbiAgICBhd2FpdCB0aGlzLmVuc3VyZUluaXRpYWxpemVkKCk7XG4gICAgYXdhaXQgdGhpcy5zZW5kTWVzc2FnZVRvUG9wdXAoe1xuICAgICAgY2hhaW5JZDogdGhpcy5jaGFpbi5pZCxcbiAgICAgIGRhdGE6IHt9LFxuICAgICAgZXZlbnQ6IFwiU0RLX09QRU5fU0VUVElOR1NcIiAvKiBTREtfT1BFTl9TRVRUSU5HUyAqLyxcbiAgICAgIG9yaWdpbjogd2luZG93LmxvY2F0aW9uLm9yaWdpblxuICAgIH0pO1xuICB9XG4gIHNlbmRNZXNzYWdlVG9Qb3B1cChyZXF1ZXN0KSB7XG4gICAgcmV0dXJuIHRoaXMuY29tbXVuaWNhdG9yLnBvc3RSZXF1ZXN0QW5kV2FpdEZvclJlc3BvbnNlKHtcbiAgICAgIC4uLnJlcXVlc3QsXG4gICAgICByZXF1ZXN0SWQ6IHdpbmRvdz8uY3J5cHRvPy5yYW5kb21VVUlEKClcbiAgICB9KTtcbiAgfVxufVxuLy8gc3JjL3Byb3ZpZGVyL3Byb3ZpZGVyLnV0aWxzLnRzXG52YXIgZmV0Y2hScGNSZXF1ZXN0ID0gYXN5bmMgKHJlcXVlc3QsIHJwY1VybCkgPT4ge1xuICBjb25zdCByZXF1ZXN0Qm9keSA9IHtcbiAgICAuLi5yZXF1ZXN0LFxuICAgIGlkOiB3aW5kb3c/LmNyeXB0bz8ucmFuZG9tVVVJRCgpLFxuICAgIGpzb25ycGM6IFwiMi4wXCJcbiAgfTtcbiAgY29uc3QgcmVzID0gYXdhaXQgd2luZG93LmZldGNoKHJwY1VybCwge1xuICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHJlcXVlc3RCb2R5KSxcbiAgICBoZWFkZXJzOiB7XG4gICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgIH0sXG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICBtb2RlOiBcImNvcnNcIlxuICB9KTtcbiAgY29uc3QgeyByZXN1bHQsIGVycm9yIH0gPSBhd2FpdCByZXMuanNvbigpO1xuICBpZiAoZXJyb3IpIHtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcbmZ1bmN0aW9uIHZhbGlkYXRlUnBjUmVxdWVzdEFyZ3MoYXJncykge1xuICBpZiAoIWFyZ3MgfHwgdHlwZW9mIGFyZ3MgIT09IFwib2JqZWN0XCIgfHwgQXJyYXkuaXNBcnJheShhcmdzKSkge1xuICAgIHRocm93IHJwY0Vycm9ycy5pbnZhbGlkUGFyYW1zKHtcbiAgICAgIG1lc3NhZ2U6IFwiRXhwZWN0ZWQgYSBzaW5nbGUsIG5vbi1hcnJheSwgb2JqZWN0IGFyZ3VtZW50LlwiXG4gICAgfSk7XG4gIH1cbiAgY29uc3QgeyBtZXRob2QsIHBhcmFtcyB9ID0gYXJncztcbiAgaWYgKHR5cGVvZiBtZXRob2QgIT09IFwic3RyaW5nXCIgfHwgbWV0aG9kLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IHJwY0Vycm9ycy5pbnZhbGlkUGFyYW1zKHtcbiAgICAgIG1lc3NhZ2U6IFwiJ2FyZ3MubWV0aG9kJyBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZy5cIlxuICAgIH0pO1xuICB9XG4gIGlmIChwYXJhbXMgIT09IHVuZGVmaW5lZCAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXMpICYmICh0eXBlb2YgcGFyYW1zICE9PSBcIm9iamVjdFwiIHx8IHBhcmFtcyA9PT0gbnVsbCkpIHtcbiAgICB0aHJvdyBycGNFcnJvcnMuaW52YWxpZFBhcmFtcyh7XG4gICAgICBtZXNzYWdlOiBcIidhcmdzLnBhcmFtcycgbXVzdCBiZSBhbiBvYmplY3Qgb3IgYXJyYXkgaWYgcHJvdmlkZWQuXCJcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gY29udmVydFNlbmRWYWx1ZXNUb0JpZ0ludCh0eCkge1xuICBjb25zdCBGSUVMRFNfVE9fTk9STUFMSVpFID0gW1widmFsdWVcIiwgXCJnYXNcIiwgXCJnYXNQcmljZVwiLCBcIm1heFByaW9yaXR5RmVlUGVyR2FzXCIsIFwibWF4RmVlUGVyR2FzXCJdO1xuICBjb25zdCBub3JtYWxpemVkID0geyAuLi50eCB9O1xuICBmb3IgKGNvbnN0IGZpZWxkIG9mIEZJRUxEU19UT19OT1JNQUxJWkUpIHtcbiAgICBpZiAoIShmaWVsZCBpbiB0eCkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IHR4W2ZpZWxkXTtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcImJpZ2ludFwiKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGlzSGV4KHZhbHVlKSkge1xuICAgICAgbm9ybWFsaXplZFtmaWVsZF0gPSBCaWdJbnQodmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbm9ybWFsaXplZDtcbn1cblxuLy8gc3JjL3Byb3ZpZGVyL3Byb3ZpZGVyLnRzXG5jbGFzcyBHZW1pbmlXYWxsZXRQcm92aWRlciBleHRlbmRzIFByb3ZpZGVyRXZlbnRFbWl0dGVyIHtcbiAgY29uZmlnO1xuICB3YWxsZXQgPSB1bmRlZmluZWQ7XG4gIGNvbnN0cnVjdG9yKHByb3ZpZGVyQ29uZmlnKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmNvbmZpZyA9IHByb3ZpZGVyQ29uZmlnO1xuICAgIGNvbnN0IHVzZXJEaXNjb25uZWN0Q2FsbGJhY2sgPSBwcm92aWRlckNvbmZpZy5vbkRpc2Nvbm5lY3RDYWxsYmFjaztcbiAgICB0aGlzLndhbGxldCA9IG5ldyBHZW1pbmlXYWxsZXQoe1xuICAgICAgLi4ucHJvdmlkZXJDb25maWcsXG4gICAgICBvbkRpc2Nvbm5lY3RDYWxsYmFjazogKCkgPT4ge1xuICAgICAgICB1c2VyRGlzY29ubmVjdENhbGxiYWNrPy4oKTtcbiAgICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgcmVxdWVzdChhcmdzKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhbGlkYXRlUnBjUmVxdWVzdEFyZ3MoYXJncyk7XG4gICAgICBpZiAoIXRoaXMud2FsbGV0Py5hY2NvdW50cz8ubGVuZ3RoKSB7XG4gICAgICAgIHN3aXRjaCAoYXJncy5tZXRob2QpIHtcbiAgICAgICAgICBjYXNlIFwiZXRoX3JlcXVlc3RBY2NvdW50c1wiOiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMud2FsbGV0KSB7XG4gICAgICAgICAgICAgIGNvbnN0IHVzZXJEaXNjb25uZWN0Q2FsbGJhY2sgPSB0aGlzLmNvbmZpZy5vbkRpc2Nvbm5lY3RDYWxsYmFjaztcbiAgICAgICAgICAgICAgdGhpcy53YWxsZXQgPSBuZXcgR2VtaW5pV2FsbGV0KHtcbiAgICAgICAgICAgICAgICAuLi50aGlzLmNvbmZpZyxcbiAgICAgICAgICAgICAgICBvbkRpc2Nvbm5lY3RDYWxsYmFjazogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgdXNlckRpc2Nvbm5lY3RDYWxsYmFjaz8uKCk7XG4gICAgICAgICAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgdGhpcy53YWxsZXQuY29ubmVjdCgpO1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiYWNjb3VudHNDaGFuZ2VkXCIsIHRoaXMud2FsbGV0LmFjY291bnRzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwibmV0X3ZlcnNpb25cIjpcbiAgICAgICAgICAgIHJldHVybiBERUZBVUxUX0NIQUlOX0lEO1xuICAgICAgICAgIGNhc2UgXCJldGhfY2hhaW5JZFwiOlxuICAgICAgICAgICAgcmV0dXJuIGhleFN0cmluZ0Zyb21OdW1iZXIoREVGQVVMVF9DSEFJTl9JRCk7XG4gICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgdGhyb3cgcHJvdmlkZXJFcnJvcnMudW5hdXRob3JpemVkKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICBsZXQgcmVxdWVzdFBhcmFtcztcbiAgICAgIHN3aXRjaCAoYXJncy5tZXRob2QpIHtcbiAgICAgICAgY2FzZSBcImV0aF9yZXF1ZXN0QWNjb3VudHNcIjpcbiAgICAgICAgY2FzZSBcImV0aF9hY2NvdW50c1wiOlxuICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy53YWxsZXQuYWNjb3VudHM7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJuZXRfdmVyc2lvblwiOlxuICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy53YWxsZXQuY2hhaW4uaWQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJldGhfY2hhaW5JZFwiOlxuICAgICAgICAgIHJlc3BvbnNlID0gaGV4U3RyaW5nRnJvbU51bWJlcih0aGlzLndhbGxldC5jaGFpbi5pZCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJwZXJzb25hbF9zaWduXCI6XG4gICAgICAgIGNhc2UgXCJ3YWxsZXRfc2lnblwiOlxuICAgICAgICAgIHJlcXVlc3RQYXJhbXMgPSBhcmdzLnBhcmFtcztcbiAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IHRoaXMud2FsbGV0LnNpZ25EYXRhKHtcbiAgICAgICAgICAgIGFjY291bnQ6IHJlcXVlc3RQYXJhbXNbMV0sXG4gICAgICAgICAgICBtZXNzYWdlOiByZXF1ZXN0UGFyYW1zWzBdXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKHJlc3BvbnNlLmVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBycGNFcnJvcnMudHJhbnNhY3Rpb25SZWplY3RlZChyZXNwb25zZS5lcnJvcik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gcmVzcG9uc2UuaGFzaDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJldGhfc2VuZFRyYW5zYWN0aW9uXCI6XG4gICAgICAgIGNhc2UgXCJ3YWxsZXRfc2VuZFRyYW5zYWN0aW9uXCI6XG4gICAgICAgICAgcmVxdWVzdFBhcmFtcyA9IGFyZ3MucGFyYW1zO1xuICAgICAgICAgIHJlcXVlc3RQYXJhbXMgPSBjb252ZXJ0U2VuZFZhbHVlc1RvQmlnSW50KHJlcXVlc3RQYXJhbXNbMF0pO1xuICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgdGhpcy53YWxsZXQuc2VuZFRyYW5zYWN0aW9uKHJlcXVlc3RQYXJhbXMpO1xuICAgICAgICAgIGlmIChyZXNwb25zZS5lcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgcnBjRXJyb3JzLnRyYW5zYWN0aW9uUmVqZWN0ZWQocmVzcG9uc2UuZXJyb3IpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNwb25zZSA9IHJlc3BvbnNlLmhhc2g7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwid2FsbGV0X3N3aXRjaEV0aGVyZXVtQ2hhaW5cIjoge1xuICAgICAgICAgIGNvbnN0IHJhd1BhcmFtcyA9IGFyZ3MucGFyYW1zO1xuICAgICAgICAgIGxldCBjaGFpbklkO1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJhd1BhcmFtcykgJiYgcmF3UGFyYW1zWzBdPy5jaGFpbklkKSB7XG4gICAgICAgICAgICBjaGFpbklkID0gcGFyc2VJbnQocmF3UGFyYW1zWzBdLmNoYWluSWQsIDE2KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHJhd1BhcmFtcyAmJiB0eXBlb2YgcmF3UGFyYW1zID09PSBcIm9iamVjdFwiICYmIFwiaWRcIiBpbiByYXdQYXJhbXMgJiYgTnVtYmVyLmlzSW50ZWdlcihyYXdQYXJhbXMuaWQpKSB7XG4gICAgICAgICAgICBjaGFpbklkID0gcmF3UGFyYW1zLmlkO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBycGNFcnJvcnMuaW52YWxpZFBhcmFtcyhcIkludmFsaWQgY2hhaW4gaWQgYXJndW1lbnQuIEV4cGVjdGVkIFt7IGNoYWluSWQ6IGhleF9zdHJpbmcgfV0gb3IgeyBpZDogbnVtYmVyIH0uXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IHRoaXMud2FsbGV0LnN3aXRjaENoYWluKHsgaWQ6IGNoYWluSWQgfSk7XG4gICAgICAgICAgaWYgKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICB0aHJvdyBwcm92aWRlckVycm9ycy5jdXN0b20oeyBjb2RlOiA0OTAyLCBtZXNzYWdlOiByZXNwb25zZSB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXdhaXQgdGhpcy5lbWl0KFwiY2hhaW5DaGFuZ2VkXCIsIGhleFN0cmluZ0Zyb21OdW1iZXIoY2hhaW5JZCkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJldGhfc2lnblR5cGVkRGF0YV92MVwiOlxuICAgICAgICBjYXNlIFwiZXRoX3NpZ25UeXBlZERhdGFfdjJcIjpcbiAgICAgICAgY2FzZSBcImV0aF9zaWduVHlwZWREYXRhX3YzXCI6XG4gICAgICAgIGNhc2UgXCJldGhfc2lnblR5cGVkRGF0YV92NFwiOlxuICAgICAgICBjYXNlIFwiZXRoX3NpZ25UeXBlZERhdGFcIjoge1xuICAgICAgICAgIHJlcXVlc3RQYXJhbXMgPSBhcmdzLnBhcmFtcztcbiAgICAgICAgICBjb25zdCBzaWduZWRUeXBlZERhdGFQYXJhbXMgPSBKU09OLnBhcnNlKHJlcXVlc3RQYXJhbXNbMV0pO1xuICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgdGhpcy53YWxsZXQuc2lnblR5cGVkRGF0YSh7XG4gICAgICAgICAgICBhY2NvdW50OiByZXF1ZXN0UGFyYW1zWzBdLFxuICAgICAgICAgICAgZG9tYWluOiBzaWduZWRUeXBlZERhdGFQYXJhbXMuZG9tYWluLFxuICAgICAgICAgICAgbWVzc2FnZTogc2lnbmVkVHlwZWREYXRhUGFyYW1zLm1lc3NhZ2UsXG4gICAgICAgICAgICBwcmltYXJ5VHlwZTogc2lnbmVkVHlwZWREYXRhUGFyYW1zLnByaW1hcnlUeXBlLFxuICAgICAgICAgICAgdHlwZXM6IHNpZ25lZFR5cGVkRGF0YVBhcmFtcy50eXBlc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChyZXNwb25zZS5lcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgcnBjRXJyb3JzLnRyYW5zYWN0aW9uUmVqZWN0ZWQocmVzcG9uc2UuZXJyb3IpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNwb25zZSA9IHJlc3BvbnNlLmhhc2g7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJldGhfZWNSZWNvdmVyXCI6XG4gICAgICAgIGNhc2UgXCJldGhfc3Vic2NyaWJlXCI6XG4gICAgICAgIGNhc2UgXCJldGhfdW5zdWJzY3JpYmVcIjpcbiAgICAgICAgY2FzZSBcInBlcnNvbmFsX2VjUmVjb3ZlclwiOlxuICAgICAgICBjYXNlIFwiZXRoX3NpZ25UcmFuc2FjdGlvblwiOlxuICAgICAgICBjYXNlIFwid2FsbGV0X3dhdGNoQXNzZXRcIjpcbiAgICAgICAgY2FzZSBcIndhbGxldF9zZW5kQ2FsbHNcIjpcbiAgICAgICAgY2FzZSBcIndhbGxldF9nZXRDYWxsc1N0YXR1c1wiOlxuICAgICAgICBjYXNlIFwid2FsbGV0X2dldENhcGFiaWxpdGllc1wiOlxuICAgICAgICBjYXNlIFwid2FsbGV0X3Nob3dDYWxsc1N0YXR1c1wiOlxuICAgICAgICBjYXNlIFwid2FsbGV0X2dyYW50UGVybWlzc2lvbnNcIjpcbiAgICAgICAgICB0aHJvdyBycGNFcnJvcnMubWV0aG9kTm90U3VwcG9ydGVkKFwiTm90IHlldCBpbXBsZW1lbnRlZC5cIik7XG4gICAgICAgIGNhc2UgXCJldGhfc2lnblwiOlxuICAgICAgICBjYXNlIFwiZXRoX2NvaW5iYXNlXCI6XG4gICAgICAgIGNhc2UgXCJ3YWxsZXRfYWRkRXRoZXJldW1DaGFpblwiOlxuICAgICAgICAgIHRocm93IHJwY0Vycm9ycy5tZXRob2ROb3RTdXBwb3J0ZWQoKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAoIXRoaXMud2FsbGV0LmNoYWluLnJwY1VybCkge1xuICAgICAgICAgICAgdGhyb3cgcnBjRXJyb3JzLmludGVybmFsKGBSUEMgVVJMIG1pc3NpbmcgZm9yIGN1cnJlbnQgY2hhaW4gKCR7dGhpcy53YWxsZXQuY2hhaW4uaWR9KWApO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZmV0Y2hScGNSZXF1ZXN0KGFyZ3MsIHRoaXMud2FsbGV0LmNoYWluLnJwY1VybCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnN0IHsgY29kZSB9ID0gZXJyb3I7XG4gICAgICBpZiAoY29kZSA9PT0gZXJyb3JDb2Rlcy5wcm92aWRlci51bmF1dGhvcml6ZWQpIHtcbiAgICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3Qoc2VyaWFsaXplRXJyb3IoZXJyb3IpKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgb3BlblNldHRpbmdzKCkge1xuICAgIGF3YWl0IHRoaXMud2FsbGV0Py5vcGVuU2V0dGluZ3MoKTtcbiAgfVxuICBhc3luYyByZXZlcnNlUmVzb2x2ZUVucyhhZGRyZXNzKSB7XG4gICAgcmV0dXJuIGF3YWl0IHJldmVyc2VSZXNvbHZlRW5zKGFkZHJlc3MpO1xuICB9XG4gIGFzeW5jIGRpc2Nvbm5lY3QoKSB7XG4gICAgaWYgKHRoaXMud2FsbGV0KSB7XG4gICAgICBjb25zdCBzdG9yYWdlID0gdGhpcy5jb25maWcuc3RvcmFnZSB8fCBuZXcgR2VtaW5pU3RvcmFnZTtcbiAgICAgIGF3YWl0IHN0b3JhZ2UucmVtb3ZlSXRlbShTVE9SQUdFX0VUSF9BQ0NPVU5UU19LRVkpO1xuICAgICAgYXdhaXQgc3RvcmFnZS5yZW1vdmVJdGVtKFNUT1JBR0VfRVRIX0FDVElWRV9DSEFJTl9LRVkpO1xuICAgIH1cbiAgICB0aGlzLndhbGxldCA9IHVuZGVmaW5lZDtcbiAgICBhd2FpdCB0aGlzLmVtaXQoXCJkaXNjb25uZWN0XCIsIFwiVXNlciBpbml0aWF0ZWQgZGlzY29ubmVjdGlvblwiKTtcbiAgfVxufVxuZXhwb3J0IHtcbiAgdmFsaWRhdGVXZWJBdXRobktleSxcbiAgdmFsaWRhdGVScGNSZXF1ZXN0QXJncyxcbiAgdXRmOFN0cmluZ1RvQnVmZmVyLFxuICBzYWZlSnNvblN0cmluZ2lmeSxcbiAgcmV2ZXJzZVJlc29sdmVFbnMsXG4gIG9wZW5Qb3B1cCxcbiAgaGV4U3RyaW5nRnJvbU51bWJlcixcbiAgZ2VuZXJhdGVSZXF1ZXN0SWQsXG4gIGdlbmVyYXRlQXV0aGVudGljYXRvcklkSGFzaCxcbiAgZmV0Y2hScGNSZXF1ZXN0LFxuICBlbmNvZGVCYXNlNjQsXG4gIGRlY29kZUJhc2U2NCxcbiAgY29udmVydFNlbmRWYWx1ZXNUb0JpZ0ludCxcbiAgY2xvc2VQb3B1cCxcbiAgY2FsY3VsYXRlV2FsbGV0QWRkcmVzcyxcbiAgYnVmZmVyVG9CYXNlNjRVUkxTdHJpbmcsXG4gIGJhc2U2NFRvSGV4LFxuICBTVE9SQUdFX1NNQVJUX0FDQ09VTlRfS0VZLFxuICBTVE9SQUdFX1NFVFRJTkdTX0tFWSxcbiAgU1RPUkFHRV9QQVNTS0VZX0NSRURFTlRJQUxfS0VZLFxuICBTVE9SQUdFX0VUSF9BQ1RJVkVfQ0hBSU5fS0VZLFxuICBTVE9SQUdFX0VUSF9BQ0NPVU5UU19LRVksXG4gIFNES19WRVJTSU9OLFxuICBTREtfQkFDS0VORF9VUkwsXG4gIFByb3ZpZGVyRXZlbnRFbWl0dGVyLFxuICBQT1BVUF9XSURUSCxcbiAgUE9QVVBfSEVJR0hULFxuICBHZW1pbmlXYWxsZXRQcm92aWRlcixcbiAgR2VtaW5pV2FsbGV0LFxuICBHZW1pbmlTdG9yYWdlLFxuICBHZW1pbmlTZGtFdmVudCxcbiAgREVGQVVMVF9DSEFJTl9JRCxcbiAgQ29tbXVuaWNhdG9yXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@gemini-wallet/core/dist/index.js\n");

/***/ })

};
;